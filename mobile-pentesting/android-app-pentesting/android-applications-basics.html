<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Android Applications Basics</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="android-applications-basics"><a class="header" href="#android-applications-basics">Android Applications Basics</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="android-security-model"><a class="header" href="#android-security-model">Android Security Model</a></h2>
<p><strong>有两个层次：</strong></p>
<ul>
<li><strong>操作系统</strong>，它使已安装的应用程序彼此隔离。</li>
<li><strong>应用程序本身</strong>，它允许开发人员<strong>暴露某些功能</strong>并配置应用程序能力。</li>
</ul>
<h3 id="uid-separation"><a class="header" href="#uid-separation">UID Separation</a></h3>
<p><strong>每个应用程序被分配一个特定的用户 ID</strong>。这在应用程序安装期间完成，因此<strong>该应用程序只能与其用户 ID 所拥有的文件或共享文件进行交互</strong>。因此，只有应用程序本身、操作系统的某些组件和根用户可以访问应用程序的数据。</p>
<h3 id="uid-sharing"><a class="header" href="#uid-sharing">UID Sharing</a></h3>
<p><strong>两个应用程序可以配置为使用相同的 UID</strong>。这可以用于共享信息，但如果其中一个被攻破，则两个应用程序的数据都会受到影响。这就是为什么这种行为<strong>不被鼓励</strong>。<br />
<strong>要共享相同的 UID，应用程序必须在其清单中定义相同的 <code>android:sharedUserId</code> 值。</strong></p>
<h3 id="sandboxing"><a class="header" href="#sandboxing">Sandboxing</a></h3>
<p><strong>Android 应用程序沙箱</strong>允许<strong>每个应用程序</strong>作为<strong>在单独用户 ID 下的单独进程运行</strong>。每个进程都有自己的虚拟机，因此应用程序的代码与其他应用程序隔离运行。<br />
从 Android 5.0(L) 开始，<strong>SELinux</strong> 被强制执行。基本上，SELinux 拒绝所有进程交互，然后创建策略以<strong>仅允许它们之间的预期交互</strong>。</p>
<h3 id="permissions"><a class="header" href="#permissions">Permissions</a></h3>
<p>当你安装一个<strong>应用程序并请求权限</strong>时，该应用程序是在请求<strong>AndroidManifest.xml</strong> 文件中配置的**<code>uses-permission</code>** 元素中的权限。<strong>uses-permission</strong> 元素在<strong>name</strong> <strong>属性中指示请求的权限名称。<strong>它还有</strong>maxSdkVersion</strong> 属性，该属性在版本高于指定版本时停止请求权限。<br />
请注意，Android 应用程序不需要在开始时请求所有权限，它们也可以<strong>动态请求权限</strong>，但所有权限必须在<strong>清单中声明</strong>。</p>
<p>当应用程序暴露功能时，它可以限制<strong>仅允许具有指定权限的应用程序访问</strong>。<br />
权限元素有三个属性：</p>
<ul>
<li>权限的<strong>名称</strong></li>
<li><strong>permission-group</strong> 属性，允许对相关权限进行分组。</li>
<li><strong>protection-level</strong>，指示权限的授予方式。共有四种类型：</li>
<li><strong>Normal</strong>：用于<strong>没有已知威胁</strong>的应用程序。用户<strong>不需要批准</strong>它。</li>
<li><strong>Dangerous</strong>：指示权限授予请求应用程序某些<strong>提升的访问权限</strong>。<strong>请求用户批准</strong>。</li>
<li><strong>Signature</strong>：只有<strong>与导出组件的相同证书签名的应用程序</strong>才能获得权限。这是最强的保护类型。</li>
<li><strong>SignatureOrSystem</strong>：只有<strong>与导出组件的相同证书签名的应用程序</strong>或<strong>以系统级访问权限运行的应用程序</strong>才能获得权限。</li>
</ul>
<h2 id="pre-installed-applications"><a class="header" href="#pre-installed-applications">Pre-Installed Applications</a></h2>
<p>这些应用程序通常位于**<code>/system/app</code>** 或 <strong><code>/system/priv-app</code></strong> 目录中，其中一些是<strong>优化过的</strong>（你可能甚至找不到 <code>classes.dex</code> 文件）。这些应用程序值得检查，因为有时它们<strong>运行的权限过多</strong>（作为 root）。</p>
<ul>
<li>随 <strong>AOSP</strong>（Android 开源项目）<strong>ROM</strong> 一起提供的应用程序</li>
<li>由设备<strong>制造商</strong>添加的</li>
<li>由手机<strong>提供商</strong>添加的（如果是从他们那里购买的）</li>
</ul>
<h2 id="rooting"><a class="header" href="#rooting">Rooting</a></h2>
<p>为了获得物理 Android 设备的 root 访问权限，通常需要<strong>利用</strong> 1 或 2 个<strong>漏洞</strong>，这些漏洞通常是<strong>特定于设备</strong>和<strong>版本</strong>的。<br />
一旦利用成功，通常会将 Linux <code>su</code> 二进制文件复制到用户 PATH 环境变量指定的位置，如 <code>/system/xbin</code>。</p>
<p>一旦配置了 su 二进制文件，另一个 Android 应用程序将用于与 <code>su</code> 二进制文件接口并<strong>处理 root 访问请求</strong>，如 <strong>Superuser</strong> 和 <strong>SuperSU</strong>（在 Google Play 商店中可用）。</p>
<p>{% hint style="danger" %}
请注意，rooting 过程非常危险，可能会严重损坏设备
{% endhint %}</p>
<h3 id="roms"><a class="header" href="#roms">ROMs</a></h3>
<p>可以通过<strong>安装自定义固件来替换操作系统</strong>。这样可以扩展旧设备的用途，绕过软件限制或访问最新的 Android 代码。<br />
<strong>OmniROM</strong> 和 <strong>LineageOS</strong> 是两个最流行的固件。</p>
<p>请注意，<strong>并不总是需要 root 设备</strong>才能安装自定义固件。<strong>一些制造商允许</strong>以良好文档和安全的方式解锁其引导加载程序。</p>
<h3 id="implications"><a class="header" href="#implications">Implications</a></h3>
<p>一旦设备被 root，任何应用程序都可以请求 root 访问权限。如果恶意应用程序获得了它，它几乎可以访问所有内容，并能够损坏手机。</p>
<h2 id="android-application-fundamentals"><a class="header" href="#android-application-fundamentals">Android Application Fundamentals <a href="#2-android-application-fundamentals" id="2-android-application-fundamentals"></a></a></h2>
<ul>
<li>Android 应用程序的格式被称为 <em>APK 文件格式</em>。它本质上是一个<strong>ZIP 文件</strong>（通过将文件扩展名重命名为 .zip，可以提取和查看内容）。</li>
<li>APK 内容（不详尽）</li>
<li><strong>AndroidManifest.xml</strong></li>
<li>resources.arsc/strings.xml</li>
<li>resources.arsc：包含预编译资源，如二进制 XML。</li>
<li>res/xml/files_paths.xml</li>
<li>META-INF/</li>
<li>这里是证书所在的位置！</li>
<li><strong>classes.dex</strong></li>
<li>包含 Dalvik 字节码，表示应用程序默认执行的编译 Java（或 Kotlin）代码。</li>
<li>lib/</li>
<li>存放本地库，按 CPU 架构在子目录中分隔。</li>
<li><code>armeabi</code>：ARM 处理器的代码</li>
<li><code>armeabi-v7a</code>：ARMv7 及更高版本处理器的代码</li>
<li><code>x86</code>：X86 处理器的代码</li>
<li><code>mips</code>：仅用于 MIPS 处理器的代码</li>
<li>assets/</li>
<li>存储应用程序所需的杂项文件，可能包括额外的本地库或 DEX 文件，有时被恶意软件作者用来隐藏额外代码。</li>
<li>res/</li>
<li>包含未编译到 resources.arsc 中的资源。</li>
</ul>
<h3 id="dalvik--smali"><a class="header" href="#dalvik--smali"><strong>Dalvik &amp; Smali</strong></a></h3>
<p>在 Android 开发中，<strong>Java 或 Kotlin</strong> 用于创建应用程序。与桌面应用程序使用 JVM 不同，Android 将此代码编译为<strong>Dalvik 可执行文件（DEX 字节码）</strong>。早期，Dalvik 虚拟机处理此字节码，但现在，Android Runtime (ART) 在较新版本的 Android 中接管。</p>
<p>对于逆向工程，<strong>Smali</strong> 变得至关重要。它是 DEX 字节码的人类可读版本，像汇编语言一样通过将源代码转换为字节码指令。Smali 和 baksmali 在此上下文中指代汇编和反汇编工具。</p>
<h2 id="intents"><a class="header" href="#intents">Intents</a></h2>
<p>Intents 是 Android 应用程序在其组件之间或与其他应用程序之间通信的主要方式。这些消息对象还可以在应用程序或组件之间携带数据，类似于 HTTP 通信中使用的 GET/POST 请求。</p>
<p>因此，Intent 基本上是<strong>在组件之间传递的消息</strong>。Intents <strong>可以定向</strong>到特定组件或应用程序，<strong>也可以在没有特定接收者的情况下发送</strong>。<br />
简单来说，Intent 可以用于：</p>
<ul>
<li>启动一个 Activity，通常打开应用程序的用户界面</li>
<li>作为广播通知系统和应用程序的变化</li>
<li>启动、停止和与后台服务通信</li>
<li>通过 ContentProviders 访问数据</li>
<li>作为回调处理事件</li>
</ul>
<p>如果存在漏洞，<strong>Intents 可以用于执行各种攻击</strong>。</p>
<h3 id="intent-filter"><a class="header" href="#intent-filter">Intent-Filter</a></h3>
<p><strong>Intent Filters</strong> 定义<strong>活动、服务或广播接收器如何与不同类型的 Intents 交互</strong>。本质上，它们描述了这些组件的能力，例如它们可以执行的操作或可以处理的广播类型。声明这些过滤器的主要位置是在<strong>AndroidManifest.xml 文件</strong>中，尽管对于广播接收器，编码它们也是一个选项。</p>
<p>Intent Filters 由类别、操作和数据过滤器组成，并可以包含附加元数据。此设置允许组件处理与声明的标准匹配的特定 Intents。</p>
<p>Android 组件（活动/服务/内容提供者/广播接收器）的一个关键方面是它们的可见性或<strong>公共状态</strong>。如果组件被**<code>exported</code>** 设置为 <strong><code>true</code></strong>，或者在清单中声明了 Intent Filter，则该组件被视为公共并可以与其他应用程序交互。然而，开发人员可以通过将**<code>exported</code>** 属性设置为 <strong><code>false</code></strong> 来显式保持这些组件私有，确保它们不会与其他应用程序意外交互。</p>
<p>此外，开发人员还有选择进一步保护对这些组件的访问的选项，要求特定权限。<strong><code>permission</code></strong> 属性可以设置为强制要求只有具有指定权限的应用程序才能访问该组件，从而增加了安全性和对谁可以与其交互的控制。</p>
<pre><code class="language-java">&lt;activity android:name=".MyActivity" android:exported="false"&gt;
&lt;!-- Intent filters go here --&gt;
&lt;/activity&gt;
</code></pre>
<h3 id="隐式意图"><a class="header" href="#隐式意图">隐式意图</a></h3>
<p>意图是通过意图构造函数以编程方式创建的：</p>
<pre><code class="language-java">Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
</code></pre>
<p>The <strong>Action</strong> of the previously declared intent is <strong>ACTION_SEND</strong> and the <strong>Extra</strong> is a mailto <strong>Uri</strong> (the Extra if the extra information the intent is expecting).</p>
<p>此意图应在清单中声明，如以下示例所示：</p>
<pre><code class="language-xml">&lt;activity android:name="ShareActivity"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.SEND" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>一个 intent-filter 需要匹配 <strong>action</strong>、<strong>data</strong> 和 <strong>category</strong> 才能接收消息。</p>
<p>“Intent 解析”过程决定了哪个应用程序应该接收每个消息。这个过程考虑了 <strong>priority attribute</strong>，可以在 <strong>intent-filter 声明</strong>中设置，<strong>优先级更高的将被选择</strong>。这个优先级可以设置在 -1000 到 1000 之间，应用程序可以使用 <code>SYSTEM_HIGH_PRIORITY</code> 值。如果出现 <strong>冲突</strong>，将出现一个“选择器”窗口，以便 <strong>用户可以决定</strong>。</p>
<h3 id="显式-intent"><a class="header" href="#显式-intent">显式 Intent</a></h3>
<p>显式 intent 指定了它所针对的类名：</p>
<pre><code class="language-java">Intent downloadIntent = new (this, DownloadService.class):
</code></pre>
<p>在其他应用程序中，为了访问先前声明的意图，您可以使用：</p>
<pre><code class="language-java">Intent intent = new Intent();
intent.setClassName("com.other.app", "com.other.app.ServiceName");
context.startService(intent);
</code></pre>
<h3 id="pending-intents"><a class="header" href="#pending-intents">Pending Intents</a></h3>
<p>这些允许其他应用程序<strong>代表您的应用程序采取行动</strong>，使用您的应用程序的身份和权限。构造一个 Pending Intent 时，应该<strong>指定一个意图和要执行的操作</strong>。如果<strong>声明的意图不是显式的</strong>（没有声明哪个意图可以调用它），则<strong>恶意应用程序可能会代表受害者应用程序执行声明的操作</strong>。此外，<strong>如果没有指定操作</strong>，恶意应用程序将能够<strong>代表受害者执行任何操作</strong>。</p>
<h3 id="broadcast-intents"><a class="header" href="#broadcast-intents">Broadcast Intents</a></h3>
<p>与之前的意图不同，后者仅由一个应用程序接收，广播意图<strong>可以被多个应用程序接收</strong>。然而，从 API 版本 14 开始，可以<strong>指定应该接收</strong>消息的应用程序，使用 Intent.setPackage。</p>
<p>或者，在发送广播时也可以<strong>指定权限</strong>。接收应用程序需要具有该权限。</p>
<p>有<strong>两种类型</strong>的广播：<strong>普通</strong>（异步）和<strong>有序</strong>（同步）。<strong>顺序</strong>基于<strong>接收器</strong>元素中的<strong>配置优先级</strong>。<strong>每个应用程序可以处理、转发或丢弃广播。</strong></p>
<p>可以使用 <code>Context</code> 类中的函数 <code>sendBroadcast(intent, receiverPermission)</code> 来<strong>发送</strong>一个<strong>广播</strong>。<br />
您还可以使用**<code>LocalBroadCastManager</code><strong>中的函数</strong><code>sendBroadcast</code><strong>，确保</strong>消息永远不会离开应用程序**。使用此方法，您甚至不需要导出接收器组件。</p>
<h3 id="sticky-broadcasts"><a class="header" href="#sticky-broadcasts">Sticky Broadcasts</a></h3>
<p>这种广播<strong>可以在发送后很久被访问</strong>。<br />
这些在 API 级别 21 中被弃用，建议<strong>不要使用它们</strong>。<br />
<strong>它们允许任何应用程序嗅探数据，还可以修改数据。</strong></p>
<p>如果您发现包含“sticky”一词的函数，如**<code>sendStickyBroadcast</code><strong>或</strong><code>sendStickyBroadcastAsUser</code>**，<strong>检查影响并尝试删除它们</strong>。</p>
<h2 id="deep-links--url-schemes"><a class="header" href="#deep-links--url-schemes">Deep links / URL schemes</a></h2>
<p>在 Android 应用程序中，<strong>深度链接</strong>用于通过 URL 直接启动一个操作（意图）。这是通过在活动中声明特定的<strong>URL 方案</strong>来完成的。当 Android 设备尝试<strong>访问具有此方案的 URL</strong>时，应用程序中的指定活动将被启动。</p>
<p>该方案必须在**<code>AndroidManifest.xml</code>**文件中声明：</p>
<pre><code class="language-xml">[...]
&lt;activity android:name=".MyActivity"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.VIEW" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;category android:name="android.intent.category.BROWSABLE" /&gt;
&lt;data android:scheme="examplescheme" /&gt;
&lt;/intent-filter&gt;
[...]
</code></pre>
<p>该示例中的方案是 <code>examplescheme://</code>（还要注意 <strong><code>category BROWSABLE</code></strong>）</p>
<p>然后，在数据字段中，您可以指定 <strong>host</strong> 和 <strong>path</strong>：</p>
<pre><code class="language-xml">&lt;data android:scheme="examplescheme"
android:host="example"
/&gt;
</code></pre>
<p>要从网页访问它，可以设置一个链接，如：</p>
<pre><code class="language-xml">&lt;a href="examplescheme://example/something"&gt;click here&lt;/a&gt;
&lt;a href="examplescheme://example/javascript://%250dalert(1)"&gt;click here&lt;/a&gt;
</code></pre>
<p>为了找到<strong>将在应用中执行的代码</strong>，请转到由深度链接调用的活动，并搜索函数**<code>onNewIntent</code>**。</p>
<p>了解如何<a href="./#exploiting-schemes-deep-links">在不使用HTML页面的情况下调用深度链接</a>。</p>
<h2 id="aidl---android接口定义语言"><a class="header" href="#aidl---android接口定义语言">AIDL - Android接口定义语言</a></h2>
<p><strong>Android接口定义语言（AIDL）<strong>旨在通过</strong>进程间通信</strong>（IPC）促进Android应用程序中客户端和服务之间的通信。由于不允许直接访问另一个进程的内存，AIDL通过将对象编组为操作系统理解的格式来简化该过程，从而简化了不同进程之间的通信。</p>
<h3 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h3>
<ul>
<li>
<p><strong>绑定服务</strong>：这些服务利用AIDL进行IPC，使活动或组件能够绑定到服务，发出请求并接收响应。服务类中的<code>onBind</code>方法对于启动交互至关重要，因此在寻找漏洞时是安全审查的重要领域。</p>
</li>
<li>
<p><strong>Messenger</strong>：作为绑定服务，Messenger促进IPC，重点处理通过<code>onBind</code>方法的数据。必须仔细检查此方法，以发现任何不安全的数据处理或敏感功能的执行。</p>
</li>
<li>
<p><strong>Binder</strong>：尽管由于AIDL的抽象，Binder类的直接使用较少，但了解Binder作为内核级驱动程序在不同进程的内存空间之间促进数据传输是有益的。有关进一步理解的资源可在<a href="https://www.youtube.com/watch?v=O-UHvFjxwZ8">https://www.youtube.com/watch?v=O-UHvFjxwZ8</a>找到。</p>
</li>
</ul>
<h2 id="组件"><a class="header" href="#组件">组件</a></h2>
<p>这些包括：<strong>活动、服务、广播接收器和提供者。</strong></p>
<h3 id="启动活动和其他活动"><a class="header" href="#启动活动和其他活动">启动活动和其他活动</a></h3>
<p>在Android应用中，<strong>活动</strong>就像屏幕，显示应用用户界面的不同部分。一个应用可以有多个活动，每个活动向用户呈现一个独特的屏幕。</p>
<p><strong>启动活动</strong>是应用的主要入口，当您点击应用图标时启动。它在应用的清单文件中定义，具有特定的MAIN和LAUNCHER意图：</p>
<pre><code class="language-markup">&lt;activity android:name=".LauncherActivity"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.MAIN" /&gt;
&lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>并非所有应用都需要启动器活动，特别是那些没有用户界面的应用，如后台服务。</p>
<p>通过在清单中将活动标记为“exported”，可以使其对其他应用或进程可用。此设置允许其他应用启动此活动：</p>
<pre><code class="language-markdown">&lt;service android:name=".ExampleExportedService" android:exported="true"/&gt;
</code></pre>
<p>然而，从另一个应用访问一个活动并不总是安全风险。问题出现在敏感数据被不当共享时，这可能导致信息泄露。</p>
<p>一个活动的生命周期 <strong>从 onCreate 方法开始</strong>，设置用户界面并准备活动与用户的交互。</p>
<h3 id="应用程序子类"><a class="header" href="#应用程序子类">应用程序子类</a></h3>
<p>在 Android 开发中，应用程序可以选择创建一个 <strong>子类</strong> 的 <a href="https://developer.android.com/reference/android/app/Application">Application</a> 类，尽管这不是强制性的。当定义了这样的子类时，它将成为应用程序中第一个被实例化的类。如果在这个子类中实现了 <strong><code>attachBaseContext</code></strong> 方法，它将在 <strong><code>onCreate</code></strong> 方法之前执行。这个设置允许在应用程序的其余部分启动之前进行早期初始化。</p>
<pre><code class="language-java">public class MyApp extends Application {
@Override
protected void attachBaseContext(Context base) {
super.attachBaseContext(base);
// Initialization code here
}

@Override
public void onCreate() {
super.onCreate();
// More initialization code
}
}
</code></pre>
<h3 id="服务"><a class="header" href="#服务">服务</a></h3>
<p><a href="https://developer.android.com/guide/components/services">服务</a> 是 <strong>后台操作</strong>，能够在没有用户界面的情况下执行任务。这些任务即使在用户切换到不同应用程序时也可以继续运行，使得服务对于 <strong>长时间运行的操作</strong> 至关重要。</p>
<p>服务是多功能的；它们可以通过多种方式启动，其中 <strong>Intent</strong> 是作为应用程序入口点启动它们的主要方法。一旦使用 <code>startService</code> 方法启动服务，其 <code>onStart</code> 方法就会启动并持续运行，直到显式调用 <code>stopService</code> 方法。或者，如果服务的角色依赖于活动的客户端连接，则使用 <code>bindService</code> 方法将客户端绑定到服务，激活 <code>onBind</code> 方法进行数据传递。</p>
<p>服务的一个有趣应用包括后台音乐播放或网络数据获取，而不会妨碍用户与应用的交互。此外，服务可以通过 <strong>导出</strong> 使其他进程在同一设备上可访问。这不是默认行为，需要在 Android Manifest 文件中进行显式配置：</p>
<pre><code class="language-xml">&lt;service android:name=".ExampleExportedService" android:exported="true"/&gt;
</code></pre>
<h3 id="广播接收器"><a class="header" href="#广播接收器">广播接收器</a></h3>
<p><strong>广播接收器</strong>充当消息系统中的监听器，允许多个应用程序响应来自系统的相同消息。应用程序可以通过应用的<strong>Manifest</strong>或通过应用代码中的**<code>registerReceiver</code>** API以<strong>两种主要方式</strong>注册接收器。在Manifest中，广播通过权限进行过滤，而动态注册的接收器在注册时也可以指定权限。</p>
<p><strong>意图过滤器</strong>在这两种注册方法中至关重要，决定哪些广播触发接收器。一旦发送匹配的广播，接收器的**<code>onReceive</code>**方法将被调用，使应用能够相应地反应，例如在低电量警报时调整行为。</p>
<p>广播可以是<strong>异步</strong>的，所有接收器无序接收，或<strong>同步</strong>的，接收器根据设定的优先级接收广播。然而，重要的是要注意潜在的安全风险，因为任何应用都可以优先处理自己以拦截广播。</p>
<p>要理解接收器的功能，请查找其类中的**<code>onReceive</code><strong>方法。该方法的代码可以操作接收到的Intent，强调接收器进行数据验证的必要性，特别是在</strong>有序广播**中，这可能会修改或丢弃Intent。</p>
<h3 id="内容提供者"><a class="header" href="#内容提供者">内容提供者</a></h3>
<p><strong>内容提供者</strong>对于应用之间<strong>共享结构化数据</strong>至关重要，强调实施<strong>权限</strong>以确保数据安全的重要性。它们允许应用访问来自各种来源的数据，包括数据库、文件系统或网络。特定权限，如**<code>readPermission</code><strong>和</strong><code>writePermission</code><strong>，对于控制访问至关重要。此外，可以通过应用的Manifest中的</strong><code>grantUriPermission</code>**设置授予临时访问，利用<code>path</code>、<code>pathPrefix</code>和<code>pathPattern</code>等属性进行详细的访问控制。</p>
<p>输入验证至关重要，以防止漏洞，例如SQL注入。内容提供者支持基本操作：<code>insert()</code>、<code>update()</code>、<code>delete()</code>和<code>query()</code>，促进应用之间的数据操作和共享。</p>
<p><strong>FileProvider</strong>，一种专门的内容提供者，专注于安全地共享文件。它在应用的Manifest中定义，具有特定属性以控制对文件夹的访问，由<code>android:exported</code>和<code>android:resource</code>指向文件夹配置。共享目录时需谨慎，以避免意外暴露敏感数据。</p>
<p>FileProvider的示例Manifest声明：</p>
<pre><code class="language-xml">&lt;provider android:name="androidx.core.content.FileProvider"
android:authorities="com.example.myapp.fileprovider"
android:grantUriPermissions="true"
android:exported="false"&gt;
&lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS"
android:resource="@xml/filepaths" /&gt;
&lt;/provider&gt;
</code></pre>
<p>并且在 <code>filepaths.xml</code> 中指定共享文件夹的示例：</p>
<pre><code class="language-xml">&lt;paths&gt;
&lt;files-path path="images/" name="myimages" /&gt;
&lt;/paths&gt;
</code></pre>
<p>For further information check:</p>
<ul>
<li><a href="https://developer.android.com/guide/topics/providers/content-providers">Android Developers: Content Providers</a></li>
<li><a href="https://developer.android.com/training/secure-file-sharing/setup-sharing">Android Developers: FileProvider</a></li>
</ul>
<h2 id="webviews"><a class="header" href="#webviews">WebViews</a></h2>
<p>WebViews 就像是 Android 应用中的 <strong>迷你网页浏览器</strong>，从网络或本地文件中提取内容。它们面临与常规浏览器类似的风险，但可以通过特定的 <strong>设置</strong> 来 <strong>减少这些风险</strong>。</p>
<p>Android 提供了两种主要的 WebView 类型：</p>
<ul>
<li><strong>WebViewClient</strong> 适合基本的 HTML，但不支持 JavaScript 警告功能，影响 XSS 攻击的测试方式。</li>
<li><strong>WebChromeClient</strong> 更像是完整的 Chrome 浏览器体验。</li>
</ul>
<p>一个关键点是 WebView 浏览器 <strong>不与设备的主浏览器共享 cookies</strong>。</p>
<p>对于加载内容，可以使用 <code>loadUrl</code>, <code>loadData</code>, 和 <code>loadDataWithBaseURL</code> 等方法。确保这些 URL 或文件是 <strong>安全使用</strong> 的至关重要。安全设置可以通过 <code>WebSettings</code> 类进行管理。例如，使用 <code>setJavaScriptEnabled(false)</code> 禁用 JavaScript 可以防止 XSS 攻击。</p>
<p>JavaScript "Bridge" 允许 Java 对象与 JavaScript 交互，从 Android 4.2 开始，要求方法使用 <code>@JavascriptInterface</code> 标记以确保安全。</p>
<p>允许内容访问 (<code>setAllowContentAccess(true)</code>) 使 WebViews 能够访问内容提供者，这可能是一个风险，除非内容 URL 被验证为安全。</p>
<p>要控制文件访问：</p>
<ul>
<li>禁用文件访问 (<code>setAllowFileAccess(false)</code>) 限制对文件系统的访问，某些资产除外，确保它们仅用于非敏感内容。</li>
</ul>
<h2 id="other-app-components-and-mobile-device-management"><a class="header" href="#other-app-components-and-mobile-device-management">Other App Components and Mobile Device Management</a></h2>
<h3 id="digital-signing-of-applications"><a class="header" href="#digital-signing-of-applications"><strong>Digital Signing of Applications</strong></a></h3>
<ul>
<li><strong>数字签名</strong> 是 Android 应用的必需，确保它们在安装前是 <strong>真实作者</strong>。此过程使用证书进行应用识别，并必须在安装时由设备的包管理器进行验证。应用可以是 <strong>自签名或由外部 CA 认证</strong>，防止未经授权的访问，并确保应用在传送到设备时保持未被篡改。</li>
</ul>
<h3 id="app-verification-for-enhanced-security"><a class="header" href="#app-verification-for-enhanced-security"><strong>App Verification for Enhanced Security</strong></a></h3>
<ul>
<li>从 <strong>Android 4.2</strong> 开始，名为 <strong>验证应用</strong> 的功能允许用户在安装前检查应用的安全性。此 <strong>验证过程</strong> 可以警告用户潜在有害的应用，甚至阻止特别恶意的应用安装，从而增强用户安全。</li>
</ul>
<h3 id="mobile-device-management-mdm"><a class="header" href="#mobile-device-management-mdm"><strong>Mobile Device Management (MDM)</strong></a></h3>
<ul>
<li><strong>MDM 解决方案</strong> 通过 <strong>设备管理 API</strong> 提供对移动设备的 <strong>监督和安全</strong>。它们需要安装 Android 应用以有效管理和保护移动设备。主要功能包括 <strong>强制密码策略</strong>、<strong>要求存储加密</strong> 和 <strong>允许远程数据擦除</strong>，确保对移动设备的全面控制和安全。</li>
</ul>
<pre><code class="language-java">// Example of enforcing a password policy with MDM
DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
ComponentName adminComponent = new ComponentName(context, AdminReceiver.class);

if (dpm.isAdminActive(adminComponent)) {
// Set minimum password length
dpm.setPasswordMinimumLength(adminComponent, 8);
}
</code></pre>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../mobile-pentesting/android-app-pentesting/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../mobile-pentesting/android-app-pentesting/android-task-hijacking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../mobile-pentesting/android-app-pentesting/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../mobile-pentesting/android-app-pentesting/android-task-hijacking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
