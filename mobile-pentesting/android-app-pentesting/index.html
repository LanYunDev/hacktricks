<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Android Applications Pentesting</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="android-applications-pentesting"><a class="header" href="#android-applications-pentesting">Android Applications Pentesting</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS Hacking:<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks Training AWS Red Team Expert (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP Hacking: <img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks Training GCP Red Team Expert (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激和挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金发布和重要平台更新</p>
<p><strong>今天就加入我们的</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，与顶尖黑客开始合作！</p>
<h2 id="android-applications-basics"><a class="header" href="#android-applications-basics">Android Applications Basics</a></h2>
<p>强烈建议您开始阅读此页面，以了解与 Android 安全性和 Android 应用程序中最危险组件相关的 <strong>最重要部分</strong>：</p>
<p>{% content-ref url="android-applications-basics.md" %}
<a href="android-applications-basics.html">android-applications-basics.md</a>
{% endcontent-ref %}</p>
<h2 id="adb-android-debug-bridge"><a class="header" href="#adb-android-debug-bridge">ADB (Android Debug Bridge)</a></h2>
<p>这是您连接到 Android 设备（模拟或物理）所需的主要工具。<br />
<strong>ADB</strong> 允许从计算机通过 <strong>USB</strong> 或 <strong>网络</strong> 控制设备。此工具使 <strong>文件</strong> 双向 <strong>复制</strong>、<strong>安装</strong> 和 <strong>卸载</strong> 应用程序、<strong>执行</strong> shell 命令、<strong>备份</strong> 数据、<strong>读取</strong> 日志等功能成为可能。</p>
<p>查看以下 <a href="adb-commands.html"><strong>ADB 命令</strong></a> 列表，了解如何使用 adb。</p>
<h2 id="smali"><a class="header" href="#smali">Smali</a></h2>
<p>有时修改 <strong>应用程序代码</strong> 以访问 <strong>隐藏信息</strong>（可能是经过良好混淆的密码或标志）是很有趣的。然后，反编译 apk、修改代码并重新编译可能会很有趣。<br />
<a href="smali-changes.html"><strong>在本教程中</strong>，您可以 <strong>学习如何反编译 APK，修改 Smali 代码并重新编译 APK</strong>，以实现新功能</a>。这在 <strong>动态分析</strong> 中作为多种测试的 <strong>替代方案</strong> 可能非常有用。然后，<strong>始终记住这个可能性</strong>。</p>
<h2 id="other-interesting-tricks"><a class="header" href="#other-interesting-tricks">Other interesting tricks</a></h2>
<ul>
<li><a href="spoofing-your-location-in-play-store.html">在 Play Store 中伪装您的位置</a></li>
<li><strong>下载 APK</strong>: <a href="https://apps.evozi.com/apk-downloader/">https://apps.evozi.com/apk-downloader/</a>, <a href="https://apkpure.com/es/">https://apkpure.com/es/</a>, <a href="https://www.apkmirror.com">https://www.apkmirror.com/</a>, <a href="https://apkcombo.com/es-es/apk-downloader/">https://apkcombo.com/es-es/apk-downloader/</a>, <a href="https://github.com/kiber-io/apkd">https://github.com/kiber-io/apkd</a></li>
<li>从设备提取 APK:</li>
</ul>
<pre><code class="language-bash">adb shell pm list packages
com.android.insecurebankv2

adb shell pm path com.android.insecurebankv2
package:/data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk

adb pull /data/app/com.android.insecurebankv2-Jnf8pNgwy3QA_U5f-n_4jQ==/base.apk
</code></pre>
<ul>
<li>使用 <a href="https://github.com/REAndroid/APKEditor">APKEditor</a> 合并所有拆分和基础 APK：</li>
</ul>
<pre><code class="language-bash">mkdir splits
adb shell pm path com.android.insecurebankv2 | cut -d ':' -f 2 | xargs -n1 -i adb pull {} splits
java -jar ../APKEditor.jar m -i splits/ -o merged.apk

# after merging, you will need to align and sign the apk, personally, I like to use the uberapksigner
java -jar uber-apk-signer.jar -a merged.apk --allowResign -o merged_signed
</code></pre>
<h2 id="静态分析"><a class="header" href="#静态分析">静态分析</a></h2>
<p>首先，分析 APK 时，您应该<strong>查看 Java 代码</strong>，使用反编译器。<br />
请<a href="apk-decompilers.html"><strong>在这里阅读有关不同可用反编译器的信息</strong></a>。</p>
<h3 id="寻找有趣的信息"><a class="header" href="#寻找有趣的信息">寻找有趣的信息</a></h3>
<p>仅查看 APK 的<strong>字符串</strong>，您可以搜索<strong>密码</strong>、<strong>URL</strong>（<a href="https://github.com/ndelphit/apkurlgrep">https://github.com/ndelphit/apkurlgrep</a>）、<strong>api</strong> 密钥、<strong>加密</strong>、<strong>蓝牙 UUID</strong>、<strong>令牌</strong>以及任何有趣的内容……甚至查找代码执行的<strong>后门</strong>或身份验证后门（硬编码的管理员凭据）。</p>
<p><strong>Firebase</strong></p>
<p>特别注意<strong>firebase URL</strong>，并检查其是否配置不当。<a href="../../network-services-pentesting/pentesting-web/buckets/firebase-database.html">有关 Firebase 的更多信息以及如何利用它，请点击这里。</a></p>
<h3 id="应用程序的基本理解---manifestxml-stringsxml"><a class="header" href="#应用程序的基本理解---manifestxml-stringsxml">应用程序的基本理解 - Manifest.xml, strings.xml</a></h3>
<p><strong>检查应用程序的 _Manifest.xml</strong><em>** 和 **</em><strong>strings.xml</strong>_** 文件可以揭示潜在的安全漏洞**。这些文件可以通过反编译器访问，或通过将 APK 文件扩展名重命名为 .zip 然后解压缩来访问。</p>
<p>从 <strong>Manifest.xml</strong> 中识别出的<strong>漏洞</strong>包括：</p>
<ul>
<li><strong>可调试应用程序</strong>：在 <em>Manifest.xml</em> 文件中设置为可调试（<code>debuggable="true"</code>）的应用程序存在风险，因为它们允许连接，可能导致被利用。有关如何利用可调试应用程序的进一步理解，请参考有关在设备上查找和利用可调试应用程序的教程。</li>
<li><strong>备份设置</strong>：对于处理敏感信息的应用程序，<code>android:allowBackup="false"</code> 属性应明确设置，以防止通过 adb 进行未经授权的数据备份，特别是在启用 USB 调试时。</li>
<li><strong>网络安全</strong>：<em>res/xml/</em> 中的自定义网络安全配置（<code>android:networkSecurityConfig="@xml/network_security_config"</code>）可以指定安全细节，如证书固定和 HTTP 流量设置。一个例子是允许特定域的 HTTP 流量。</li>
<li><strong>导出活动和服务</strong>：在清单中识别导出的活动和服务可以突出可能被滥用的组件。在动态测试期间的进一步分析可以揭示如何利用这些组件。</li>
<li><strong>内容提供者和文件提供者</strong>：暴露的内容提供者可能允许未经授权访问或修改数据。文件提供者的配置也应受到审查。</li>
<li><strong>广播接收器和 URL 方案</strong>：这些组件可能被利用进行攻击，特别注意如何管理 URL 方案以防止输入漏洞。</li>
<li><strong>SDK 版本</strong>：<code>minSdkVersion</code>、<code>targetSDKVersion</code> 和 <code>maxSdkVersion</code> 属性指示支持的 Android 版本，强调出于安全原因不支持过时、易受攻击的 Android 版本的重要性。</li>
</ul>
<p>从 <strong>strings.xml</strong> 文件中，可以发现敏感信息，如 API 密钥、自定义模式和其他开发者注释，强调了对这些资源进行仔细审查的必要性。</p>
<h3 id="tapjacking"><a class="header" href="#tapjacking">Tapjacking</a></h3>
<p><strong>Tapjacking</strong> 是一种攻击，其中<strong>恶意</strong> <strong>应用程序</strong>被启动并<strong>定位在受害者应用程序的顶部</strong>。一旦它可见地遮挡了受害者应用程序，其用户界面被设计成欺骗用户与之交互，同时将交互传递给受害者应用程序。<br />
实际上，它是<strong>让用户无法知道他们实际上是在对受害者应用程序执行操作</strong>。</p>
<p>在这里找到更多信息：</p>
<p>{% content-ref url="tapjacking.md" %}
<a href="tapjacking.html">tapjacking.md</a>
{% endcontent-ref %}</p>
<h3 id="任务劫持"><a class="header" href="#任务劫持">任务劫持</a></h3>
<p>一个<strong>活动</strong>的**<code>launchMode</code>** 设置为 <strong><code>singleTask</code></strong> 且没有定义任何 <code>taskAffinity</code> 是易受任务劫持的。这意味着，一个<strong>应用程序</strong>可以被安装，如果在真实应用程序之前启动，它可能会<strong>劫持真实应用程序的任务</strong>（因此用户将与<strong>恶意应用程序</strong>交互，以为自己在使用真实的应用程序）。</p>
<p>更多信息在：</p>
<p>{% content-ref url="android-task-hijacking.md" %}
<a href="android-task-hijacking.html">android-task-hijacking.md</a>
{% endcontent-ref %}</p>
<h3 id="不安全的数据存储"><a class="header" href="#不安全的数据存储">不安全的数据存储</a></h3>
<p><strong>内部存储</strong></p>
<p>在 Android 中，<strong>存储</strong>在<strong>内部</strong>存储中的文件<strong>设计</strong>为仅由<strong>创建</strong>它们的<strong>应用程序</strong>访问。此安全措施由 Android 操作系统<strong>强制</strong>执行，通常足以满足大多数应用程序的安全需求。然而，开发人员有时会使用 <code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITABLE</code> 等模式来<strong>允许</strong>文件在不同应用程序之间<strong>共享</strong>。然而，这些模式<strong>并不限制</strong>其他应用程序（包括潜在的恶意应用程序）对这些文件的访问。</p>
<ol>
<li><strong>静态分析：</strong></li>
</ol>
<ul>
<li><strong>确保</strong>仔细审查 <code>MODE_WORLD_READABLE</code> 和 <code>MODE_WORLD_WRITABLE</code> 的使用。这些模式<strong>可能会暴露</strong>文件给<strong>意外或未经授权的访问</strong>。</li>
</ul>
<ol start="2">
<li><strong>动态分析：</strong></li>
</ol>
<ul>
<li><strong>验证</strong>应用程序创建的文件上设置的<strong>权限</strong>。具体来说，<strong>检查</strong>是否有任何文件被<strong>设置为全球可读或可写</strong>。这可能构成重大安全风险，因为这将允许<strong>任何安装在设备上的应用程序</strong>，无论其来源或意图如何，<strong>读取或修改</strong>这些文件。</li>
</ul>
<p><strong>外部存储</strong></p>
<p>处理<strong>外部存储</strong>上的文件（如 SD 卡）时，应采取某些预防措施：</p>
<ol>
<li><strong>可访问性</strong>：</li>
</ol>
<ul>
<li>外部存储上的文件是<strong>全球可读和可写</strong>的。这意味着任何应用程序或用户都可以访问这些文件。</li>
</ul>
<ol start="2">
<li><strong>安全问题</strong>：</li>
</ol>
<ul>
<li>鉴于访问的便利性，建议<strong>不要在外部存储上存储敏感信息</strong>。</li>
<li>外部存储可以被任何应用程序移除或访问，使其安全性降低。</li>
</ul>
<ol start="3">
<li><strong>处理来自外部存储的数据</strong>：</li>
</ol>
<ul>
<li>始终对从外部存储检索的数据<strong>执行输入验证</strong>。这至关重要，因为数据来自不受信任的来源。</li>
<li>强烈不建议在外部存储上存储可执行文件或类文件以进行动态加载。</li>
<li>如果您的应用程序必须从外部存储检索可执行文件，请确保这些文件在动态加载之前<strong>经过签名和加密验证</strong>。此步骤对于维护应用程序的安全完整性至关重要。</li>
</ul>
<p>外部存储可以在 <code>/storage/emulated/0</code>、<code>/sdcard</code>、<code>/mnt/sdcard</code> 中访问。</p>
<p>{% hint style="info" %}
从 Android 4.4（<strong>API 17</strong>）开始，SD 卡具有目录结构，这<strong>限制了应用程序对特定于该应用程序的目录的访问</strong>。这防止恶意应用程序获得对其他应用程序文件的读写访问。
{% endhint %}</p>
<p><strong>以明文存储的敏感数据</strong></p>
<ul>
<li><strong>共享首选项</strong>：Android 允许每个应用程序轻松地在路径 <code>/data/data/&lt;packagename&gt;/shared_prefs/</code> 中保存 xml 文件，有时可以在该文件夹中找到明文的敏感信息。</li>
<li><strong>数据库</strong>：Android 允许每个应用程序轻松地在路径 <code>/data/data/&lt;packagename&gt;/databases/</code> 中保存 sqlite 数据库，有时可以在该文件夹中找到明文的敏感信息。</li>
</ul>
<h3 id="破损的-tls"><a class="header" href="#破损的-tls">破损的 TLS</a></h3>
<p><strong>接受所有证书</strong></p>
<p>出于某种原因，有时开发人员会接受所有证书，即使例如主机名与以下代码行不匹配：</p>
<pre><code class="language-java">SSLSocketFactory sf = new cc(trustStore);
sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
</code></pre>
<p>一个好的测试方法是尝试使用一些代理（如 Burp）捕获流量，而不在设备内授权 Burp CA。此外，您还可以使用 Burp 为不同的主机名生成证书并使用它。</p>
<h3 id="破损的加密"><a class="header" href="#破损的加密">破损的加密</a></h3>
<p><strong>糟糕的密钥管理流程</strong></p>
<p>一些开发者将敏感数据保存在本地存储中，并使用在代码中硬编码/可预测的密钥进行加密。这是不应该这样做的，因为一些反向工程可能允许攻击者提取机密信息。</p>
<p><strong>使用不安全和/或过时的算法</strong></p>
<p>开发者不应该使用<strong>过时的算法</strong>来执行授权<strong>检查</strong>、<strong>存储</strong>或<strong>发送</strong>数据。这些算法包括：RC4、MD4、MD5、SHA1……如果<strong>哈希</strong>用于存储密码，例如，应该使用带盐的抗暴力破解<strong>哈希</strong>。</p>
<h3 id="其他检查"><a class="header" href="#其他检查">其他检查</a></h3>
<ul>
<li>建议<strong>混淆 APK</strong>，以增加攻击者的反向工程难度。</li>
<li>如果应用程序是敏感的（如银行应用），它应该执行<strong>自己的检查以查看手机是否已被root</strong>并采取相应措施。</li>
<li>如果应用程序是敏感的（如银行应用），它应该检查是否正在使用<strong>模拟器</strong>。</li>
<li>如果应用程序是敏感的（如银行应用），它应该<strong>在执行之前检查自身的完整性</strong>以确认是否被修改。</li>
<li>使用 <a href="https://github.com/rednaga/APKiD"><strong>APKiD</strong></a> 检查构建 APK 时使用的编译器/打包器/混淆器</li>
</ul>
<h3 id="react-native-应用程序"><a class="header" href="#react-native-应用程序">React Native 应用程序</a></h3>
<p>阅读以下页面以了解如何轻松访问 React 应用程序的 JavaScript 代码：</p>
<p>{% content-ref url="react-native-application.md" %}
<a href="react-native-application.html">react-native-application.md</a>
{% endcontent-ref %}</p>
<h3 id="xamarin-应用程序"><a class="header" href="#xamarin-应用程序">Xamarin 应用程序</a></h3>
<p>阅读以下页面以了解如何轻松访问 Xamarin 应用程序的 C# 代码：</p>
<p>{% content-ref url="../xamarin-apps.md" %}
<a href="../xamarin-apps.html">xamarin-apps.md</a>
{% endcontent-ref %}</p>
<h3 id="超级打包应用程序"><a class="header" href="#超级打包应用程序">超级打包应用程序</a></h3>
<p>根据这篇 <a href="https://clearbluejar.github.io/posts/desuperpacking-meta-superpacked-apks-with-github-actions/"><strong>博客文章</strong></a>，超级打包是一种将应用程序内容压缩为单个文件的 Meta 算法。博客讨论了创建一个解压缩此类应用程序的应用的可能性……以及一种更快的方法，即<strong>执行应用程序并从文件系统中收集解压缩的文件</strong>。</p>
<h3 id="自动化静态代码分析"><a class="header" href="#自动化静态代码分析">自动化静态代码分析</a></h3>
<p>工具 <a href="https://github.com/facebook/mariana-trench"><strong>mariana-trench</strong></a> 能够通过<strong>扫描</strong>应用程序的<strong>代码</strong>来发现<strong>漏洞</strong>。该工具包含一系列<strong>已知源</strong>（指示工具<strong>用户控制输入的地方</strong>）、<strong>汇</strong>（指示工具<strong>危险的地方</strong>，恶意用户输入可能造成损害）和<strong>规则</strong>。这些规则指示<strong>源-汇</strong>的<strong>组合</strong>，表明存在漏洞。</p>
<p>凭借这些知识，<strong>mariana-trench 将审查代码并找到可能的漏洞</strong>。</p>
<h3 id="秘密泄露"><a class="header" href="#秘密泄露">秘密泄露</a></h3>
<p>应用程序可能包含秘密（API 密钥、密码、隐藏的 URL、子域名……），您可能能够发现。您可以使用工具如 <a href="https://github.com/dwisiswant0/apkleaks">https://github.com/dwisiswant0/apkleaks</a></p>
<h3 id="绕过生物识别认证"><a class="header" href="#绕过生物识别认证">绕过生物识别认证</a></h3>
<p>{% content-ref url="bypass-biometric-authentication-android.md" %}
<a href="bypass-biometric-authentication-android.html">bypass-biometric-authentication-android.md</a>
{% endcontent-ref %}</p>
<h3 id="其他有趣的功能"><a class="header" href="#其他有趣的功能">其他有趣的功能</a></h3>
<ul>
<li><strong>代码执行</strong>：<code>Runtime.exec(), ProcessBuilder(), native code:system()</code></li>
<li><strong>发送短信</strong>：<code>sendTextMessage, sendMultipartTestMessage</code></li>
<li><strong>声明为 <code>native</code> 的本地函数</strong>：<code>public native, System.loadLibrary, System.load</code></li>
<li><a href="reversing-native-libraries.html">阅读此文以了解<strong>如何反向工程本地函数</strong></a></li>
</ul>
<h3 id="其他技巧"><a class="header" href="#其他技巧"><strong>其他技巧</strong></a></h3>
<p>{% content-ref url="content-protocol.md" %}
<a href="content-protocol.html">content-protocol.md</a>
{% endcontent-ref %}</p>
<hr />
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金计划和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作！</p>
<hr />
<h2 id="动态分析"><a class="header" href="#动态分析">动态分析</a></h2>
<blockquote>
<p>首先，您需要一个可以安装应用程序和所有环境（主要是 Burp CA 证书、Drozer 和 Frida）的环境。因此，强烈建议使用已 root 的设备（无论是模拟的还是非模拟的）。</p>
</blockquote>
<h3 id="在线动态分析"><a class="header" href="#在线动态分析">在线动态分析</a></h3>
<p>您可以在 <a href="https://appetize.io">https://appetize.io/</a> 创建一个<strong>免费账户</strong>。该平台允许您<strong>上传</strong>和<strong>执行</strong> APK，因此它对于查看 APK 的行为非常有用。</p>
<p>您甚至可以在网页上<strong>查看应用程序的日志</strong>并通过<strong>adb</strong>连接。</p>
<p><img src="../../.gitbook/assets/image%20(831).png" alt="" /></p>
<p>通过 ADB 连接，您可以在模拟器中使用<strong>Drozer</strong>和<strong>Frida</strong>。</p>
<h3 id="本地动态分析"><a class="header" href="#本地动态分析">本地动态分析</a></h3>
<h4 id="使用模拟器"><a class="header" href="#使用模拟器">使用模拟器</a></h4>
<ul>
<li><a href="https://developer.android.com/studio"><strong>Android Studio</strong></a>（您可以创建<strong>x86</strong>和<strong>arm</strong>设备，并且根据<a href="https://android-developers.googleblog.com/2020/03/run-arm-apps-on-android-emulator.html"><strong>这个</strong></a><strong>最新的 x86</strong> 版本<strong>支持 ARM 库</strong>，无需使用慢速的 arm 模拟器）。</li>
<li>在此页面学习如何设置：</li>
</ul>
<p>{% content-ref url="avd-android-virtual-device.md" %}
<a href="avd-android-virtual-device.html">avd-android-virtual-device.md</a>
{% endcontent-ref %}</p>
<ul>
<li><a href="https://www.genymotion.com/fun-zone/"><strong>Genymotion</strong></a> <strong>（免费版：<strong>个人版，您需要创建一个账户。_建议下载</strong>带有</strong><em><strong>VirtualBox</strong>的版本，以避免潜在错误。</em>）</li>
<li><a href="https://es.bignox.com"><strong>Nox</strong></a>（免费，但不支持 Frida 或 Drozer）。</li>
</ul>
<p>{% hint style="info" %}
创建新模拟器时，请记住屏幕越大，模拟器运行越慢。因此，如果可能，请选择小屏幕。
{% endhint %}</p>
<p>要在 Genymotion 中<strong>安装 Google 服务</strong>（如 AppStore），您需要单击以下图像中红色标记的按钮：</p>
<p><img src="../../.gitbook/assets/image%20(277).png" alt="" /></p>
<p>此外，请注意在 Genymotion 的<strong>Android VM 配置中</strong>，您可以选择<strong>桥接网络模式</strong>（如果您将从不同的 VM 连接到 Android VM，这将非常有用）。</p>
<h4 id="使用物理设备"><a class="header" href="#使用物理设备">使用物理设备</a></h4>
<p>您需要激活<strong>调试</strong>选项，如果您能<strong>root</strong>它，那就更好了：</p>
<ol>
<li><strong>设置</strong>。</li>
<li>（从 Android 8.0 开始）选择<strong>系统</strong>。</li>
<li>选择<strong>关于手机</strong>。</li>
<li>按<strong>构建号</strong> 7 次。</li>
<li>返回，您将找到<strong>开发者选项</strong>。</li>
</ol>
<blockquote>
<p>一旦您安装了应用程序，您首先应该尝试它并调查它的功能、工作原理，并熟悉它。<br />
我建议使用 MobSF 动态分析 + pidcat 进行此初步动态分析，这样我们就可以在 MobSF <strong>捕获</strong>大量<strong>有趣的</strong>数据时<strong>了解应用程序的工作原理</strong>，您可以稍后查看这些数据。</p>
</blockquote>
<h3 id="意外数据泄露"><a class="header" href="#意外数据泄露">意外数据泄露</a></h3>
<p><strong>日志记录</strong></p>
<p>开发者应谨慎公开<strong>调试信息</strong>，因为这可能导致敏感数据泄露。建议使用工具 <a href="https://github.com/JakeWharton/pidcat"><strong>pidcat</strong></a> 和 <code>adb logcat</code> 监控应用程序日志，以识别和保护敏感信息。<strong>Pidcat</strong>因其易用性和可读性而受到青睐。</p>
<p>{% hint style="warning" %}
请注意，从<strong>Android 4.0 及更高版本</strong>开始，<strong>应用程序只能访问自己的日志</strong>。因此，应用程序无法访问其他应用的日志。<br />
无论如何，仍然建议<strong>不要记录敏感信息</strong>。
{% endhint %}</p>
<p><strong>复制/粘贴缓冲区缓存</strong></p>
<p>Android 的<strong>基于剪贴板</strong>的框架使应用程序能够实现复制粘贴功能，但也带来了风险，因为<strong>其他应用程序</strong>可以<strong>访问</strong>剪贴板，可能会暴露敏感数据。对于应用程序的敏感部分（如信用卡详细信息），至关重要的是<strong>禁用复制/粘贴</strong>功能，以防止数据泄露。</p>
<p><strong>崩溃日志</strong></p>
<p>如果应用程序<strong>崩溃</strong>并<strong>保存日志</strong>，这些日志可能会帮助攻击者，特别是当应用程序无法被反向工程时。为了降低此风险，避免在崩溃时记录日志，如果必须通过网络传输日志，请确保通过 SSL 通道发送以确保安全。</p>
<p>作为渗透测试者，<strong>请尝试查看这些日志</strong>。</p>
<p><strong>发送给第三方的分析数据</strong></p>
<p>应用程序通常集成 Google Adsense 等服务，由于开发者的不当实现，可能会无意中<strong>泄露敏感数据</strong>。为了识别潜在的数据泄露，建议<strong>拦截应用程序的流量</strong>并检查是否有任何敏感信息被发送到第三方服务。</p>
<h3 id="sqlite-数据库"><a class="header" href="#sqlite-数据库">SQLite 数据库</a></h3>
<p>大多数应用程序将使用<strong>内部 SQLite 数据库</strong>来保存信息。在渗透测试期间，请<strong>查看</strong>创建的<strong>数据库</strong>、<strong>表</strong>和<strong>列</strong>的名称以及所有保存的<strong>数据</strong>，因为您可能会发现<strong>敏感信息</strong>（这将是一个漏洞）。<br />
数据库应位于 <code>/data/data/the.package.name/databases</code>，如 <code>/data/data/com.mwr.example.sieve/databases</code></p>
<p>如果数据库保存机密信息并且是<strong>加密的</strong>，但您可以在应用程序中<strong>找到</strong>密码，这仍然是一个<strong>漏洞</strong>。</p>
<p>使用 <code>.tables</code> 枚举表，使用 <code>.schema &lt;table_name&gt;</code> 枚举表的列。</p>
<h3 id="drozer利用活动内容提供者和服务"><a class="header" href="#drozer利用活动内容提供者和服务">Drozer（利用活动、内容提供者和服务）</a></h3>
<p>来自 <a href="https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf">Drozer 文档</a>：<strong>Drozer</strong> 允许您<strong>假设 Android 应用程序的角色</strong>并与其他应用程序交互。它可以做<strong>任何已安装应用程序可以做的事情</strong>，例如利用 Android 的进程间通信（IPC）机制并与底层操作系统交互。<br />
Drozer 是一个有用的工具，可以<strong>利用导出活动、导出服务和内容提供者</strong>，您将在以下部分中学习。</p>
<h3 id="利用导出活动"><a class="header" href="#利用导出活动">利用导出活动</a></h3>
<p><a href="android-applications-basics.html#launcher-activity-and-other-activities"><strong>如果您想刷新 Android 活动的概念，请阅读此文。</strong></a><br />
还要记住，活动的代码从**<code>onCreate</code>** 方法开始。</p>
<p><strong>授权绕过</strong></p>
<p>当活动被导出时，您可以从外部应用程序调用其界面。因此，如果导出一个包含<strong>敏感信息</strong>的活动，您可以<strong>绕过</strong>访问它的<strong>认证</strong>机制。</p>
<p><a href="drozer-tutorial/#activities"><strong>了解如何使用 Drozer 利用导出活动。</strong></a></p>
<p>您还可以从 adb 启动导出活动：</p>
<ul>
<li>包名是 com.example.demo</li>
<li>导出活动名称是 com.example.test.MainActivity</li>
</ul>
<pre><code class="language-bash">adb shell am start -n com.example.demo/com.example.test.MainActivity
</code></pre>
<p><strong>注意</strong>：MobSF会将使用_<strong>singleTask/singleInstance</strong>_作为活动中的<code>android:launchMode</code>视为恶意，但由于<a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF/pull/750">这个</a>，显然这在旧版本（API版本&lt;21）中才是危险的。</p>
<p>{% hint style="info" %}
请注意，授权绕过并不总是一个漏洞，这取决于绕过的工作方式和暴露的信息。
{% endhint %}</p>
<p><strong>敏感信息泄露</strong></p>
<p><strong>活动也可以返回结果</strong>。如果你设法找到一个导出且未保护的活动调用**<code>setResult</code><strong>方法并</strong>返回敏感信息**，则存在敏感信息泄露。</p>
<h4 id="tapjacking-1"><a class="header" href="#tapjacking-1">Tapjacking</a></h4>
<p>如果没有防止tapjacking，你可能会滥用导出的活动使<strong>用户执行意外操作</strong>。有关<a href="./#tapjacking"><strong>什么是Tapjacking的更多信息，请访问此链接</strong></a>。</p>
<h3 id="利用内容提供者---访问和操纵敏感信息"><a class="header" href="#利用内容提供者---访问和操纵敏感信息">利用内容提供者 - 访问和操纵敏感信息</a></h3>
<p><a href="android-applications-basics.html#content-provider"><strong>如果你想刷新什么是内容提供者，请阅读此内容。</strong></a><br />
内容提供者基本上用于<strong>共享数据</strong>。如果一个应用程序有可用的内容提供者，你可能能够<strong>提取敏感</strong>数据。测试可能的<strong>SQL注入</strong>和<strong>路径遍历</strong>也很有趣，因为它们可能存在漏洞。</p>
<p><a href="drozer-tutorial/#content-providers"><strong>了解如何使用Drozer利用内容提供者。</strong></a></p>
<h3 id="利用服务"><a class="header" href="#利用服务"><strong>利用服务</strong></a></h3>
<p><a href="android-applications-basics.html#services"><strong>如果你想刷新什么是服务，请阅读此内容。</strong></a><br />
请记住，服务的操作始于方法<code>onStartCommand</code>。</p>
<p>服务基本上是可以<strong>接收数据</strong>、<strong>处理</strong>它并<strong>返回</strong>（或不返回）响应的东西。因此，如果一个应用程序导出了一些服务，你应该<strong>检查</strong>其<strong>代码</strong>以了解它在做什么，并<strong>动态测试</strong>以提取机密信息、绕过身份验证措施...<br />
<a href="drozer-tutorial/#services"><strong>了解如何使用Drozer利用服务。</strong></a></p>
<h3 id="利用广播接收器"><a class="header" href="#利用广播接收器"><strong>利用广播接收器</strong></a></h3>
<p><a href="android-applications-basics.html#broadcast-receivers"><strong>如果你想刷新什么是广播接收器，请阅读此内容。</strong></a><br />
请记住，广播接收器的操作始于方法<code>onReceive</code>。</p>
<p>广播接收器将等待某种类型的消息。根据接收器如何处理消息，它可能会存在漏洞。<br />
<a href="./#exploiting-broadcast-receivers"><strong>了解如何使用Drozer利用广播接收器。</strong></a></p>
<h3 id="利用方案深度链接"><a class="header" href="#利用方案深度链接"><strong>利用方案/深度链接</strong></a></h3>
<p>你可以手动查找深度链接，使用像MobSF这样的工具或像<a href="https://github.com/ashleykinguk/FBLinkBuilder/blob/master/FBLinkBuilder.py">这个</a>的脚本。<br />
你可以使用<strong>adb</strong>或<strong>浏览器</strong>打开声明的<strong>方案</strong>：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">adb shell am start -a android.intent.action.VIEW -d "scheme://hostname/path?param=value" [your.package.name]
</code></pre>
<p>{% endcode %}</p>
<p><em>请注意，您可以<strong>省略包名</strong>，手机将自动调用应该打开该链接的应用程序。</em></p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-markup">&lt;!-- Browser regular link --&gt;
&lt;a href="scheme://hostname/path?param=value"&gt;Click me&lt;/a&gt;
&lt;!-- fallback in your url you could try the intent url --&gt;
&lt;a href="intent://hostname#Intent;scheme=scheme;package=your.package.name;S.browser_fallback_url=http%3A%2F%2Fwww.example.com;end"&gt;with alternative&lt;/a&gt;
</code></pre>
<p>{% endcode %}</p>
<p><strong>代码执行</strong></p>
<p>为了找到<strong>将在应用中执行的代码</strong>，请转到由深度链接调用的活动，并搜索函数**<code>onNewIntent</code>**。</p>
<p><img src="../../.gitbook/assets/image%20(436)%20(1)%20(1)%20(1).png" alt="" /></p>
<p><strong>敏感信息</strong></p>
<p>每次找到深度链接时，请检查<strong>它是否通过 URL 参数接收敏感数据（如密码）</strong>，因为任何其他应用程序都可能<strong>冒充深度链接并窃取该数据！</strong></p>
<p><strong>路径中的参数</strong></p>
<p>您<strong>还必须检查任何深度链接是否在 URL 的路径中使用参数</strong>，例如：<code>https://api.example.com/v1/users/{username}</code>，在这种情况下，您可以强制路径遍历，访问类似于：<code>example://app/users?username=../../unwanted-endpoint%3fparam=value</code>。<br />
请注意，如果您在应用程序中找到正确的端点，您可能能够导致<strong>开放重定向</strong>（如果路径的一部分用作域名），<strong>账户接管</strong>（如果您可以在没有 CSRF 令牌的情况下修改用户详细信息，并且漏洞端点使用了正确的方法）以及任何其他漏洞。更多<a href="http://dphoeniixx.com/2020/12/13-2/">信息在这里</a>。</p>
<p><strong>更多示例</strong></p>
<p>一个<a href="https://hackerone.com/reports/855618">有趣的漏洞赏金报告</a>关于链接（<em>/.well-known/assetlinks.json</em>）。</p>
<h3 id="传输层检查和验证失败"><a class="header" href="#传输层检查和验证失败">传输层检查和验证失败</a></h3>
<ul>
<li><strong>证书并不总是被 Android 应用程序正确检查</strong>。这些应用程序常常忽视警告，接受自签名证书，或者在某些情况下，恢复使用 HTTP 连接。</li>
<li><strong>SSL/TLS 握手期间的协商有时较弱</strong>，使用不安全的密码套件。此漏洞使连接容易受到中间人（MITM）攻击，允许攻击者解密数据。</li>
<li><strong>私密信息泄露</strong>是一个风险，当应用程序通过安全通道进行身份验证，但随后在其他交易中通过非安全通道进行通信。这种方法未能保护敏感数据，例如会话 cookie 或用户详细信息，免受恶意实体的拦截。</li>
</ul>
<h4 id="证书验证"><a class="header" href="#证书验证">证书验证</a></h4>
<p>我们将重点关注<strong>证书验证</strong>。必须验证服务器证书的完整性以增强安全性。这一点至关重要，因为不安全的 TLS 配置和通过未加密通道传输敏感数据可能会带来重大风险。有关验证服务器证书和解决漏洞的详细步骤，<a href="https://manifestsecurity.com/android-application-security-part-10/"><strong>此资源</strong></a>提供了全面的指导。</p>
<h4 id="ssl-钉扎"><a class="header" href="#ssl-钉扎">SSL 钉扎</a></h4>
<p>SSL 钉扎是一种安全措施，应用程序将服务器的证书与存储在应用程序内部的已知副本进行验证。这种方法对于防止 MITM 攻击至关重要。强烈建议处理敏感信息的应用程序实施 SSL 钉扎。</p>
<h4 id="流量检查"><a class="header" href="#流量检查">流量检查</a></h4>
<p>要检查 HTTP 流量，必须<strong>安装代理工具的证书</strong>（例如，Burp）。如果不安装此证书，加密流量可能无法通过代理可见。有关安装自定义 CA 证书的指南，<a href="avd-android-virtual-device.html#install-burp-certificate-on-a-virtual-machine"><strong>请点击这里</strong></a>。</p>
<p>针对<strong>API Level 24 及以上</strong>的应用程序需要修改网络安全配置以接受代理的 CA 证书。这一步对于检查加密流量至关重要。有关修改网络安全配置的说明，<a href="make-apk-accept-ca-certificate.html"><strong>请参考此教程</strong></a>。</p>
<h4 id="绕过-ssl-钉扎"><a class="header" href="#绕过-ssl-钉扎">绕过 SSL 钉扎</a></h4>
<p>当实施 SSL 钉扎时，绕过它变得必要以检查 HTTPS 流量。为此有多种方法可用：</p>
<ul>
<li>自动<strong>修改</strong> <strong>apk</strong>以<strong>绕过</strong> SSLPinning，使用<a href="https://github.com/shroudedcode/apk-mitm"><strong>apk-mitm</strong></a>。此选项的最大优点是，您无需 root 即可绕过 SSL 钉扎，但您需要删除应用程序并重新安装新版本，这并不总是有效。</li>
<li>您可以使用<strong>Frida</strong>（下面讨论）来绕过此保护。这里有一个使用 Burp+Frida+Genymotion 的指南：<a href="https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/">https://spenkk.github.io/bugbounty/Configuring-Frida-with-Burp-and-GenyMotion-to-bypass-SSL-Pinning/</a></li>
<li>您还可以尝试使用<a href="frida-tutorial/objection-tutorial.html"><strong>objection</strong></a><strong>自动绕过 SSL 钉扎</strong>：<code>objection --gadget com.package.app explore --startup-command "android sslpinning disable"</code></li>
<li>您还可以尝试使用<strong>MobSF 动态分析</strong>（下面解释）<strong>自动绕过 SSL 钉扎</strong></li>
<li>如果您仍然认为有一些流量未被捕获，您可以尝试<strong>使用 iptables 将流量转发到 burp</strong>。阅读此博客：<a href="https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62">https://infosecwriteups.com/bypass-ssl-pinning-with-ip-forwarding-iptables-568171b52b62</a></li>
</ul>
<h4 id="寻找常见的网络漏洞"><a class="header" href="#寻找常见的网络漏洞">寻找常见的网络漏洞</a></h4>
<p>在应用程序中搜索常见的网络漏洞也很重要。有关识别和缓解这些漏洞的详细信息超出了本摘要的范围，但在其他地方有广泛的覆盖。</p>
<h3 id="frida"><a class="header" href="#frida">Frida</a></h3>
<p><a href="https://www.frida.re">Frida</a>是一个动态插桩工具包，供开发人员、逆向工程师和安全研究人员使用。<br />
<strong>您可以访问正在运行的应用程序并在运行时挂钩方法以更改行为、更改值、提取值、运行不同的代码...</strong><br />
如果您想对 Android 应用程序进行渗透测试，您需要知道如何使用 Frida。</p>
<ul>
<li>学习如何使用 Frida：<a href="frida-tutorial/"><strong>Frida 教程</strong></a></li>
<li>一些用于 Frida 操作的“GUI”： <a href="https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security"><strong>https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security</strong></a></li>
<li>Ojection 非常适合自动化使用 Frida：<a href="https://github.com/sensepost/objection"><strong>https://github.com/sensepost/objection</strong></a> <strong>,</strong> <a href="https://github.com/dpnishant/appmon"><strong>https://github.com/dpnishant/appmon</strong></a></li>
<li>您可以在这里找到一些很棒的 Frida 脚本：<a href="https://codeshare.frida.re"><strong>https://codeshare.frida.re/</strong></a></li>
<li>尝试通过加载 Frida 绕过反调试/反 Frida 机制，如<a href="https://erfur.github.io/blog/dev/code-injection-without-ptrace">https://erfur.github.io/blog/dev/code-injection-without-ptrace</a>中所示（工具<a href="https://github.com/erfur/linjector-rs">linjector</a>）</li>
</ul>
<h3 id="内存转储---fridump"><a class="header" href="#内存转储---fridump"><strong>内存转储 - Fridump</strong></a></h3>
<p>检查应用程序是否在内存中存储不应存储的敏感信息，例如密码或助记符。</p>
<p>使用<a href="https://github.com/rootbsd/fridump3"><strong>Fridump3</strong></a>，您可以转储应用程序的内存：</p>
<pre><code class="language-bash"># With PID
python3 fridump3.py -u &lt;PID&gt;

# With name
frida-ps -Uai
python3 fridump3.py -u "&lt;Name&gt;"
</code></pre>
<p>这将把内存转储到 ./dump 文件夹中，在那里你可以使用类似的 grep：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">strings * | grep -E "^[a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+ [a-z]+$"
</code></pre>
<p>{% endcode %}</p>
<h3 id="keystore中的敏感数据"><a class="header" href="#keystore中的敏感数据"><strong>Keystore中的敏感数据</strong></a></h3>
<p>在Android中，Keystore是存储敏感数据的最佳位置，然而，拥有足够权限的情况下仍然<strong>可以访问它</strong>。由于应用程序倾向于在此处存储<strong>明文敏感数据</strong>，因此pentests应以root用户身份进行检查，否则拥有物理访问权限的人可能能够窃取这些数据。</p>
<p>即使应用程序将数据存储在keystore中，数据也应该是加密的。</p>
<p>要访问keystore中的数据，可以使用此Frida脚本：<a href="https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js">https://github.com/WithSecureLabs/android-keystore-audit/blob/master/frida-scripts/tracer-cipher.js</a></p>
<pre><code class="language-bash">frida -U -f com.example.app -l frida-scripts/tracer-cipher.js
</code></pre>
<h3 id="指纹生物识别绕过"><a class="header" href="#指纹生物识别绕过"><strong>指纹/生物识别绕过</strong></a></h3>
<p>使用以下 Frida 脚本，可能可以 <strong>绕过指纹认证</strong>，Android 应用程序可能会执行此操作以 <strong>保护某些敏感区域：</strong></p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">frida --codeshare krapgras/android-biometric-bypass-update-android-11 -U -f &lt;app.package&gt;
</code></pre>
<p>{% endcode %}</p>
<h3 id="背景图像"><a class="header" href="#背景图像"><strong>背景图像</strong></a></h3>
<p>当您将应用程序置于后台时，Android 会存储应用程序的 <strong>快照</strong>，因此当它恢复到前台时，它会在应用程序之前开始加载图像，因此看起来应用程序加载得更快。</p>
<p>然而，如果这个快照包含 <strong>敏感信息</strong>，那么有权限访问快照的人可能会 <strong>窃取这些信息</strong>（请注意，您需要 root 权限才能访问它）。</p>
<p>快照通常存储在：<strong><code>/data/system_ce/0/snapshots</code></strong></p>
<p>Android 提供了一种方法来 <strong>通过设置 FLAG_SECURE</strong> 布局参数来防止屏幕截图的捕获。通过使用这个标志，窗口内容被视为安全，防止其出现在屏幕截图中或在不安全的显示器上查看。</p>
<pre><code class="language-bash">getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams.FLAG_SECURE);
</code></pre>
<h3 id="android-应用程序分析器"><a class="header" href="#android-应用程序分析器"><strong>Android 应用程序分析器</strong></a></h3>
<p>此工具可以帮助您在动态分析期间管理不同的工具：<a href="https://github.com/NotSoSecure/android_application_analyzer">https://github.com/NotSoSecure/android_application_analyzer</a></p>
<h3 id="intent-注入"><a class="header" href="#intent-注入">Intent 注入</a></h3>
<p>开发人员经常创建代理组件，如活动、服务和广播接收器，这些组件处理这些 Intents 并将其传递给 <code>startActivity(...)</code> 或 <code>sendBroadcast(...)</code> 等方法，这可能是有风险的。</p>
<p>危险在于允许攻击者通过错误引导这些 Intents 来触发未导出的应用组件或访问敏感内容提供者。一个显著的例子是 <code>WebView</code> 组件通过 <code>Intent.parseUri(...)</code> 将 URL 转换为 <code>Intent</code> 对象，然后执行它们，这可能导致恶意 Intent 注入。</p>
<h3 id="重要要点"><a class="header" href="#重要要点">重要要点</a></h3>
<ul>
<li><strong>Intent 注入</strong> 类似于网络的开放重定向问题。</li>
<li>利用涉及将 <code>Intent</code> 对象作为额外参数传递，这可能被重定向以执行不安全的操作。</li>
<li>它可以将未导出的组件和内容提供者暴露给攻击者。</li>
<li><code>WebView</code> 的 URL 到 <code>Intent</code> 的转换可以促进意外操作。</li>
</ul>
<h3 id="android-客户端侧注入及其他"><a class="header" href="#android-客户端侧注入及其他">Android 客户端侧注入及其他</a></h3>
<p>您可能已经知道这种类型的漏洞来自网络。您必须特别小心 Android 应用程序中的这些漏洞：</p>
<ul>
<li><strong>SQL 注入：</strong> 在处理动态查询或内容提供者时，确保使用参数化查询。</li>
<li><strong>JavaScript 注入 (XSS)：</strong> 验证任何 WebViews 的 JavaScript 和插件支持是否已禁用（默认情况下禁用）。 <a href="webview-attacks.html#javascript-enabled">更多信息在这里</a>。</li>
<li><strong>本地文件包含：</strong> WebViews 应禁用对文件系统的访问（默认情况下启用） - <code>(webview.getSettings().setAllowFileAccess(false);)</code>。 <a href="webview-attacks.html#javascript-enabled">更多信息在这里</a>。</li>
<li><strong>持久性 Cookie：</strong> 在多个情况下，当 Android 应用程序结束会话时，Cookie 不会被撤销，或者甚至可能被保存到磁盘。</li>
<li><a href="../../pentesting-web/hacking-with-cookies/#cookies-flags"><strong>Cookie 中的安全标志</strong></a></li>
</ul>
<hr />
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激和挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
及时了解最新的漏洞赏金发布和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作！</p>
<h2 id="自动分析"><a class="header" href="#自动分析">自动分析</a></h2>
<h3 id="mobsf"><a class="header" href="#mobsf"><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">MobSF</a></a></h3>
<p><strong>静态分析</strong></p>
<p><img src="../../.gitbook/assets/image%20(866).png" alt="" /></p>
<p><strong>使用漂亮的基于 Web 的前端进行应用程序的漏洞评估。</strong> 您还可以执行动态分析（但您需要准备环境）。</p>
<pre><code class="language-bash">docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest
</code></pre>
<p>注意，MobSF 可以分析 <strong>Android</strong>(apk)<strong>、IOS</strong>(ipa) <strong>和 Windows</strong>(apx) 应用程序（<em>Windows 应用程序必须从安装在 Windows 主机上的 MobSF 进行分析</em>）。<br />
此外，如果您创建一个包含 <strong>Android</strong> 或 <strong>IOS</strong> 应用程序源代码的 <strong>ZIP</strong> 文件（转到应用程序的根文件夹，选择所有内容并创建一个 ZIP 文件），它也能够分析它。</p>
<p>MobSF 还允许您进行 <strong>diff/比较</strong> 分析，并集成 <strong>VirusTotal</strong>（您需要在 <em>MobSF/settings.py</em> 中设置您的 API 密钥并启用它：<code>VT_ENABLED = TRUE</code> <code>VT_API_KEY = &lt;Your API key&gt;</code> <code>VT_UPLOAD = TRUE</code>）。您还可以将 <code>VT_UPLOAD</code> 设置为 <code>False</code>，那么 <strong>hash</strong> 将被 <strong>上传</strong> 而不是文件。</p>
<h3 id="使用-mobsf-进行辅助动态分析"><a class="header" href="#使用-mobsf-进行辅助动态分析">使用 MobSF 进行辅助动态分析</a></h3>
<p><strong>MobSF</strong> 对于 <strong>Android</strong> 的 <strong>动态分析</strong> 也非常有帮助，但在这种情况下，您需要在主机上安装 MobSF 和 <strong>genymotion</strong>（虚拟机或 Docker 不会工作）。<em>注意：您需要 <strong>先在 genymotion 中启动虚拟机</strong>，然后 <strong>再启动 MobSF。</strong></em><br />
<strong>MobSF 动态分析器</strong> 可以：</p>
<ul>
<li><strong>转储应用程序数据</strong>（URLs、日志、剪贴板、您拍摄的屏幕截图、由 "<strong>Exported Activity Tester</strong>" 拍摄的屏幕截图、电子邮件、SQLite 数据库、XML 文件和其他创建的文件）。所有这些都是自动完成的，除了屏幕截图，您需要在想要截图时按下，或者您需要按 "<strong>Exported Activity Tester</strong>" 以获取所有导出活动的屏幕截图。</li>
<li>捕获 <strong>HTTPS 流量</strong></li>
<li>使用 <strong>Frida</strong> 获取 <strong>运行时</strong> <strong>信息</strong></li>
</ul>
<p>从 Android <strong>版本 &gt; 5</strong> 开始，它将 <strong>自动启动 Frida</strong> 并设置全局 <strong>代理</strong> 设置以 <strong>捕获</strong> 流量。它只会捕获被测试应用程序的流量。</p>
<p><strong>Frida</strong></p>
<p>默认情况下，它还将使用一些 Frida 脚本来 <strong>绕过 SSL 钉扎</strong>、<strong>根检测</strong> 和 <strong>调试器检测</strong>，并 <strong>监控有趣的 API</strong>。<br />
MobSF 还可以 <strong>调用导出活动</strong>，抓取它们的 <strong>屏幕截图</strong> 并 <strong>保存</strong> 到报告中。</p>
<p>要 <strong>开始</strong> 动态测试，请按绿色按钮：“<strong>开始仪器化</strong>”。按下“<strong>Frida 实时日志</strong>”以查看 Frida 脚本生成的日志，按下“<strong>实时 API 监视器</strong>”以查看所有调用的挂钩方法、传递的参数和返回值（在按下“开始仪器化”后会出现）。<br />
MobSF 还允许您加载自己的 <strong>Frida 脚本</strong>（要将您的 Frida 脚本的结果发送到 MobSF，请使用函数 <code>send()</code>）。它还具有 <strong>多个预编写的脚本</strong>，您可以加载（您可以在 <code>MobSF/DynamicAnalyzer/tools/frida_scripts/others/</code> 中添加更多），只需 <strong>选择它们</strong>，按“<strong>加载</strong>”并按“<strong>开始仪器化</strong>”（您将能够在“<strong>Frida 实时日志</strong>”中看到该脚本的日志）。</p>
<p><img src="../../.gitbook/assets/image%20(419).png" alt="" /></p>
<p>此外，您还有一些辅助 Frida 功能：</p>
<ul>
<li><strong>枚举已加载的类</strong>：它将打印所有已加载的类</li>
<li><strong>捕获字符串</strong>：它将打印在使用应用程序时捕获的所有字符串（非常嘈杂）</li>
<li><strong>捕获字符串比较</strong>：可能非常有用。它将 <strong>显示正在比较的两个字符串</strong> 以及结果是 True 还是 False。</li>
<li><strong>枚举类方法</strong>：输入类名（如 "java.io.File"），它将打印该类的所有方法。</li>
<li><strong>搜索类模式</strong>：按模式搜索类</li>
<li><strong>跟踪类方法</strong>：<strong>跟踪</strong> 一个 <strong>整个类</strong>（查看该类所有方法的输入和输出）。请记住，默认情况下 MobSF 跟踪几个有趣的 Android API 方法。</li>
</ul>
<p>一旦您选择了要使用的辅助模块，您需要按“<strong>开始仪器化</strong>”，您将看到所有输出在“<strong>Frida 实时日志</strong>”中。</p>
<p><strong>Shell</strong></p>
<p>Mobsf 还为您提供了一个带有一些 <strong>adb</strong> 命令、<strong>MobSF 命令</strong> 和常见 <strong>shell</strong> <strong>命令</strong> 的 shell，位于动态分析页面的底部。一些有趣的命令：</p>
<pre><code class="language-bash">help
shell ls
activities
exported_activities
services
receivers
</code></pre>
<p><strong>HTTP工具</strong></p>
<p>当http流量被捕获时，您可以在“<strong>HTTP(S) Traffic</strong>”底部看到捕获流量的丑陋视图，或在“<strong>Start HTTPTools</strong>”绿色按钮中看到更好的视图。从第二个选项中，您可以<strong>发送</strong>捕获的<strong>请求</strong>到像Burp或Owasp ZAP这样的<strong>代理</strong>。<br />
要做到这一点，<em>打开Burp --&gt;</em> <em>关闭拦截 --&gt; 在MobSB HTTPTools中选择请求</em> --&gt; 按下“<strong>Send to Fuzzer</strong>” --&gt; <em>选择代理地址</em> (<a href="http://127.0.0.1:8080">http://127.0.0.1:8080\</a>)。</p>
<p>完成MobSF的动态分析后，您可以按“<strong>Start Web API Fuzzer</strong>”来<strong>模糊http请求</strong>并寻找漏洞。</p>
<p>{% hint style="info" %}
在使用MobSF进行动态分析后，代理设置可能配置错误，您将无法从GUI中修复它们。您可以通过以下方式修复代理设置：</p>
<pre><code>adb shell settings put global http_proxy :0
</code></pre>
<p>{% endhint %}</p>
<h3 id="assisted-dynamic-analysis-with-inspeckage"><a class="header" href="#assisted-dynamic-analysis-with-inspeckage">Assisted Dynamic Analysis with Inspeckage</a></h3>
<p>您可以从 <a href="https://github.com/ac-pm/Inspeckage"><strong>Inspeckage</strong></a> 获取该工具。<br />
该工具将使用一些 <strong>Hooks</strong> 让您了解 <strong>在执行动态分析时应用程序中发生了什么</strong>。</p>
<h3 id="yaazhini"><a class="header" href="#yaazhini"><a href="https://www.vegabird.com/yaazhini/">Yaazhini</a></a></h3>
<p>这是一个 <strong>使用 GUI 进行静态分析的好工具</strong></p>
<p><img src="../../.gitbook/assets/image%20(741).png" alt="" /></p>
<h3 id="qark"><a class="header" href="#qark"><a href="https://github.com/linkedin/qark">Qark</a></a></h3>
<p>该工具旨在查找多个 <strong>与安全相关的 Android 应用程序漏洞</strong>，无论是在 <strong>源代码</strong> 还是 <strong>打包的 APK</strong> 中。该工具还 <strong>能够创建可部署的 "Proof-of-Concept" APK</strong> 和 <strong>ADB 命令</strong>，以利用一些发现的漏洞（暴露的活动、意图、tapjacking...）。与 Drozer 一样，无需对测试设备进行 root。</p>
<pre><code class="language-bash">pip3 install --user qark  # --user is only needed if not using a virtualenv
qark --apk path/to/my.apk
qark --java path/to/parent/java/folder
qark --java path/to/specific/java/file.java
</code></pre>
<h3 id="reverseapk"><a class="header" href="#reverseapk"><a href="https://github.com/1N3/ReverseAPK.git"><strong>ReverseAPK</strong></a></a></h3>
<ul>
<li>显示所有提取的文件以便于参考</li>
<li>自动将APK文件反编译为Java和Smali格式</li>
<li>分析AndroidManifest.xml以查找常见漏洞和行为</li>
<li>静态源代码分析以查找常见漏洞和行为</li>
<li>设备信息</li>
<li>以及更多</li>
</ul>
<pre><code class="language-bash">reverse-apk relative/path/to/APP.apk
</code></pre>
<h3 id="super-android-analyzer"><a class="header" href="#super-android-analyzer"><a href="https://github.com/SUPERAndroidAnalyzer/super">SUPER Android Analyzer</a></a></h3>
<p>SUPER 是一个可以在 Windows、MacOS X 和 Linux 上使用的命令行应用程序，旨在分析 <em>.apk</em> 文件以寻找漏洞。它通过解压 APK 并应用一系列规则来检测这些漏洞。</p>
<p>所有规则都集中在一个 <code>rules.json</code> 文件中，每个公司或测试人员都可以创建自己的规则来分析他们需要的内容。</p>
<p>从 <a href="https://superanalyzer.rocks/download.html">下载页面</a> 下载最新的二进制文件。</p>
<pre><code>super-analyzer {apk_file}
</code></pre>
<h3 id="stacoan"><a class="header" href="#stacoan"><a href="https://github.com/vincentcox/StaCoAn">StaCoAn</a></a></h3>
<p><img src="../../.gitbook/assets/image%20(297).png" alt="" /></p>
<p>StaCoAn 是一个 <strong>跨平台</strong> 工具，帮助开发者、漏洞赏金猎人和道德黑客对移动应用程序进行 <a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态代码分析</a>。</p>
<p>其概念是将您的移动应用程序文件（.apk 或 .ipa 文件）拖放到 StaCoAn 应用程序上，它将为您生成一个可视化和便携的报告。您可以调整设置和词汇表，以获得定制的体验。</p>
<p>下载 <a href="https://github.com/vincentcox/StaCoAn/releases">最新版本</a>：</p>
<pre><code>./stacoan
</code></pre>
<h3 id="androbugs"><a class="header" href="#androbugs"><a href="https://github.com/AndroBugs/AndroBugs_Framework">AndroBugs</a></a></h3>
<p>AndroBugs Framework 是一个 Android 漏洞分析系统，帮助开发者或黑客发现 Android 应用中的潜在安全漏洞。<br />
<a href="https://github.com/AndroBugs/AndroBugs_Framework/releases">Windows releases</a></p>
<pre><code>python androbugs.py -f [APK file]
androbugs.exe -f [APK file]
</code></pre>
<h3 id="androwarn"><a class="header" href="#androwarn"><a href="https://github.com/maaaaz/androwarn">Androwarn</a></a></h3>
<p><strong>Androwarn</strong> 是一个工具，其主要目的是检测并警告用户关于 Android 应用程序可能存在的恶意行为。</p>
<p>检测是通过对应用程序的 Dalvik 字节码进行 <strong>静态分析</strong> 来执行的，该字节码以 <strong>Smali</strong> 形式表示，使用 <a href="https://github.com/androguard/androguard"><code>androguard</code></a> 库。</p>
<p>该工具寻找 <strong>“坏” 应用程序的常见行为</strong>，例如：电话标识符外泄、音频/视频流拦截、PIM 数据修改、任意代码执行...</p>
<pre><code>python androwarn.py -i my_application_to_be_analyzed.apk -r html -v 3
</code></pre>
<h3 id="mara-framework"><a class="header" href="#mara-framework"><a href="https://github.com/xtiankisutsa/MARA_Framework">MARA Framework</a></a></h3>
<p><img src="../../.gitbook/assets/image%20(595).png" alt="" /></p>
<p><strong>MARA</strong> 是一个 <strong>M</strong>obile <strong>A</strong>pplication <strong>R</strong>everse engineering 和 <strong>A</strong>nalysis Framework。它是一个将常用的移动应用程序逆向工程和分析工具整合在一起的工具，旨在帮助测试移动应用程序以应对 OWASP 移动安全威胁。其目标是使这一任务对移动应用程序开发人员和安全专业人员更加简单和友好。</p>
<p>它能够：</p>
<ul>
<li>使用不同工具提取 Java 和 Smali 代码</li>
<li>使用以下工具分析 APK： <a href="https://github.com/dorneanu/smalisca">smalisca</a>, <a href="https://github.com/google/android-classyshark">ClassyShark</a>, <a href="https://github.com/AndroBugs/AndroBugs_Framework">androbugs</a>, <a href="https://github.com/maaaaz/androwarn">androwarn</a>, <a href="https://github.com/rednaga/APKiD">APKiD</a></li>
<li>使用正则表达式从 APK 中提取私人信息。</li>
<li>分析 Manifest。</li>
<li>使用以下工具分析发现的域： <a href="https://github.com/moheshmohan/pyssltest">pyssltest</a>, <a href="https://github.com/drwetter/testssl.sh">testssl</a> 和 <a href="https://github.com/urbanadventurer/WhatWeb">whatweb</a></li>
<li>通过 <a href="http://www.apk-deguard.com">apk-deguard.com</a> 进行 APK 的去混淆。</li>
</ul>
<h3 id="koodous"><a class="header" href="#koodous">Koodous</a></h3>
<p>用于检测恶意软件： <a href="https://koodous.com">https://koodous.com/</a></p>
<h2 id="混淆去混淆代码"><a class="header" href="#混淆去混淆代码">混淆/去混淆代码</a></h2>
<p>请注意，具体取决于您用于混淆代码的服务和配置。秘密可能会被混淆或不会被混淆。</p>
<h3 id="proguard"><a class="header" href="#proguard"><a href="https://en.wikipedia.org/wiki/ProGuard_(software)">ProGuard</a></a></h3>
<p>来自 <a href="https://en.wikipedia.org/wiki/ProGuard_(software)">Wikipedia</a>：<strong>ProGuard</strong> 是一个开源命令行工具，用于缩小、优化和混淆 Java 代码。它能够优化字节码，并检测和删除未使用的指令。ProGuard 是免费软件，并根据 GNU 通用公共许可证第 2 版分发。</p>
<p>ProGuard 作为 Android SDK 的一部分分发，并在以发布模式构建应用程序时运行。</p>
<h3 id="dexguard"><a class="header" href="#dexguard"><a href="https://www.guardsquare.com/dexguard">DexGuard</a></a></h3>
<p>在 <a href="https://blog.lexfo.fr/dexguard.html">https://blog.lexfo.fr/dexguard.html</a> 找到逐步指南以去混淆 apk。</p>
<p>（来自该指南）上次我们检查时，Dexguard 的操作模式是：</p>
<ul>
<li>将资源加载为 InputStream；</li>
<li>将结果传递给继承自 FilterInputStream 的类以进行解密；</li>
<li>进行一些无用的混淆，以浪费反向工程师几分钟的时间；</li>
<li>将解密的结果传递给 ZipInputStream 以获取 DEX 文件；</li>
<li>最后使用 <code>loadDex</code> 方法将结果 DEX 作为资源加载。</li>
</ul>
<h3 id="deguard"><a class="header" href="#deguard"><a href="http://apk-deguard.com">DeGuard</a></a></h3>
<p><strong>DeGuard 逆转了 Android 混淆工具执行的混淆过程。这使得许多安全分析成为可能，包括代码检查和预测库。</strong></p>
<p>您可以将混淆的 APK 上传到他们的平台。</p>
<h3 id="simplify"><a class="header" href="#simplify"><a href="https://github.com/CalebFenton/simplify">Simplify</a></a></h3>
<p>它是一个 <strong>通用的 Android 去混淆器。</strong> Simplify <strong>虚拟执行应用程序</strong> 以理解其行为，然后 <strong>尝试优化代码</strong> 使其表现相同，但更易于人类理解。每种优化类型都简单且通用，因此无论使用何种特定类型的混淆都无关紧要。</p>
<h3 id="apkid"><a class="header" href="#apkid"><a href="https://github.com/rednaga/APKiD">APKiD</a></a></h3>
<p>APKiD 提供有关 <strong>APK 是如何制作的</strong> 信息。它识别许多 <strong>编译器</strong>、<strong>打包器</strong>、<strong>混淆器</strong> 和其他奇怪的东西。它是 Android 的 <a href="https://www.aldeid.com/wiki/PEiD"><em>PEiD</em></a>。</p>
<h3 id="手动"><a class="header" href="#手动">手动</a></h3>
<p><a href="manual-deobfuscation.html">阅读本教程以了解一些关于 <strong>如何逆向自定义混淆</strong> 的技巧</a></p>
<h2 id="实验室"><a class="header" href="#实验室">实验室</a></h2>
<h3 id="androl4b"><a class="header" href="#androl4b"><a href="https://github.com/sh4hin/Androl4b">Androl4b</a></a></h3>
<p>AndroL4b 是一个基于 ubuntu-mate 的 Android 安全虚拟机，包含来自不同安全极客和研究人员的最新框架、教程和实验室，用于逆向工程和恶意软件分析。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://owasp.org/www-project-mobile-app-security/">https://owasp.org/www-project-mobile-app-security/</a></li>
<li><a href="https://appsecwiki.com/#/">https://appsecwiki.com/#/</a> 这是一个很好的资源列表</li>
<li><a href="https://maddiestone.github.io/AndroidAppRE/">https://maddiestone.github.io/AndroidAppRE/</a> Android 快速课程</li>
<li><a href="https://manifestsecurity.com/android-application-security/">https://manifestsecurity.com/android-application-security/</a></li>
<li><a href="https://github.com/Ralireza/Android-Security-Teryaagh">https://github.com/Ralireza/Android-Security-Teryaagh</a></li>
<li><a href="https://www.youtube.com/watch?v=PMKnPaGWxtg&amp;feature=youtu.be&amp;ab_channel=B3nacSec">https://www.youtube.com/watch?v=PMKnPaGWxtg&amp;feature=youtu.be&amp;ab_channel=B3nacSec</a></li>
</ul>
<h2 id="尚待尝试"><a class="header" href="#尚待尝试">尚待尝试</a></h2>
<ul>
<li><a href="https://www.vegabird.com/yaazhini/">https://www.vegabird.com/yaazhini/</a></li>
<li><a href="https://github.com/abhi-r3v0/Adhrit">https://github.com/abhi-r3v0/Adhrit</a></li>
</ul>
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激和挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
及时了解最新的漏洞赏金发布和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作！</p>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术： <img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>在 Twitter 上关注</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../mobile-pentesting/android-checklist.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../mobile-pentesting/android-app-pentesting/android-applications-basics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../mobile-pentesting/android-checklist.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../mobile-pentesting/android-app-pentesting/android-applications-basics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
