<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Browser Extension Pentesting Methodology</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="浏览器扩展渗透测试方法论"><a class="header" href="#浏览器扩展渗透测试方法论">浏览器扩展渗透测试方法论</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="基本信息"><a class="header" href="#基本信息">基本信息</a></h2>
<p>浏览器扩展是用 JavaScript 编写的，并在后台由浏览器加载。它有自己的 <a href="https://www.w3schools.com/js/js_htmldom.asp">DOM</a>，但可以与其他网站的 DOM 进行交互。这意味着它可能会危害其他网站的机密性、完整性和可用性 (CIA)。</p>
<h2 id="主要组件"><a class="header" href="#主要组件">主要组件</a></h2>
<p>扩展布局在可视化时效果最佳，由三个组件组成。让我们深入了解每个组件。</p>
<figure><img src="../../.gitbook/assets/image (16) (1) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>
<h3 id="内容脚本"><a class="header" href="#内容脚本"><strong>内容脚本</strong></a></h3>
<p>每个内容脚本可以直接访问 <strong>单个网页</strong> 的 DOM，因此暴露于 <strong>潜在恶意输入</strong>。然而，内容脚本除了能够向扩展核心发送消息外，没有其他权限。</p>
<h3 id="扩展核心"><a class="header" href="#扩展核心"><strong>扩展核心</strong></a></h3>
<p>扩展核心包含大部分扩展权限/访问，但扩展核心只能通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> 和内容脚本与网页内容进行交互。此外，扩展核心无法直接访问主机机器。</p>
<h3 id="本地二进制文件"><a class="header" href="#本地二进制文件"><strong>本地二进制文件</strong></a></h3>
<p>扩展允许一个本地二进制文件，可以 <strong>以用户的全部权限访问主机机器。</strong> 本地二进制文件通过 Flash 和其他浏览器插件使用的标准 Netscape 插件应用程序编程接口 (<a href="https://en.wikipedia.org/wiki/NPAPI">NPAPI</a>) 与扩展核心进行交互。</p>
<h3 id="边界"><a class="header" href="#边界">边界</a></h3>
<p>{% hint style="danger" %}
为了获得用户的全部权限，攻击者必须说服扩展将恶意输入从内容脚本传递到扩展核心，再从扩展核心传递到本地二进制文件。
{% endhint %}</p>
<p>扩展的每个组件之间由 <strong>强保护边界</strong> 隔开。每个组件在 <strong>单独的操作系统进程</strong> 中运行。内容脚本和扩展核心在 <strong>沙箱进程</strong> 中运行，这些进程对大多数操作系统服务不可用。</p>
<p>此外，内容脚本通过 <strong>在单独的 JavaScript 堆中运行</strong> 与其关联的网页分开。内容脚本和网页可以 <strong>访问相同的底层 DOM</strong>，但两者 <strong>从不交换 JavaScript 指针</strong>，防止 JavaScript 功能的泄露。</p>
<h2 id="manifestjson"><a class="header" href="#manifestjson"><strong><code>manifest.json</code></strong></a></h2>
<p>Chrome 扩展只是一个带有 <a href="https://www.lifewire.com/crx-file-2620391">.crx 文件扩展名</a> 的 ZIP 文件夹。扩展的核心是位于文件夹根目录的 <strong><code>manifest.json</code></strong> 文件，该文件指定布局、权限和其他配置选项。</p>
<p>示例：</p>
<pre><code class="language-json">{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
</code></pre>
<h3 id="content_scripts"><a class="header" href="#content_scripts"><code>content_scripts</code></a></h3>
<p>内容脚本在用户<strong>导航到匹配页面</strong>时<strong>加载</strong>，在我们的例子中，任何匹配**<code>https://example.com/*</code><strong>表达式且不匹配</strong><code>*://*/*/business*</code><strong>正则表达式的页面。它们</strong>像页面自己的脚本**一样执行，并且对页面的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">文档对象模型 (DOM)</a>具有任意访问权限。</p>
<pre><code class="language-json">"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
</code></pre>
<p>为了包含或排除更多的 URL，您还可以使用 <strong><code>include_globs</code></strong> 和 <strong><code>exclude_globs</code></strong>。</p>
<p>这是一个示例内容脚本，当使用 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage">存储 API</a> 从扩展的存储中检索 <code>message</code> 值时，将向页面添加一个解释按钮。</p>
<pre><code class="language-js">chrome.storage.local.get("message", result =&gt;
{
let div = document.createElement("div");
div.innerHTML = result.message + " &lt;button&gt;Explain&lt;/button&gt;";
div.querySelector("button").addEventListener("click", () =&gt;
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
</code></pre>
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>
<p>当点击此按钮时，通过利用<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage"><strong>runtime.sendMessage() API</strong></a>，内容脚本向扩展页面发送消息。这是由于内容脚本在直接访问API方面的限制，<code>storage</code>是少数例外之一。对于超出这些例外的功能，消息被发送到扩展页面，内容脚本可以与之通信。</p>
<p>{% hint style="warning" %}
根据浏览器的不同，内容脚本的能力可能会略有不同。对于基于Chromium的浏览器，能力列表可在<a href="https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities">Chrome Developers documentation</a>中找到，而对于Firefox，<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis">MDN</a>是主要来源。<br />
值得注意的是，内容脚本能够与后台脚本进行通信，使其能够执行操作并传递响应。
{% endhint %}</p>
<p>要在Chrome中查看和调试内容脚本，可以通过选项 &gt; 更多工具 &gt; 开发者工具访问Chrome开发者工具菜单，或按Ctrl + Shift + I。</p>
<p>当开发者工具显示后，点击<strong>源</strong>选项卡，然后点击<strong>内容脚本</strong>选项卡。这允许观察来自各种扩展的运行内容脚本，并设置断点以跟踪执行流程。</p>
<h3 id="注入的内容脚本"><a class="header" href="#注入的内容脚本">注入的内容脚本</a></h3>
<p>{% hint style="success" %}
请注意，<strong>内容脚本不是强制性的</strong>，因为也可以<strong>动态</strong> <strong>注入</strong>脚本，并通过**<code>tabs.executeScript</code><strong>在网页中</strong>程序化地注入<strong>它们。这实际上提供了更</strong>细粒度的控制**。
{% endhint %}</p>
<p>对于内容脚本的程序化注入，扩展需要对要注入脚本的页面具有<a href="https://developer.chrome.com/docs/extensions/reference/permissions">主机权限</a>。这些权限可以通过在扩展的清单中<strong>请求它们</strong>或通过<a href="https://developer.chrome.com/docs/extensions/reference/manifest/activeTab"><strong>activeTab</strong></a>临时获得。</p>
<h4 id="示例-activetab-基础扩展"><a class="header" href="#示例-activetab-基础扩展">示例 activeTab 基础扩展</a></h4>
<p>{% code title="manifest.json" %}</p>
<pre><code class="language-json">{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
</code></pre>
<p>{% endcode %}</p>
<ul>
<li><strong>点击时注入一个JS文件：</strong></li>
</ul>
<pre><code class="language-javascript">// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) =&gt; {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
</code></pre>
<ul>
<li><strong>在点击时注入一个函数</strong>:</li>
</ul>
<pre><code class="language-javascript">//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) =&gt; {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
</code></pre>
<h4 id="示例与脚本权限"><a class="header" href="#示例与脚本权限">示例与脚本权限</a></h4>
<pre><code class="language-javascript">// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
</code></pre>
<p>为了包含或排除更多的 URL，您还可以使用 <strong><code>include_globs</code></strong> 和 <strong><code>exclude_globs</code></strong>。</p>
<h3 id="内容脚本-run_at"><a class="header" href="#内容脚本-run_at">内容脚本 <code>run_at</code></a></h3>
<p><code>run_at</code> 字段控制 <strong>JavaScript 文件何时注入到网页中</strong>。首选和默认值是 <code>"document_idle"</code>。</p>
<p>可能的值有：</p>
<ul>
<li><strong><code>document_idle</code></strong>：尽可能地</li>
<li><strong><code>document_start</code></strong>：在任何 <code>css</code> 文件之后，但在构建任何其他 DOM 或运行任何其他脚本之前。</li>
<li><strong><code>document_end</code></strong>：在 DOM 完成后立即，但在图像和框架等子资源加载之前。</li>
</ul>
<h4 id="通过-manifestjson"><a class="header" href="#通过-manifestjson">通过 <code>manifest.json</code></a></h4>
<pre><code class="language-json">{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

</code></pre>
<p>通过 <strong><code>service-worker.js</code></strong></p>
<pre><code class="language-javascript">chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
</code></pre>
<h3 id="background"><a class="header" href="#background"><code>background</code></a></h3>
<p>由内容脚本发送的消息由<strong>后台页面</strong>接收，后台页面在协调扩展的组件中发挥着核心作用。值得注意的是，后台页面在扩展的整个生命周期中持续存在，默默运行而无需直接用户交互。它拥有自己的文档对象模型（DOM），能够实现复杂的交互和状态管理。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>后台页面角色：</strong> 作为扩展的神经中枢，确保扩展各部分之间的通信和协调。</li>
<li><strong>持久性：</strong> 它是一个始终存在的实体，对用户不可见，但对扩展的功能至关重要。</li>
<li><strong>自动生成：</strong> 如果未明确定义，浏览器将自动创建一个后台页面。这个自动生成的页面将包含扩展清单中指定的所有后台脚本，确保扩展后台任务的无缝运行。</li>
</ul>
<p>{% hint style="success" %}
浏览器在自动生成后台页面（未明确声明时）所提供的便利，确保所有必要的后台脚本都被集成并正常运行，从而简化了扩展的设置过程。
{% endhint %}</p>
<p>示例后台脚本：</p>
<pre><code class="language-js">chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt;
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
</code></pre>
<p>它使用 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage">runtime.onMessage API</a> 来监听消息。当接收到 <code>"explain"</code> 消息时，它使用 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs">tabs API</a> 在新标签页中打开一个页面。</p>
<p>要调试后台脚本，您可以转到 <strong>扩展详细信息并检查服务工作者，</strong> 这将打开带有后台脚本的开发者工具：</p>
<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>
<h3 id="选项页面和其他"><a class="header" href="#选项页面和其他">选项页面和其他</a></h3>
<p>浏览器扩展可以包含各种类型的页面：</p>
<ul>
<li><strong>操作页面</strong> 在点击扩展图标时显示在 <strong>下拉菜单中</strong>。</li>
<li>扩展将 <strong>在新标签页中加载的页面</strong>。</li>
<li><strong>选项页面</strong>：此页面在点击时显示在扩展顶部。在之前的清单中，我能够通过 <code>chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca</code> 访问此页面或点击：</li>
</ul>
<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>
<p>请注意，这些页面不像后台页面那样持久，因为它们根据需要动态加载内容。尽管如此，它们与后台页面共享某些功能：</p>
<ul>
<li><strong>与内容脚本的通信：</strong> 类似于后台页面，这些页面可以接收来自内容脚本的消息，促进扩展内的交互。</li>
<li><strong>访问扩展特定的 API：</strong> 这些页面享有对扩展特定 API 的全面访问，受扩展定义的权限限制。</li>
</ul>
<h3 id="permissions--host_permissions"><a class="header" href="#permissions--host_permissions"><code>permissions</code> &amp; <code>host_permissions</code></a></h3>
<p><strong><code>permissions</code></strong> 和 <strong><code>host_permissions</code></strong> 是 <code>manifest.json</code> 中的条目，指示 <strong>浏览器扩展具有哪些权限</strong>（存储、位置等）以及 <strong>在哪些网页上</strong>。</p>
<p>由于浏览器扩展可能具有如此 <strong>特权</strong>，恶意扩展或被攻破的扩展可能允许攻击者 <strong>以不同方式窃取敏感信息并监视用户</strong>。</p>
<p>检查这些设置如何工作以及它们如何被滥用：</p>
<p>{% content-ref url="browext-permissions-and-host_permissions.md" %}
<a href="browext-permissions-and-host_permissions.html">browext-permissions-and-host_permissions.md</a>
{% endcontent-ref %}</p>
<h3 id="content_security_policy"><a class="header" href="#content_security_policy"><code>content_security_policy</code></a></h3>
<p><strong>内容安全策略</strong> 也可以在 <code>manifest.json</code> 中声明。如果定义了内容安全策略，它可能是 <strong>脆弱的</strong>。</p>
<p>浏览器扩展页面的默认设置相当严格：</p>
<pre><code class="language-bash">script-src 'self'; object-src 'self';
</code></pre>
<p>有关CSP和潜在绕过的更多信息，请查看：</p>
<p>{% content-ref url="../content-security-policy-csp-bypass/" %}
<a href="../content-security-policy-csp-bypass/">content-security-policy-csp-bypass</a>
{% endcontent-ref %}</p>
<h3 id="web_accessible_resources"><a class="header" href="#web_accessible_resources"><code>web_accessible_resources</code></a></h3>
<p>为了让网页访问浏览器扩展的页面，例如一个<code>.html</code>页面，该页面需要在<code>manifest.json</code>的**<code>web_accessible_resources</code>**字段中提到。<br />
例如：</p>
<pre><code class="language-javascript">{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
</code></pre>
<p>这些页面可以通过以下URL访问：</p>
<pre><code>chrome-extension://&lt;extension-id&gt;/message.html
</code></pre>
<p>在公共扩展中，<strong>extension-id 是可访问的</strong>：</p>
<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>
<p>不过，如果使用 <code>manifest.json</code> 参数 <strong><code>use_dynamic_url</code></strong>，则该 <strong>id 可能是动态的</strong>。</p>
<p>{% hint style="success" %}
请注意，即使此处提到某个页面，它也可能由于 <strong>内容安全策略</strong> 而 <strong>受到 ClickJacking 保护</strong>。因此，在确认 ClickJacking 攻击是否可能之前，您还需要检查它（frame-ancestors 部分）。
{% endhint %}</p>
<p>允许访问这些页面使这些页面 <strong>可能容易受到 ClickJacking 攻击</strong>：</p>
<p>{% content-ref url="browext-clickjacking.md" %}
<a href="browext-clickjacking.html">browext-clickjacking.md</a>
{% endcontent-ref %}</p>
<p>{% hint style="success" %}
仅允许这些页面由扩展加载，而不是由随机 URL 加载，可以防止 ClickJacking 攻击。
{% endhint %}</p>
<p>{% hint style="danger" %}
请注意，<strong><code>web_accessible_resources</code></strong> 中的页面和扩展的其他页面也能够 <strong>联系后台脚本</strong>。因此，如果这些页面中的一个容易受到 <strong>XSS</strong> 攻击，可能会导致更大的漏洞。</p>
<p>此外，请注意，您只能在 iframe 中打开 <strong><code>web_accessible_resources</code></strong> 中指示的页面，但从新标签页可以访问扩展中的任何页面，只需知道扩展 ID。因此，如果发现 XSS 利用相同的参数，即使页面未在 <strong><code>web_accessible_resources</code></strong> 中配置，也可能被利用。
{% endhint %}</p>
<h3 id="externally_connectable"><a class="header" href="#externally_connectable"><code>externally_connectable</code></a></h3>
<p>根据 <a href="https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable"><strong>文档</strong></a>，<code>"externally_connectable"</code> 清单属性声明 <strong>哪些扩展和网页可以通过</strong> <a href="https://developer.chrome.com/docs/extensions/reference/runtime#method-connect">runtime.connect</a> 和 <a href="https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage">runtime.sendMessage</a> 连接到您的扩展。</p>
<ul>
<li>如果在扩展的清单中 <strong>未声明 <code>externally_connectable</code></strong> 键或声明为 <strong><code>"ids": ["*"]</code></strong>，<strong>所有扩展都可以连接，但没有网页可以连接</strong>。</li>
<li>如果指定了 <strong>特定 ID</strong>，如 <code>"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]</code>，<strong>只有这些应用程序</strong>可以连接。</li>
<li>如果指定了 <strong>匹配项</strong>，这些网页应用程序将能够连接：</li>
</ul>
<pre><code class="language-json">"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
</code></pre>
<ul>
<li>如果指定为空：<strong><code>"externally_connectable": {}</code></strong>，则没有应用程序或网页能够连接。</li>
</ul>
<p>这里指示的<strong>扩展和网址越少</strong>，<strong>攻击面就越小</strong>。</p>
<p>{% hint style="danger" %}
如果在**<code>externally_connectable</code><strong>中指示了</strong>易受XSS或接管攻击的网页**，攻击者将能够<strong>直接向后台脚本发送消息</strong>，完全绕过内容脚本及其CSP。</p>
<p>因此，这是一个<strong>非常强大的绕过</strong>。</p>
<p>此外，如果客户端安装了一个恶意扩展，即使它不被允许与易受攻击的扩展通信，它也可以在<strong>允许的网页中注入XSS数据</strong>，或滥用**<code>WebRequest</code><strong>或</strong><code>DeclarativeNetRequest</code>** API来操纵目标域上的请求，改变页面对<strong>JavaScript文件</strong>的请求。（请注意，目标页面上的CSP可能会阻止这些攻击）。这个想法来自<a href="https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability"><strong>这篇文章</strong></a>。
{% endhint %}</p>
<h2 id="通信总结"><a class="header" href="#通信总结">通信总结</a></h2>
<h3 id="扩展----webapp"><a class="header" href="#扩展----webapp">扩展 &lt;--&gt; WebApp</a></h3>
<p>在内容脚本和网页之间，通常使用后续消息进行通信。因此，在网页应用程序中，您通常会找到对**<code>window.postMessage</code><strong>函数的调用，而在内容脚本中则有像</strong><code>window.addEventListener</code><strong>这样的监听器。然而，请注意，扩展也可以</strong>通过发送Post Message与网页应用程序通信**（因此网页应该预期到这一点），或者只是让网页加载一个新脚本。</p>
<h3 id="在扩展内部"><a class="header" href="#在扩展内部">在扩展内部</a></h3>
<p>通常使用**<code>chrome.runtime.sendMessage</code><strong>在扩展内部发送消息（通常由<code>background</code>脚本处理），为了接收和处理它，声明一个监听器调用</strong><code>chrome.runtime.onMessage.addListener</code>**。</p>
<p>也可以使用**<code>chrome.runtime.connect()</code><strong>来建立持久连接，而不是发送单个消息，可以用它来</strong>发送<strong>和</strong>接收****消息**，如下例所示：</p>
<details>
<summary><code>chrome.runtime.connect()</code> 示例</summary>
```javascript
var port = chrome.runtime.connect();
<p>// Listen for messages from the web page
window.addEventListener("message", (event) =&gt; {
// Only accept messages from the same window
if (event.source !== window) {
return;
}</p>
<p>// Check if the message type is "FROM_PAGE"
if (event.data.type &amp;&amp; (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);</p>
<p>// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});</p>
<pre><code>&lt;/details&gt;

也可以从后台脚本向位于特定标签页中的内容脚本发送消息，调用 **`chrome.tabs.sendMessage`**，在此需要指明要发送消息的 **标签页ID**。

### 从允许的 `externally_connectable` 到扩展

在 `externally_connectable` 配置中允许的 **Web 应用和外部浏览器扩展** 可以使用以下方式发送请求：
```javascript
chrome.runtime.sendMessage(extensionId, ...
</code></pre>
<p>需要提到 <strong>extension ID</strong> 的地方。</p>
<h3 id="本地消息传递"><a class="header" href="#本地消息传递">本地消息传递</a></h3>
<p>后台脚本可以与系统内的二进制文件进行通信，如果这种通信没有得到妥善保护，可能会 <strong>容易受到诸如 RCEs 的关键漏洞</strong>。 <a href="./#native-messaging">稍后会详细介绍</a>。</p>
<pre><code class="language-javascript">chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
</code></pre>
<h2 id="web--内容脚本通信"><a class="header" href="#web--内容脚本通信">Web <strong>↔︎</strong> 内容脚本通信</a></h2>
<p><strong>内容脚本</strong> 操作的环境与主机页面存在的环境是 <strong>分开的</strong>，确保了 <strong>隔离</strong>。尽管存在这种隔离，双方都能够与页面的 <strong>文档对象模型 (DOM)</strong> 进行交互，这是一个共享资源。为了使主机页面能够与 <strong>内容脚本</strong> 进行通信，或通过内容脚本间接与扩展进行通信，必须利用双方都可以访问的 <strong>DOM</strong> 作为通信通道。</p>
<h3 id="发送消息"><a class="header" href="#发送消息">发送消息</a></h3>
<p>{% code title="content-script.js" %}</p>
<pre><code class="language-javascript">// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) =&gt; {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type &amp;&amp; (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
</code></pre>
<p>{% endcode %}</p>
<p>{% code title="example.js" %}</p>
<pre><code class="language-javascript">document.getElementById("theButton").addEventListener("click", () =&gt; {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
</code></pre>
<p>{% endcode %}</p>
<p>安全的 Post Message 通信应检查接收到的消息的真实性，这可以通过以下方式进行检查：</p>
<ul>
<li><strong><code>event.isTrusted</code></strong>：只有当事件是由用户操作触发时，这个值才为 True</li>
<li>内容脚本可能只在用户执行某些操作时才期待接收到消息</li>
<li><strong>源域</strong>：可能只允许白名单中的域接收消息。</li>
<li>如果使用正则表达式，请非常小心</li>
<li><strong>来源</strong>：<code>received_message.source !== window</code> 可用于检查消息是否来自 <strong>同一窗口</strong>，即内容脚本正在监听的窗口。</li>
</ul>
<p>即使执行了上述检查，仍可能存在漏洞，因此请检查以下页面 <strong>潜在的 Post Message 绕过</strong>：</p>
<p>{% content-ref url="../postmessage-vulnerabilities/" %}
<a href="../postmessage-vulnerabilities/">postmessage-vulnerabilities</a>
{% endcontent-ref %}</p>
<h3 id="iframe"><a class="header" href="#iframe">Iframe</a></h3>
<p>另一种可能的通信方式可能是通过 <strong>Iframe URLs</strong>，您可以在以下位置找到示例：</p>
<p>{% content-ref url="browext-xss-example.md" %}
<a href="browext-xss-example.html">browext-xss-example.md</a>
{% endcontent-ref %}</p>
<h3 id="dom"><a class="header" href="#dom">DOM</a></h3>
<p>这并不是“确切的”通信方式，但 <strong>网页和内容脚本将可以访问网页 DOM</strong>。因此，如果 <strong>内容脚本</strong> 从中读取某些信息，<strong>信任网页 DOM</strong>，网页可能会 <strong>修改这些数据</strong>（因为网页不应被信任，或者因为网页易受 XSS 攻击）并 <strong>危害内容脚本</strong>。</p>
<p>您还可以在以下位置找到 <strong>基于 DOM 的 XSS 以危害浏览器扩展</strong> 的示例：</p>
<p>{% content-ref url="browext-xss-example.md" %}
<a href="browext-xss-example.html">browext-xss-example.md</a>
{% endcontent-ref %}</p>
<h2 id="内容脚本--后台脚本通信"><a class="header" href="#内容脚本--后台脚本通信">内容脚本 <strong>↔︎</strong> 后台脚本通信</a></h2>
<p>内容脚本可以使用 <a href="https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage"><strong>runtime.sendMessage()</strong></a> <strong>或</strong> <a href="https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage"><strong>tabs.sendMessage()</strong></a> 发送 <strong>一次性 JSON 可序列化</strong> 消息。</p>
<p>要处理 <strong>响应</strong>，请使用返回的 <strong>Promise</strong>。尽管为了向后兼容，您仍然可以将 <strong>回调</strong> 作为最后一个参数传递。</p>
<p>从 <strong>内容脚本</strong> 发送请求的方式如下：</p>
<pre><code class="language-javascript">(async () =&gt; {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
</code></pre>
<p>从<strong>扩展</strong>发送请求（通常是<strong>后台脚本</strong>）。以下是如何向选定标签页中的内容脚本发送消息的示例：</p>
<pre><code class="language-javascript">// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () =&gt; {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
</code></pre>
<p>在<strong>接收端</strong>，您需要设置一个 <a href="https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage"><strong>runtime.onMessage</strong></a> <strong>事件监听器</strong> 来处理消息。这在内容脚本或扩展页面中看起来是一样的。</p>
<pre><code class="language-javascript">// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
</code></pre>
<p>在突出显示的示例中，<strong><code>sendResponse()</code></strong> 是以同步方式执行的。要修改 <code>onMessage</code> 事件处理程序以异步执行 <code>sendResponse()</code>，必须加入 <code>return true;</code>。</p>
<p>一个重要的考虑是，在多个页面设置为接收 <code>onMessage</code> 事件的情况下，<strong>第一个执行 <code>sendResponse()</code></strong> 的页面将是唯一能够有效传递响应的页面。对同一事件的任何后续响应将不被考虑。</p>
<p>在创建新扩展时，应该优先使用 promises 而不是回调。关于回调的使用，只有在同步上下文中直接执行 <code>sendResponse()</code> 函数，或者事件处理程序通过返回 <code>true</code> 表示异步操作时，<code>sendResponse()</code> 函数才被视为有效。如果没有任何处理程序返回 <code>true</code>，或者 <code>sendResponse()</code> 函数从内存中移除（被垃圾回收），则与 <code>sendMessage()</code> 函数关联的回调将默认被触发。</p>
<h2 id="native-messaging"><a class="header" href="#native-messaging">Native Messaging</a></h2>
<p>浏览器扩展还允许通过 <strong>stdin</strong> 与系统中的 <strong>二进制文件</strong> 进行通信。应用程序必须安装一个 json 来指示这一点，格式如下：</p>
<pre><code class="language-json">{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
</code></pre>
<pre><code class="language-markdown">其中 `name` 是传递给 [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) 或 [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) 的字符串，用于从浏览器扩展的后台脚本与应用程序进行通信。`path` 是二进制文件的路径，只有 1 种有效的 `type`，即 stdio（使用 stdin 和 stdout），而 `allowed_origins` 表示可以访问它的扩展（不能使用通配符）。

Chrome/Chromium 会在某些 Windows 注册表和 macOS 和 Linux 的某些路径中搜索此 json（更多信息请参见 [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)）。

{% hint style="success" %}
浏览器扩展还需要声明 `nativeMessaing` 权限，以便能够使用此通信。
{% endhint %}

这就是一些后台脚本代码向本地应用程序发送消息的样子：
</code></pre>
<pre><code class="language-javascript">chrome.runtime.sendNativeMessage(
'com.my_company.my_application',
{text: 'Hello'},
function (response) {
console.log('Received ' + response);
}
);
</code></pre>
<p>在<a href="https://spaceraccoon.dev/universal-code-execution-browser-extensions/"><strong>这篇博客文章</strong></a>中，提出了一种利用本机消息的脆弱模式：</p>
<ol>
<li>浏览器扩展对内容脚本有一个通配符模式。</li>
<li>内容脚本使用<code>sendMessage</code>将<code>postMessage</code>消息传递给后台脚本。</li>
<li>后台脚本使用<code>sendNativeMessage</code>将消息传递给本机应用程序。</li>
<li>本机应用程序危险地处理消息，导致代码执行。</li>
</ol>
<p>其中解释了<strong>如何从任何页面利用浏览器扩展进行RCE</strong>的示例。</p>
<h2 id="内存代码剪贴板中的敏感信息"><a class="header" href="#内存代码剪贴板中的敏感信息">内存/代码/剪贴板中的敏感信息</a></h2>
<p>如果浏览器扩展将<strong>敏感信息存储在其内存中</strong>，则可能会被<strong>转储</strong>（特别是在Windows机器上）并<strong>搜索</strong>这些信息。</p>
<p>因此，浏览器扩展的内存<strong>不应被视为安全</strong>，并且<strong>敏感信息</strong>如凭据或助记短语<strong>不应存储</strong>。</p>
<p>当然，<strong>不要将敏感信息放入代码中</strong>，因为它将是<strong>公开的</strong>。</p>
<p>要从浏览器转储内存，可以<strong>转储进程内存</strong>，或者要进入浏览器扩展的<strong>设置</strong>，点击**<code>Inspect pop-up</code>** -&gt; 在**<code>Memory</code><strong>部分 -&gt; <strong><code>Take a snaphost</code></strong>，然后使用</strong><code>CTRL+F</code>**在快照中搜索敏感信息。</p>
<p>此外，像助记密钥或密码这样的高度敏感信息<strong>不应允许复制到剪贴板</strong>（或至少在几秒钟内将其从剪贴板中移除），因为这样监控剪贴板的进程将能够获取它们。</p>
<h2 id="在浏览器中加载扩展"><a class="header" href="#在浏览器中加载扩展">在浏览器中加载扩展</a></h2>
<ol>
<li><strong>下载</strong>浏览器扩展并解压</li>
<li>转到**<code>chrome://extensions/</code><strong>并</strong>启用**<code>开发者模式</code></li>
<li>点击**<code>加载已解压的扩展</code>**按钮</li>
</ol>
<p>在<strong>Firefox</strong>中，转到**<code>about:debugging#/runtime/this-firefox</code><strong>并点击</strong><code>加载临时附加组件</code>**按钮。</p>
<h2 id="从商店获取源代码"><a class="header" href="#从商店获取源代码">从商店获取源代码</a></h2>
<p>Chrome扩展的源代码可以通过多种方法获得。以下是每个选项的详细说明和指示。</p>
<h3 id="通过命令行将扩展下载为zip"><a class="header" href="#通过命令行将扩展下载为zip">通过命令行将扩展下载为ZIP</a></h3>
<p>Chrome扩展的源代码可以通过命令行下载为ZIP文件。这涉及使用<code>curl</code>从特定URL获取ZIP文件，然后将ZIP文件的内容提取到一个目录中。以下是步骤：</p>
<ol>
<li>将<code>"extension_id"</code>替换为扩展的实际ID。</li>
<li>执行以下命令：</li>
</ol>
<pre><code class="language-bash">extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&amp;os=mac&amp;arch=x86-64&amp;nacl_arch=x86-64&amp;prod=chromecrx&amp;prodchannel=stable&amp;prodversion=44.0.2403.130&amp;x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
</code></pre>
<h3 id="使用-crx-viewer-网站"><a class="header" href="#使用-crx-viewer-网站">使用 CRX Viewer 网站</a></h3>
<p><a href="https://robwu.nl/crxviewer/">https://robwu.nl/crxviewer/</a></p>
<h3 id="使用-crx-viewer-扩展"><a class="header" href="#使用-crx-viewer-扩展">使用 CRX Viewer 扩展</a></h3>
<p>另一种方便的方法是使用 Chrome 扩展源查看器，这是一个开源项目。可以从 <a href="https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en">Chrome Web Store</a> 安装。查看器的源代码可以在其 <a href="https://github.com/Rob--W/crxviewer">GitHub 仓库</a> 中找到。</p>
<h3 id="查看本地安装的扩展的源代码"><a class="header" href="#查看本地安装的扩展的源代码">查看本地安装的扩展的源代码</a></h3>
<p>本地安装的 Chrome 扩展也可以被检查。方法如下：</p>
<ol>
<li>通过访问 <code>chrome://version/</code> 并找到“Profile Path”字段来访问您的 Chrome 本地配置文件目录。</li>
<li>在配置文件目录中导航到 <code>Extensions/</code> 子文件夹。</li>
<li>该文件夹包含所有已安装的扩展，通常其源代码以可读格式存放。</li>
</ol>
<p>要识别扩展，您可以将它们的 ID 映射到名称：</p>
<ul>
<li>在 <code>about:extensions</code> 页面上启用开发者模式，以查看每个扩展的 ID。</li>
<li>在每个扩展的文件夹中，<code>manifest.json</code> 文件包含一个可读的 <code>name</code> 字段，帮助您识别扩展。</li>
</ul>
<h3 id="使用文件归档程序或解压缩工具"><a class="header" href="#使用文件归档程序或解压缩工具">使用文件归档程序或解压缩工具</a></h3>
<p>前往 Chrome Web Store 下载扩展。文件将具有 <code>.crx</code> 扩展名。将文件扩展名从 <code>.crx</code> 更改为 <code>.zip</code>。使用任何文件归档程序（如 WinRAR、7-Zip 等）提取 ZIP 文件的内容。</p>
<h3 id="在-chrome-中使用开发者模式"><a class="header" href="#在-chrome-中使用开发者模式">在 Chrome 中使用开发者模式</a></h3>
<p>打开 Chrome 并转到 <code>chrome://extensions/</code>。在右上角启用“开发者模式”。点击“加载已解压的扩展...”。导航到您的扩展目录。这不会下载源代码，但对于查看和修改已下载或开发的扩展的代码非常有用。</p>
<h2 id="chrome-扩展清单数据集"><a class="header" href="#chrome-扩展清单数据集">Chrome 扩展清单数据集</a></h2>
<p>为了尝试发现易受攻击的浏览器扩展，您可以使用 <a href="https://github.com/palant/chrome-extension-manifests-dataset">https://github.com/palant/chrome-extension-manifests-dataset</a> 并检查它们的清单文件以寻找潜在的脆弱迹象。例如，检查用户超过 25000 的扩展，<code>content_scripts</code> 和权限 <code>nativeMessaing</code>：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash"># Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count &gt; 250000" "manifest.content_scripts?.length &gt; 0 &amp;&amp; manifest.permissions?.includes('nativeMessaging')"
</code></pre>
<p>{% endcode %}</p>
<h2 id="安全审计检查表"><a class="header" href="#安全审计检查表">安全审计检查表</a></h2>
<p>尽管浏览器扩展具有<strong>有限的攻击面</strong>，但其中一些可能包含<strong>漏洞</strong>或<strong>潜在的加固改进</strong>。以下是最常见的：</p>
<ul>
<li><input disabled="" type="checkbox"/>
尽可能<strong>限制</strong>请求的**<code>permissions</code>**</li>
<li><input disabled="" type="checkbox"/>
尽可能<strong>限制****<code>host_permissions</code></strong></li>
<li><input disabled="" type="checkbox"/>
使用<strong>强</strong>的**<code>content_security_policy</code>**</li>
<li><input disabled="" type="checkbox"/>
尽可能<strong>限制****<code>externally_connectable</code></strong>，如果不需要且可能，请不要默认留空，指定**<code>{}</code>**</li>
<li><input disabled="" type="checkbox"/>
如果这里提到的<strong>URL易受XSS或接管攻击</strong>，攻击者将能够<strong>直接向后台脚本发送消息</strong>。非常强大的绕过方式。</li>
<li><input disabled="" type="checkbox"/>
尽可能<strong>限制****<code>web_accessible_resources</code></strong>，甚至如果可能的话留空。</li>
<li><input disabled="" type="checkbox"/>
如果**<code>web_accessible_resources</code>**不为空，请检查<a href="browext-clickjacking.html"><strong>ClickJacking</strong></a></li>
<li><input disabled="" type="checkbox"/>
如果<strong>扩展</strong>与<strong>网页</strong>之间发生任何<strong>通信</strong>，请<a href="browext-xss-example.html"><strong>检查XSS</strong></a> <strong>漏洞</strong>。</li>
<li><input disabled="" type="checkbox"/>
如果使用了Post Messages，请检查<a href="../postmessage-vulnerabilities/"><strong>Post Message漏洞</strong></a><strong>。</strong></li>
<li><input disabled="" type="checkbox"/>
如果<strong>内容脚本访问DOM细节</strong>，请检查它们是否在被网页<strong>修改</strong>时<strong>引入XSS</strong>。</li>
<li><input disabled="" type="checkbox"/>
如果此通信也涉及<strong>内容脚本 -&gt; 后台脚本通信</strong>，请特别强调。</li>
<li><input disabled="" type="checkbox"/>
如果后台脚本通过<strong>本机消息传递</strong>进行通信，请检查通信是否安全且经过清理。</li>
<li><input disabled="" type="checkbox"/>
<strong>敏感信息不应存储</strong>在浏览器扩展<strong>代码</strong>中。</li>
<li><input disabled="" type="checkbox"/>
<strong>敏感信息不应存储</strong>在浏览器扩展<strong>内存</strong>中。</li>
<li><input disabled="" type="checkbox"/>
<strong>敏感信息不应存储</strong>在<strong>文件系统中未加保护</strong>。</li>
</ul>
<h2 id="浏览器扩展风险"><a class="header" href="#浏览器扩展风险">浏览器扩展风险</a></h2>
<ul>
<li>应用程序<a href="https://crxaminer.tech/">https://crxaminer.tech/</a>分析一些数据，例如浏览器扩展请求的权限，以提供使用浏览器扩展的风险级别。</li>
</ul>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<h3 id="tarnish"><a class="header" href="#tarnish"><a href="https://thehackerblog.com/tarnish/"><strong>Tarnish</strong></a></a></h3>
<ul>
<li>从提供的Chrome网上应用店链接提取任何Chrome扩展。</li>
<li><a href="https://developer.chrome.com/extensions/manifest"><strong>manifest.json</strong></a> <strong>查看器</strong>：简单地显示扩展清单的JSON美化版本。</li>
<li><strong>指纹分析</strong>：检测<a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources">web_accessible_resources</a>并自动生成Chrome扩展指纹JavaScript。</li>
<li><strong>潜在的Clickjacking分析</strong>：检测设置了<a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources">web_accessible_resources</a>指令的扩展HTML页面。这些页面可能会受到Clickjacking的攻击，具体取决于页面的目的。</li>
<li><strong>权限警告查看器</strong>：显示用户尝试安装扩展时将显示的所有Chrome权限提示警告的列表。</li>
<li><strong>危险函数</strong>：显示可能被攻击者利用的危险函数的位置（例如，innerHTML、chrome.tabs.executeScript等函数）。</li>
<li><strong>入口点</strong>：显示扩展接收用户/外部输入的位置。这对于理解扩展的表面区域和寻找潜在的恶意数据发送点非常有用。</li>
<li>危险函数和入口点扫描器生成的警报包含以下内容：</li>
<li>相关代码片段和导致警报的行。</li>
<li>问题描述。</li>
<li>“查看文件”按钮以查看包含代码的完整源文件。</li>
<li>警报文件的路径。</li>
<li>警报文件的完整Chrome扩展URI。</li>
<li>文件类型，例如后台页面脚本、内容脚本、浏览器操作等。</li>
<li>如果易受攻击的行在JavaScript文件中，则包括所有包含该行的页面的路径以及这些页面的类型和<a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources">web_accessible_resource</a>状态。</li>
<li><strong>内容安全策略（CSP）分析器和绕过检查器</strong>：这将指出扩展CSP中的弱点，并将揭示由于白名单CDN等可能绕过CSP的任何潜在方式。</li>
<li><strong>已知漏洞库</strong>：使用<a href="https://retirejs.github.io/retire.js/">Retire.js</a>检查是否使用了已知漏洞的JavaScript库。</li>
<li>下载扩展和格式化版本。</li>
<li>下载原始扩展。</li>
<li>下载美化版本的扩展（自动美化的HTML和JavaScript）。</li>
<li>扫描结果的自动缓存，第一次运行扩展扫描将花费相当多的时间。然而，第二次运行时，假设扩展没有更新，将几乎是瞬时的，因为结果已被缓存。</li>
<li>可链接的报告URL，轻松将其他人链接到由Tarnish生成的扩展报告。</li>
</ul>
<h3 id="neto"><a class="header" href="#neto"><a href="https://github.com/elevenpaths/neto">Neto</a></a></h3>
<p>项目Neto是一个Python 3包，旨在分析和揭示Firefox和Chrome等知名浏览器的浏览器插件和扩展的隐藏功能。它自动解压打包文件，以从扩展的相关资源中提取这些功能，如<code>manifest.json</code>、本地化文件夹或JavaScript和HTML源文件。</p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><strong>感谢</strong> <a href="https://twitter.com/naivenom"><strong>@naivenom</strong></a> <strong>对本方法的帮助</strong></li>
<li><a href="https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing">https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing</a></li>
<li><a href="https://palant.info/2022/08/10/anatomy-of-a-basic-extension/">https://palant.info/2022/08/10/anatomy-of-a-basic-extension/</a></li>
<li><a href="https://palant.info/2022/08/24/attack-surface-of-extension-pages/">https://palant.info/2022/08/24/attack-surface-of-extension-pages/</a></li>
<li><a href="https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/">https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/</a></li>
<li><a href="https://help.passbolt.com/assets/files/PBL-02-report.pdf">https://help.passbolt.com/assets/files/PBL-02-report.pdf</a></li>
<li><a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts">https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts</a></li>
<li><a href="https://developer.chrome.com/docs/extensions/mv2/background-pages">https://developer.chrome.com/docs/extensions/mv2/background-pages</a></li>
<li><a href="https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/">https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/</a></li>
<li><a href="https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0">https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0</a></li>
</ul>
<p>{% hint style="success" %}
学习和实践AWS黑客攻击：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks培训AWS红队专家（ARTE）</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践GCP黑客攻击：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks培训GCP红队专家（GRTE）</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持HackTricks</summary>
<ul>
<li>查看<a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord小组</strong></a>或<a href="https://t.me/peass"><strong>电报小组</strong></a>或<strong>在Twitter上关注</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a>和<a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub库提交PR分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pentesting-web/account-takeover.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pentesting-web/browser-extension-pentesting-methodology/browext-clickjacking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pentesting-web/account-takeover.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pentesting-web/browser-extension-pentesting-methodology/browext-clickjacking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
