# OAuth to Account takeover

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth, [OAuth 2.0 belgeleri](https://oauth.net/2/) adresinde erişilebilen temel bilgilerle birlikte çeşitli sürümler sunar. Bu tartışma esas olarak yaygın olarak kullanılan [OAuth 2.0 yetkilendirme kodu hibe türü](https://oauth.net/2/grant-types/authorization-code/) etrafında döner ve **bir uygulamanın başka bir uygulamadaki bir kullanıcının hesabına erişmesini veya eylemler gerçekleştirmesini sağlayan bir yetkilendirme çerçevesi** sunar (yetkilendirme sunucusu).

Hayali bir web sitesi _**https://example.com**_ düşünün; bu site **tüm sosyal medya gönderilerinizi**, özel olanlar da dahil olmak üzere, **sergilemek** için tasarlanmıştır. Bunu başarmak için OAuth 2.0 kullanılır. _https://example.com_, **sosyal medya gönderilerinize erişim** izni talep edecektir. Sonuç olarak, _https://socialmedia.com_ adresinde, **talep edilen izinler ve talebi yapan geliştirici** hakkında bilgi veren bir onay ekranı belirecektir. Onayınızla, _https://example.com_ **adınıza gönderilerinize erişim** elde eder.

OAuth 2.0 çerçevesindeki aşağıdaki bileşenleri anlamak önemlidir:

* **resource owner**: Siz, **kullanıcı/varlık** olarak, sosyal medya hesabınızdaki gönderiler gibi kaynaklarınıza erişim izni verirsiniz.
* **resource server**: Uygulamanın `resource owner` adına bir `access token` güvence altına aldıktan sonra **kimlik doğrulama isteklerini yöneten sunucu**, örneğin, **https://socialmedia.com**.
* **client application**: `resource owner`dan yetkilendirme talep eden **uygulama**, örneğin **https://example.com**.
* **authorization server**: `resource owner`ın başarılı bir şekilde kimlik doğrulamasını yaptıktan sonra `client application`a `access tokens` veren **sunucu**, örneğin, **https://socialmedia.com**.
* **client\_id**: Uygulama için kamuya açık, benzersiz bir tanımlayıcı.
* **client\_secret:** Sadece uygulama ve yetkilendirme sunucusu tarafından bilinen, `access_tokens` oluşturmak için kullanılan gizli bir anahtar.
* **response\_type**: **istenen token türünü belirten** bir değer, örneğin `code`.
* **scope**: `client application`ın `resource owner`dan talep ettiği **erişim seviyesi**.
* **redirect\_uri**: **yetkilendirmeden sonra kullanıcının yönlendirileceği URL**. Bu genellikle önceden kaydedilmiş yönlendirme URL'si ile uyumlu olmalıdır.
* **state**: **kullanıcının yetkilendirme sunucusuna yönlendirilmesi sırasında verileri korumak için** bir parametre. Benzersizliği, **CSRF koruma mekanizması** olarak hizmet etmesi için kritik öneme sahiptir.
* **grant\_type**: **hibe türünü ve döndürülecek token türünü belirten** bir parametre.
* **code**: `authorization server`dan alınan yetkilendirme kodu; `client application` tarafından `access_token` almak için `client_id` ve `client_secret` ile birlikte kullanılır.
* **access\_token**: `resource owner` adına API istekleri için `client application`ın kullandığı **token**.
* **refresh\_token**: Uygulamanın **kullanıcıyı yeniden istemeden yeni bir `access_token` almasını** sağlar.

### Flow

**Gerçek OAuth akışı** şu şekilde ilerler:

1. [https://example.com](https://example.com) adresine gidersiniz ve “Sosyal Medya ile Entegre Ol” butonunu seçersiniz.
2. Site, https://example.com uygulamasının gönderilerinize erişim izni talep etmek için [https://socialmedia.com](https://socialmedia.com) adresine bir istek gönderir. İstek şu şekilde yapılandırılmıştır:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ardından bir onay sayfası ile karşılaşırsınız.  
4. Onayınızı takiben, Sosyal Medya `code` ve `state` parametreleri ile birlikte `redirect_uri`'ye bir yanıt gönderir:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com bu `code`'u, `client_id` ve `client_secret` ile birlikte, sizin adınıza bir `access_token` almak için sunucu tarafında bir istek yapmak üzere kullanır ve onayladığınız izinlere erişim sağlar:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Son olarak, süreç https://example.com `access_token`'ınızı kullanarak Sosyal Medya'ya erişmek için bir API çağrısı yapar.

## Güvenlik Açıkları <a href="#id-323a" id="id-323a"></a>

### Açık yönlendirme\_uri <a href="#cc36" id="cc36"></a>

`redirect_uri`, OAuth ve OpenID uygulamalarında güvenlik için kritik öneme sahiptir, çünkü yetkilendirme kodları gibi hassas verilerin yetkilendirme sonrası nereye gönderileceğini yönlendirir. Yanlış yapılandırıldığında, saldırganların bu istekleri kötü niyetli sunuculara yönlendirmesine izin verebilir, bu da hesap ele geçirmeye yol açabilir.

Sömürü teknikleri, yetkilendirme sunucusunun doğrulama mantığına bağlı olarak değişir. Katı yol eşleştirmeden, belirtilen alan veya alt dizin içindeki herhangi bir URL'yi kabul etmeye kadar değişebilir. Yaygın sömürü yöntemleri arasında açık yönlendirmeler, yol geçişi, zayıf regexlerin sömürülmesi ve token hırsızlığı için HTML enjeksiyonu yer alır.

`redirect_uri` dışında, `client_uri`, `policy_uri`, `tos_uri` ve `initiate_login_uri` gibi diğer OAuth ve OpenID parametreleri de yönlendirme saldırılarına karşı hassastır. Bu parametreler isteğe bağlıdır ve destekleri sunucular arasında değişiklik gösterir.

OpenID sunucusunu hedef alanlar için, keşif uç noktası (`**.well-known/openid-configuration**`) genellikle `registration_endpoint`, `request_uri_parameter_supported` ve "`require_request_uri_registration`" gibi değerli yapılandırma ayrıntılarını listeler. Bu ayrıntılar, kayıt uç noktasını ve sunucunun diğer yapılandırma özelliklerini belirlemede yardımcı olabilir.

### Yönlendirme uygulamasında XSS <a href="#bda5" id="bda5"></a>

Bu hata ödülü raporunda belirtildiği gibi [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), yönlendirme **URL'sinin, kullanıcı kimlik doğruladıktan sonra sunucunun yanıtında yansıtılması** mümkün olabilir ve bu durum **XSS'ye karşı savunmasızdır**. Test etmek için olası yük:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - State parametresinin yanlış yönetimi <a href="#bda5" id="bda5"></a>

OAuth uygulamalarında, **`state` parametresinin** kötüye kullanımı veya atlanması, **Cross-Site Request Forgery (CSRF)** saldırılarının riskini önemli ölçüde artırabilir. Bu zafiyet, `state` parametresi **kullanılmadığında, statik bir değer olarak kullanıldığında veya düzgün bir şekilde doğrulanmadığında** ortaya çıkar ve saldırganların CSRF korumalarını atlamasına olanak tanır.

Saldırganlar, yetkilendirme sürecini kesintiye uğratarak kendi hesaplarını bir mağdurun hesabıyla ilişkilendirebilir, bu da potansiyel **hesap ele geçirmelerine** yol açar. Bu, OAuth'un **kimlik doğrulama amaçları** için kullanıldığı uygulamalarda özellikle kritik öneme sahiptir.

Bu zafiyetin gerçek dünya örnekleri, çeşitli **CTF yarışmaları** ve **hacking platformları** üzerinde belgelenmiştir ve pratik etkilerini vurgulamaktadır. Sorun, saldırganların bildirimleri veya ödemeleri kendi hesaplarına yönlendirebileceği **Slack**, **Stripe** ve **PayPal** gibi üçüncü taraf hizmetlerle entegrasyonlara da uzanmaktadır.

**`state` parametresinin** doğru yönetimi ve doğrulanması, CSRF'ye karşı korunmak ve OAuth akışını güvence altına almak için kritik öneme sahiptir.

### Hesap Ele Geçirmeden Önce <a href="#ebe4" id="ebe4"></a>

1. **Hesap Oluşturma sırasında E-posta Doğrulaması Olmadan**: Saldırganlar, mağdurun e-posta adresini kullanarak önceden bir hesap oluşturabilir. Eğer mağdur daha sonra bir üçüncü taraf hizmeti ile giriş yaparsa, uygulama bu üçüncü taraf hesabını saldırganın önceden oluşturduğu hesapla yanlışlıkla ilişkilendirebilir ve yetkisiz erişime yol açabilir.
2. **Gevşek OAuth E-posta Doğrulamasını Kötüye Kullanma**: Saldırganlar, e-postaları doğrulamayan OAuth hizmetlerini kötüye kullanarak kendi hizmetleriyle kaydolabilir ve ardından hesap e-posta adresini mağdurunki ile değiştirebilir. Bu yöntem, ilk senaryoya benzer şekilde yetkisiz hesap erişimi riski taşır, ancak farklı bir saldırı vektörü aracılığıyla gerçekleşir.

### Gizli Bilgilerin Açığa Çıkması <a href="#e177" id="e177"></a>

Gizli OAuth parametrelerini tanımlamak ve korumak çok önemlidir. **`client_id`** güvenle ifşa edilebilirken, **`client_secret`** ifşa edilmesi önemli riskler taşır. Eğer `client_secret` ele geçirilirse, saldırganlar uygulamanın kimliğini ve güvenini kötüye kullanarak **kullanıcı `access_tokens`** ve özel bilgileri çalabilir.

Uygulamaların yetkilendirme `code`'unu `access_token` ile istemci tarafında değil, sunucu tarafında yanlışlıkla yönetmesi durumunda yaygın bir zafiyet ortaya çıkar. Bu hata, `client_secret`'in açığa çıkmasına yol açar ve saldırganların uygulamanın kimliğini kullanarak `access_tokens` oluşturmasına olanak tanır. Ayrıca, sosyal mühendislik yoluyla, saldırganlar OAuth yetkilendirmesine ek kapsamlar ekleyerek ayrıcalıkları artırabilir ve uygulamanın güvenilir durumunu daha da kötüye kullanabilir.

### Client Secret Bruteforce

Bir hizmet sağlayıcının client\_secret'ini çalmak için kimlik sağlayıcı ile **bruteforce** yapmayı deneyebilirsiniz.\
BF isteği şu şekilde görünebilir:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Müşteri **kod ve durum** bilgilerine sahip olduğunda, eğer bu bilgiler **Referer başlığında yansıtılıyorsa** ve farklı bir sayfaya gittiğinde, o zaman bu açık durumdadır.

### Tarayıcı Geçmişinde Saklanan Erişim Token'ı

**Tarayıcı geçmişine gidin ve erişim token'ının orada kaydedilip kaydedilmediğini kontrol edin.**

### Süresiz Yetkilendirme Kodu

**Yetkilendirme kodu, bir saldırganın onu çalabileceği ve kullanabileceği zaman penceresini sınırlamak için sadece bir süre boyunca geçerli olmalıdır.**

### Yetkilendirme/Yenileme Token'ı istemciye bağlı değil

Eğer **yetkilendirme kodunu alabilir ve bunu farklı bir istemci ile kullanabilirseniz, diğer hesapları ele geçirebilirsiniz.**

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Bu gönderiyi kontrol edin**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Bu hata ödül raporunda: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) **AWS Cognito** tarafından kullanıcıya geri verilen **token'ın** **kullanıcı verilerini üzerine yazmak için yeterli izinlere sahip olabileceğini** görebilirsiniz. Bu nedenle, eğer **bir kullanıcı e-posta adresini farklı bir kullanıcı e-posta adresi ile değiştirebilirseniz**, diğer hesapları **ele geçirebilirsiniz.**
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
For more detailed info about how to abuse AWS cognito check:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abusing other Apps tokens <a href="#bda5" id="bda5"></a>

[**Bu yazıda bahsedildiği gibi**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), **token** (ve kod değil) almayı bekleyen OAuth akışları, token'ın uygulamaya ait olduğunu kontrol etmedikleri takdirde savunmasız olabilir.

Bu, bir **saldırganın** kendi uygulamasında **OAuth destekleyen ve Facebook ile giriş yapan bir uygulama** oluşturabileceği anlamına gelir. Daha sonra, bir kurban **saldırganın uygulamasında** Facebook ile giriş yaptığında, saldırgan **kullanıcının uygulamasına verilen OAuth token'ını alabilir ve bunu kurbanın OAuth uygulamasında kurbanın kullanıcı token'ı ile giriş yapmak için kullanabilir**.

{% hint style="danger" %}
Bu nedenle, eğer saldırgan kullanıcıyı kendi OAuth uygulamasına eriştirmeyi başarırsa, token bekleyen ve token'ın kendi uygulama kimliğine verilip verilmediğini kontrol etmeyen uygulamalarda kurbanın hesabını ele geçirebilir.
{% endhint %}

### Two links & cookie <a href="#bda5" id="bda5"></a>

[**Bu yazıya göre**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), bir kurbanın saldırganın ana bilgisayarına işaret eden bir **returnUrl** ile bir sayfa açması sağlanabiliyordu. Bu bilgi **bir çerezde (RU)** saklanacak ve **sonraki adımda** **istem** **kullanıcıya** o saldırganın ana bilgisayarına erişim vermek isteyip istemediğini **soracaktır**.

Bu istemi atlatmak için, **returnUrl** kullanarak bu RU çerezini ayarlayacak bir **Oauth akışını** başlatmak için bir sekme açmak, istem gösterilmeden önce sekmeyi kapatmak ve o değeri içermeyen yeni bir sekme açmak mümkündü. Böylece, **istem saldırganın ana bilgisayarı hakkında bilgi vermeyecek**, ancak çerez ona ayarlanacak, bu nedenle **token saldırganın ana bilgisayarına** yönlendirme sırasında gönderilecektir.

### Prompt Interaction Bypass <a href="#bda5" id="bda5"></a>

[**Bu videoda açıklandığı gibi**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), bazı OAuth uygulamaları, kullanıcıların platformda zaten oturum açmışlarsa webde verilen erişimi onaylamaları için **`prompt`** GET parametresini None (**`&prompt=none`**) olarak belirtmelerine izin verir.

### response\_mode

[**Bu videoda açıklandığı gibi**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), kodun son URL'de nerede sağlanacağını belirtmek için **`response_mode`** parametresini belirtmek mümkün olabilir:

* `response_mode=query` -> Kod bir GET parametresi içinde sağlanır: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Kod URL parçası parametresi içinde sağlanır `#code=2397rf3gu93f`
* `response_mode=form_post` -> Kod, `code` adında bir girdi ile bir POST formu içinde sağlanır ve değer
* `response_mode=web_message` -> Kod bir post mesajında gönderilir: `window.opener.postMessage({"code": "asdasdasd...`

### OAuth ROPC flow - 2 FA bypass <a href="#b440" id="b440"></a>

[**Bu blog yazısına göre**](https://cybxis.medium.com/a-bypass-on-gitlabs-login-email-verification-via-oauth-ropc-flow-e194242cad96), bu, OAuth üzerinden **kullanıcı adı** ve **şifre** ile giriş yapmayı sağlayan bir OAuth akışıdır. Bu basit akış sırasında, kullanıcının gerçekleştirebileceği tüm eylemlere erişim sağlayan bir **token** dönerse, bu token kullanılarak 2FA atlatılabilir.

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Bu araştırmayı kontrol edin**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Bu tekniğin daha fazla ayrıntısı için.**

OAuth'taki Dinamik İstemci Kaydı, güvenlik açıkları için daha az belirgin ama kritik bir vektör olarak hizmet eder, özellikle **Sunucu Tarafı İstek Sahteciliği (SSRF)** saldırıları için. Bu uç nokta, OAuth sunucularının istemci uygulamaları hakkında, kötüye kullanılabilecek hassas URL'ler de dahil olmak üzere ayrıntılar almasına olanak tanır.

**Ana Noktalar:**

* **Dinamik İstemci Kaydı** genellikle `/register` ile eşleştirilir ve `client_name`, `client_secret`, `redirect_uris` ve logo veya JSON Web Key Sets (JWK'ler) için URL'ler gibi ayrıntıları POST istekleri aracılığıyla kabul eder.
* Bu özellik, **RFC7591** ve **OpenID Connect Registration 1.0**'da belirtilen spesifikasyonlara uyar; bu, SSRF'ye karşı potansiyel olarak savunmasız parametreleri içerir.
* Kayıt süreci, istemcileri birkaç şekilde SSRF'ye maruz bırakabilir:
* **`logo_uri`**: Sunucu tarafından alınabilecek istemci uygulamasının logosu için bir URL; bu, SSRF'yi tetikleyebilir veya URL yanlış yönetilirse XSS'ye yol açabilir.
* **`jwks_uri`**: İstemcinin JWK belgesine giden bir URL; kötü niyetle oluşturulursa, sunucunun saldırgan kontrolündeki bir sunucuya dışa dönük istekler yapmasına neden olabilir.
* **`sector_identifier_uri`**: Sunucunun alabileceği `redirect_uris` JSON dizisini referans alır ve bu, SSRF fırsatı yaratır.
* **`request_uris`**: İstemci için izin verilen istek URI'lerini listeler; bu, sunucu bu URI'leri yetkilendirme sürecinin başında alırsa kötüye kullanılabilir.

**Kötüye Kullanım Stratejisi:**

* SSRF, `logo_uri`, `jwks_uri` veya `sector_identifier_uri` gibi parametrelerde kötü niyetli URL'lerle yeni bir istemci kaydederek tetiklenebilir.
* `request_uris` aracılığıyla doğrudan kötüye kullanım, beyaz liste kontrolleri ile azaltılabilirken, önceden kaydedilmiş, saldırgan kontrolündeki bir `request_uri` sağlamak, yetkilendirme aşamasında SSRF'yi kolaylaştırabilir.

## OAuth providers Race Conditions

Test ettiğiniz platform bir OAuth sağlayıcısıysa [**Olası Yarış Koşullarını test etmek için bunu okuyun**](race-condition.md).

## References

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../.gitbook/assets/arte.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
