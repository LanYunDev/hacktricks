<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>XS-Search/XS-Leaks</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="xs-searchxs-leaks"><a class="header" href="#xs-searchxs-leaks">XS-Search/XS-Leaks</a></h1>
<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p>使用 <a href="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=text&amp;utm_campaign=ppc&amp;utm_content=xs-search">****</a> 轻松构建和 <strong>自动化工作流程</strong>，由世界上 <strong>最先进</strong> 的社区工具提供支持。<br />
立即获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=xs-search" %}</p>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术： <img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>在 Twitter 上关注</strong> 我们 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="基本信息"><a class="header" href="#基本信息">基本信息</a></h2>
<p>XS-Search 是一种通过利用 <strong>侧信道漏洞</strong> 来 <strong>提取跨源信息</strong> 的方法。</p>
<p>此攻击涉及的关键组件包括：</p>
<ul>
<li><strong>易受攻击的网页</strong>：目标网站，信息旨在从中提取。</li>
<li><strong>攻击者的网页</strong>：攻击者创建的恶意网站，受害者访问，托管漏洞利用。</li>
<li><strong>包含方法</strong>：用于将易受攻击的网页纳入攻击者网页的技术（例如，window.open、iframe、fetch、带 href 的 HTML 标签等）。</li>
<li><strong>泄露技术</strong>：用于根据通过包含方法收集的信息来辨别易受攻击网页状态差异的技术。</li>
<li><strong>状态</strong>：易受攻击网页的两种潜在条件，攻击者旨在区分。</li>
<li><strong>可检测差异</strong>：攻击者依赖于可观察的变化来推断易受攻击网页的状态。</li>
</ul>
<h3 id="可检测差异"><a class="header" href="#可检测差异">可检测差异</a></h3>
<p>可以分析多个方面以区分易受攻击网页的状态：</p>
<ul>
<li><strong>状态码</strong>：区分 <strong>各种 HTTP 响应状态码</strong> 跨源，如服务器错误、客户端错误或身份验证错误。</li>
<li><strong>API 使用</strong>：识别跨页面的 <strong>Web API 使用</strong>，揭示跨源页面是否使用特定的 JavaScript Web API。</li>
<li><strong>重定向</strong>：检测导航到不同页面，不仅是 HTTP 重定向，还有由 JavaScript 或 HTML 触发的重定向。</li>
<li><strong>页面内容</strong>：观察 <strong>HTTP 响应体中的变化</strong> 或页面子资源中的变化，例如 <strong>嵌入框的数量</strong> 或图像的大小差异。</li>
<li><strong>HTTP 头</strong>：注意 <strong>特定 HTTP 响应头</strong> 的存在或可能的值，包括 X-Frame-Options、Content-Disposition 和 Cross-Origin-Resource-Policy 等头。</li>
<li><strong>时间</strong>：注意两个状态之间的一致时间差异。</li>
</ul>
<h3 id="包含方法"><a class="header" href="#包含方法">包含方法</a></h3>
<ul>
<li><strong>HTML 元素</strong>：HTML 提供多种元素用于 <strong>跨源资源包含</strong>，如样式表、图像或脚本，迫使浏览器请求非 HTML 资源。可以在 <a href="https://github.com/cure53/HTTPLeaks">https://github.com/cure53/HTTPLeaks</a> 找到用于此目的的潜在 HTML 元素的汇编。</li>
<li><strong>框架</strong>：如 <strong>iframe</strong>、<strong>object</strong> 和 <strong>embed</strong> 的元素可以将 HTML 资源直接嵌入攻击者的页面。如果页面 <strong>缺乏框架保护</strong>，JavaScript 可以通过 contentWindow 属性访问框架资源的窗口对象。</li>
<li><strong>弹出窗口</strong>：<strong><code>window.open</code></strong> 方法在新标签页或窗口中打开资源，为 JavaScript 提供 <strong>窗口句柄</strong>，以便与遵循 SOP 的方法和属性进行交互。弹出窗口通常用于单点登录，绕过目标资源的框架和 cookie 限制。然而，现代浏览器将弹出窗口的创建限制为某些用户操作。</li>
<li><strong>JavaScript 请求</strong>：JavaScript 允许使用 <strong>XMLHttpRequests</strong> 或 <strong>Fetch API</strong> 直接请求目标资源。这些方法提供对请求的精确控制，例如选择跟随 HTTP 重定向。</li>
</ul>
<h3 id="泄露技术"><a class="header" href="#泄露技术">泄露技术</a></h3>
<ul>
<li><strong>事件处理程序</strong>：XS-Leaks 中的一种经典泄露技术，其中事件处理程序如 <strong>onload</strong> 和 <strong>onerror</strong> 提供有关资源加载成功或失败的见解。</li>
<li><strong>错误消息</strong>：JavaScript 异常或特殊错误页面可以直接从错误消息或通过区分其存在与否提供泄露信息。</li>
<li><strong>全局限制</strong>：浏览器的物理限制，如内存容量或其他强制的浏览器限制，可以在达到阈值时发出信号，作为泄露技术。</li>
<li><strong>全局状态</strong>：可检测与浏览器 <strong>全局状态</strong>（例如，历史接口）的交互可以被利用。例如，浏览器历史中的 <strong>条目数量</strong> 可以提供有关跨源页面的线索。</li>
<li><strong>性能 API</strong>：此 API 提供 <strong>当前页面的性能细节</strong>，包括文档和加载资源的网络时间，能够推断请求的资源。</li>
<li><strong>可读属性</strong>：某些 HTML 属性是 <strong>跨源可读</strong> 的，可以用作泄露技术。例如，<code>window.frame.length</code> 属性允许 JavaScript 计算跨源网页中包含的框架数量。</li>
</ul>
<h2 id="xsinator-工具与论文"><a class="header" href="#xsinator-工具与论文">XSinator 工具与论文</a></h2>
<p>XSinator 是一个自动化工具，用于 <strong>检查浏览器是否存在多种已知的 XS-Leaks</strong>，详见其论文：<a href="https://xsinator.com/paper.pdf"><strong>https://xsinator.com/paper.pdf</strong></a></p>
<p>您可以 <strong>访问该工具</strong> <a href="https://xsinator.com/"><strong>https://xsinator.com/</strong></a></p>
<p>{% hint style="warning" %}
<strong>排除的 XS-Leaks</strong>：我们不得不排除依赖 <strong>服务工作者</strong> 的 XS-Leaks，因为它们会干扰 XSinator 中的其他泄露。此外，我们选择 <strong>排除依赖特定 Web 应用程序中的错误配置和漏洞的 XS-Leaks</strong>。例如，跨源资源共享（CORS）错误配置、postMessage 泄露或跨站脚本。此外，我们还排除了基于时间的 XS-Leaks，因为它们通常存在缓慢、嘈杂和不准确的问题。
{% endhint %}</p>
<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p><br />
使用 <a href="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=text&amp;utm_campaign=ppc&amp;utm_content=xs-search"><strong>Trickest</strong></a> 轻松构建和 <strong>自动化工作流程</strong>，由世界上 <strong>最先进</strong> 的社区工具提供支持。<br />
立即获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=xs-search" %}</p>
<h2 id="基于时间的技术"><a class="header" href="#基于时间的技术"><strong>基于时间的技术</strong></a></h2>
<p>以下一些技术将使用时间作为检测网页可能状态差异的过程的一部分。测量时间在网页浏览器中有不同的方法。</p>
<p><strong>时钟</strong>： <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">performance.now()</a> API 允许开发人员获取高分辨率的时间测量。<br />
攻击者可以滥用大量 API 来创建隐式时钟：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API">Broadcast Channel API</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel">Message Channel API</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">requestAnimationFrame</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">setTimeout</a>、CSS 动画等。<br />
更多信息请参见：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/">https://xsleaks.dev/docs/attacks/timing-attacks/clocks</a>。</p>
<h2 id="事件处理程序技术"><a class="header" href="#事件处理程序技术">事件处理程序技术</a></h2>
<h3 id="onloadonerror"><a class="header" href="#onloadonerror">Onload/Onerror</a></h3>
<ul>
<li><strong>包含方法</strong>：框架，HTML 元素</li>
<li><strong>可检测差异</strong>：状态码</li>
<li><strong>更多信息</strong>：<a href="https://www.usenix.org/conference/usenixsecurity19/presentation/staicu">https://www.usenix.org/conference/usenixsecurity19/presentation/staicu</a>，<a href="https://xsleaks.dev/docs/attacks/error-events/">https://xsleaks.dev/docs/attacks/error-events/</a></li>
<li><strong>总结</strong>：如果尝试加载资源，onerror/onload 事件在资源成功/失败加载时被触发，可以推断出状态码。</li>
<li><strong>代码示例</strong>：<a href="https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)">https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)</a></li>
</ul>
<p>{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
<a href="cookie-bomb-+-onerror-xs-leak.html">cookie-bomb-+-onerror-xs-leak.md</a>
{% endcontent-ref %}</p>
<p>代码示例尝试 <strong>从 JS 加载脚本对象</strong>，但 <strong>其他标签</strong> 如对象、样式表、图像、音频也可以使用。此外，还可以直接注入 <strong>标签</strong> 并在标签内声明 <code>onload</code> 和 <code>onerror</code> 事件（而不是从 JS 注入）。</p>
<p>此攻击还有一个无脚本版本：</p>
<pre><code class="language-html">&lt;object data="//example.com/404"&gt;
&lt;object data="//attacker.com/?error"&gt;&lt;/object&gt;
&lt;/object&gt;
</code></pre>
<p>在这种情况下，如果 <code>example.com/404</code> 未找到，将加载 <code>attacker.com/?error</code>。</p>
<h3 id="加载时机"><a class="header" href="#加载时机">加载时机</a></h3>
<ul>
<li><strong>包含方法</strong>：HTML 元素</li>
<li><strong>可检测差异</strong>：时机（通常由于页面内容、状态码）</li>
<li><strong>更多信息</strong>：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events</a></li>
<li><strong>总结：</strong> <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow"><strong>performance.now()</strong></a> <strong>API</strong> 可用于测量执行请求所需的时间。然而，也可以使用其他时钟，例如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming"><strong>PerformanceLongTaskTiming API</strong></a>，它可以识别运行超过 50 毫秒的任务。</li>
<li><strong>代码示例</strong>：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events</a> 另一个示例在：</li>
</ul>
<p>{% content-ref url="performance.now-example.md" %}
<a href="performance.now-example.html">performance.now-example.md</a>
{% endcontent-ref %}</p>
<h4 id="加载时机--强制重任务"><a class="header" href="#加载时机--强制重任务">加载时机 + 强制重任务</a></h4>
<p>此技术与前一种相似，但 <strong>攻击者</strong> 还将 <strong>强制</strong> 一些操作以花费 <strong>相关的时间</strong>，无论 <strong>答案是正面还是负面</strong>，并测量该时间。</p>
<p>{% content-ref url="performance.now-+-force-heavy-task.md" %}
<a href="performance.now-+-force-heavy-task.html">performance.now-+-force-heavy-task.md</a>
{% endcontent-ref %}</p>
<h3 id="卸载卸载前时机"><a class="header" href="#卸载卸载前时机">卸载/卸载前时机</a></h3>
<ul>
<li><strong>包含方法</strong>：框架</li>
<li><strong>可检测差异</strong>：时机（通常由于页面内容、状态码）</li>
<li><strong>更多信息</strong>：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events</a></li>
<li><strong>总结：</strong> <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers">SharedArrayBuffer 时钟</a> 可用于测量执行请求所需的时间。也可以使用其他时钟。</li>
<li><strong>代码示例</strong>：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events</a></li>
</ul>
<p>获取资源所需的时间可以通过利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event"><code>unload</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event"><code>beforeunload</code></a> 事件来测量。<strong><code>beforeunload</code></strong> 事件在浏览器即将导航到新页面时触发，而 <strong><code>unload</code></strong> 事件在实际进行导航时发生。这两个事件之间的时间差可以计算出 <strong>浏览器获取资源所花费的时间</strong>。</p>
<h3 id="沙箱框架时机--加载"><a class="header" href="#沙箱框架时机--加载">沙箱框架时机 + 加载 <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a></a></h3>
<ul>
<li><strong>包含方法</strong>：框架</li>
<li><strong>可检测差异</strong>：时机（通常由于页面内容、状态码）</li>
<li><strong>更多信息</strong>：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks</a></li>
<li><strong>总结：</strong> <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow">performance.now()</a> API 可用于测量执行请求所需的时间。也可以使用其他时钟。</li>
<li><strong>代码示例</strong>：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks</a></li>
</ul>
<p>已观察到，在没有 <a href="https://xsleaks.dev/docs/defenses/opt-in/xfo/">框架保护</a> 的情况下，攻击者可以测量页面及其子资源在网络上加载所需的时间。此测量通常是可能的，因为 iframe 的 <code>onload</code> 处理程序仅在资源加载和 JavaScript 执行完成后触发。为了绕过脚本执行引入的可变性，攻击者可能会在 <code>&lt;iframe&gt;</code> 中使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe"><code>sandbox</code></a> 属性。包含此属性会限制许多功能，特别是 JavaScript 的执行，从而促进主要受网络性能影响的测量。</p>
<pre><code class="language-javascript">// Example of an iframe with the sandbox attribute
&lt;iframe src="example.html" sandbox&gt;&lt;/iframe&gt;
</code></pre>
<h3 id="id--error--onload"><a class="header" href="#id--error--onload">#ID + error + onload</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 页面内容</li>
<li><strong>More info</strong>:</li>
<li><strong>Summary</strong>: 如果您可以在访问正确内容时使页面出错，并在访问任何内容时使其正确加载，那么您可以创建一个循环来提取所有信息，而无需测量时间。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>假设您可以<strong>插入</strong>包含<strong>秘密</strong>内容的<strong>页面****在一个 Iframe</strong> 中。</p>
<p>您可以<strong>让受害者搜索</strong>包含“<em><strong>flag</strong></em>”的文件，使用<strong>Iframe</strong>（例如，利用 CSRF）。在 Iframe 内，您知道 <em><strong>onload 事件</strong></em> 将<strong>至少执行一次</strong>。然后，您可以<strong>更改</strong> <strong>iframe</strong> 的 <strong>URL</strong>，但仅更改 <strong>URL</strong> 中 <strong>hash</strong> 的 <strong>内容</strong>。</p>
<p>例如：</p>
<ol>
<li><strong>URL1</strong>: www.attacker.com/xssearch#try1</li>
<li><strong>URL2</strong>: www.attacker.com/xssearch#try2</li>
</ol>
<p>如果第一个 URL <strong>成功加载</strong>，那么，当<strong>更改</strong> URL 的 <strong>hash</strong> 部分时，<strong>onload</strong> 事件<strong>不会再次触发</strong>。但是<strong>如果</strong>页面在<strong>加载</strong>时出现某种<strong>错误</strong>，那么，<strong>onload</strong> 事件将<strong>再次触发</strong>。</p>
<p>然后，您可以<strong>区分</strong>一个<strong>正确</strong>加载的页面或访问时有<strong>错误</strong>的页面。</p>
<h3 id="javascript-execution"><a class="header" href="#javascript-execution">Javascript Execution</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 页面内容</li>
<li><strong>More info</strong>:</li>
<li><strong>Summary:</strong> 如果<strong>页面</strong>返回<strong>敏感</strong>内容，<strong>或</strong>用户可以<strong>控制</strong>的<strong>内容</strong>。用户可以在<strong>负面情况下</strong>设置<strong>有效的 JS 代码</strong>，并在每次尝试中使用**<code>&lt;script&gt;</code>** 标签加载，因此在<strong>负面</strong>情况下攻击者的<strong>代码</strong>会被<strong>执行</strong>，而在<strong>肯定</strong>情况下<strong>什么</strong>都不会被执行。</li>
<li><strong>Code Example:</strong></li>
</ul>
<p>{% content-ref url="javascript-execution-xs-leak.md" %}
<a href="javascript-execution-xs-leak.html">javascript-execution-xs-leak.md</a>
{% endcontent-ref %}</p>
<h3 id="corb---onerror"><a class="header" href="#corb---onerror">CORB - Onerror</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements</li>
<li><strong>Detectable Difference</strong>: 状态码 &amp; 头部</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/browser-features/corb/">https://xsleaks.dev/docs/attacks/browser-features/corb/</a></li>
<li><strong>Summary</strong>: <strong>跨源读取阻止 (CORB)</strong> 是一种安全措施，防止网页加载某些敏感的跨源资源，以保护免受<strong>Spectre</strong>等攻击。然而，攻击者可以利用其保护行为。当受<strong>CORB</strong>保护的响应返回带有 <code>nosniff</code> 的 <em><strong>CORB 保护</strong></em> <code>Content-Type</code> 和 <code>2xx</code> 状态码时，<strong>CORB</strong> 会剥离响应的主体和头部。观察到这一点的攻击者可以推断出<strong>状态码</strong>（指示成功或错误）和 <code>Content-Type</code>（表示是否受<strong>CORB</strong>保护）的组合，从而导致潜在的信息泄露。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>查看更多信息链接以获取有关攻击的更多信息。</p>
<h3 id="onblur"><a class="header" href="#onblur">onblur</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 页面内容</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/id-attribute/">https://xsleaks.dev/docs/attacks/id-attribute/</a>, <a href="https://xsleaks.dev/docs/attacks/experiments/portals/">https://xsleaks.dev/docs/attacks/experiments/portals/</a></li>
<li><strong>Summary</strong>: 从 id 或 name 属性泄露敏感数据。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet">https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet</a></li>
</ul>
<p>可以<strong>在一个 iframe</strong> 中<strong>加载一个页面</strong>并使用 <strong><code>#id_value</code></strong> 使页面<strong>聚焦于</strong>指定的 iframe 元素，然后如果触发了**<code>onblur</code>** 信号，则 ID 元素存在。<br />
您可以使用 <strong><code>portal</code></strong> 标签执行相同的攻击。</p>
<h3 id="postmessage-broadcasts"><a class="header" href="#postmessage-broadcasts">postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames, Pop-ups</li>
<li><strong>Detectable Difference</strong>: API 使用</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/postmessage-broadcasts/">https://xsleaks.dev/docs/attacks/postmessage-broadcasts/</a></li>
<li><strong>Summary</strong>: 从 postMessage 收集敏感信息或使用 postMessages 的存在作为 oracle 来了解用户在页面上的状态</li>
<li><strong>Code Example</strong>: <code>任何监听所有 postMessages 的代码。</code></li>
</ul>
<p>应用程序经常利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage"><code>postMessage</code> 广播</a> 在不同源之间进行通信。然而，如果 <code>targetOrigin</code> 参数未正确指定，这种方法可能会无意中暴露<strong>敏感信息</strong>，允许任何窗口接收消息。此外，接收消息的行为本身可以充当<strong>oracle</strong>；例如，某些消息可能仅发送给已登录的用户。因此，这些消息的存在或缺失可以揭示有关用户状态或身份的信息，例如他们是否经过身份验证。</p>
<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p>使用 <a href="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=text&amp;utm_campaign=ppc&amp;utm_content=xs-search"><strong>Trickest</strong></a> 轻松构建和<strong>自动化工作流</strong>，由世界上<strong>最先进</strong>的社区工具提供支持。<br />
立即获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=xs-search" %}</p>
<h2 id="global-limits-techniques"><a class="header" href="#global-limits-techniques">Global Limits Techniques</a></h2>
<h3 id="websocket-api"><a class="header" href="#websocket-api">WebSocket API</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames, Pop-ups</li>
<li><strong>Detectable Difference</strong>: API 使用</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.1)</li>
<li><strong>Summary</strong>: 耗尽 WebSocket 连接限制泄露跨源页面的 WebSocket 连接数量。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)">https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)</a>, <a href="https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)">https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)</a></li>
</ul>
<p>可以识别目标页面使用的<strong>WebSocket 连接</strong>的数量。这使攻击者能够检测应用程序状态并泄露与 WebSocket 连接数量相关的信息。</p>
<p>如果一个<strong>源</strong>使用<strong>最大数量的 WebSocket</strong> 连接对象，无论其连接状态如何，创建<strong>新对象将导致 JavaScript 异常</strong>。要执行此攻击，攻击者网站在弹出窗口或 iframe 中打开目标网站，然后在目标网页加载后，尝试创建尽可能多的 WebSocket 连接。<strong>抛出的异常数量</strong>就是目标网站窗口使用的<strong>WebSocket 连接数量</strong>。</p>
<h3 id="payment-api"><a class="header" href="#payment-api">Payment API</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames, Pop-ups</li>
<li><strong>Detectable Difference</strong>: API 使用</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.1)</li>
<li><strong>Summary</strong>: 检测支付请求，因为一次只能激活一个。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Payment%20API%20Leak">https://xsinator.com/testing.html#Payment%20API%20Leak</a></li>
</ul>
<p>此 XS-Leak 使攻击者能够<strong>检测跨源页面何时发起支付请求</strong>。</p>
<p>因为<strong>一次只能激活一个支付请求</strong>，如果目标网站使用支付请求 API，任何进一步尝试使用此 API 的请求将失败，并导致<strong>JavaScript 异常</strong>。攻击者可以通过<strong>定期尝试显示支付 API UI</strong>来利用这一点。如果一次尝试导致异常，则目标网站当前正在使用它。攻击者可以通过在创建后立即关闭 UI 来隐藏这些定期尝试。</p>
<h3 id="timing-the-event-loop"><a class="header" href="#timing-the-event-loop">Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>:</li>
<li><strong>Detectable Difference</strong>: 时间（通常由于页面内容、状态码）</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop">https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop</a></li>
<li><strong>Summary:</strong> 测量滥用单线程 JS 事件循环的网页执行时间。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
<a href="event-loop-blocking-+-lazy-images.html">event-loop-blocking-+-lazy-images.md</a>
{% endcontent-ref %}</p>
<p>JavaScript 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">单线程事件循环</a> 并发模型上运行，这意味着<strong>它一次只能执行一个任务</strong>。这一特性可以被利用来评估<strong>来自不同源的代码执行所需的时间</strong>。攻击者可以通过不断调度具有固定属性的事件来测量其代码在事件循环中的执行时间。这些事件将在事件池为空时被处理。如果其他源也在向同一池调度事件，攻击者可以通过观察自己任务执行的延迟来推断这些外部事件执行所需的时间。这种监控事件循环延迟的方法可以揭示来自不同源的代码的执行时间，可能会暴露敏感信息。</p>
<p>{% hint style="warning" %}
在执行时间中，可以<strong>消除</strong> <strong>网络因素</strong>以获得<strong>更精确的测量</strong>。例如，通过在加载页面之前加载页面使用的资源。
{% endhint %}</p>
<h3 id="busy-event-loop"><a class="header" href="#busy-event-loop">Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>:</li>
<li><strong>Detectable Difference</strong>: 时间（通常由于页面内容、状态码）</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop">https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop</a></li>
<li><strong>Summary:</strong> 一种测量网页操作执行时间的方法是故意阻塞线程的事件循环，然后计时<strong>事件循环再次可用所需的时间</strong>。通过在事件循环中插入阻塞操作（例如长时间计算或同步 API 调用），并监控后续代码开始执行所需的时间，可以推断出在阻塞期间事件循环中执行的任务的持续时间。这种技术利用了 JavaScript 事件循环的单线程特性，其中任务是顺序执行的，并且可以提供有关共享同一线程的其他操作的性能或行为的见解。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>通过锁定事件循环来测量执行时间的技术的一个显著优势是其潜在的绕过<strong>站点隔离</strong>。<strong>站点隔离</strong>是一种安全功能，将不同网站分隔到不同的进程中，旨在防止恶意网站直接访问其他网站的敏感数据。然而，通过通过共享事件循环影响另一个源的执行时间，攻击者可以间接提取有关该源活动的信息。这种方法不依赖于直接访问其他源的数据，而是观察该源活动对共享事件循环的影响，从而规避<strong>站点隔离</strong>建立的保护屏障。</p>
<p>{% hint style="warning" %}
在执行时间中，可以<strong>消除</strong> <strong>网络因素</strong>以获得<strong>更精确的测量</strong>。例如，通过在加载页面之前加载页面使用的资源。
{% endhint %}</p>
<h3 id="connection-pool"><a class="header" href="#connection-pool">Connection Pool</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: JavaScript Requests</li>
<li><strong>Detectable Difference</strong>: 时间（通常由于页面内容、状态码）</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/">https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</a></li>
<li><strong>Summary:</strong> 攻击者可以锁定除 1 个以外的所有套接字，加载目标网页，同时加载另一个页面，最后一个页面开始加载的时间就是目标页面加载所需的时间。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>{% content-ref url="connection-pool-example.md" %}
<a href="connection-pool-example.html">connection-pool-example.md</a>
{% endcontent-ref %}</p>
<p>浏览器利用套接字进行服务器通信，但由于操作系统和硬件的资源有限，<strong>浏览器被迫施加限制</strong>，限制并发套接字的数量。攻击者可以通过以下步骤利用这一限制：</p>
<ol>
<li>确定浏览器的套接字限制，例如，256 个全局套接字。</li>
<li>通过向不同主机发起 255 个请求，长时间占用 255 个套接字，旨在保持连接开放而不完成。</li>
<li>使用第 256 个套接字向目标页面发送请求。</li>
<li>尝试向不同主机发起第 257 个请求。由于所有套接字都在使用中（根据步骤 2 和 3），此请求将被排队，直到有套接字可用。此请求进行之前的延迟为攻击者提供了与第 256 个套接字（目标页面的套接字）相关的网络活动的时间信息。这种推断是可能的，因为步骤 2 中的 255 个套接字仍在使用，这意味着任何新可用的套接字必须是从步骤 3 中释放的。第 256 个套接字变为可用所需的时间因此直接与请求完成所需的时间相关联。</li>
</ol>
<p>有关更多信息：<a href="https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/">https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/</a></p>
<h3 id="connection-pool-by-destination"><a class="header" href="#connection-pool-by-destination">Connection Pool by Destination</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: JavaScript Requests</li>
<li><strong>Detectable Difference</strong>: 时间（通常由于页面内容、状态码）</li>
<li><strong>More info</strong>:</li>
<li><strong>Summary:</strong> 这与前一种技术类似，但 Google <strong>Chrome</strong> 对<strong>同一源的并发请求</strong>限制为<strong>6 个</strong>。如果我们<strong>阻塞 5 个</strong>，然后<strong>发起第 6 个</strong>请求，我们可以<strong>计时</strong>，如果我们成功让<strong>受害者页面发送</strong>更多<strong>请求</strong>到同一端点以检测页面的<strong>状态</strong>，第 <strong>6 个请求</strong>将需要<strong>更长时间</strong>，我们可以检测到。</li>
</ul>
<h2 id="performance-api-techniques"><a class="header" href="#performance-api-techniques">Performance API Techniques</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance"><code>Performance API</code></a> 提供了有关 Web 应用程序性能指标的见解，进一步通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API"><code>Resource Timing API</code></a> 得到丰富。当服务器在其响应中包含 <code>Timing-Allow-Origin: *</code> 头时，Resource Timing API 使得监控详细的网络请求时长成为可能，例如请求的持续时间。</p>
<p>这些丰富的数据可以通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries"><code>performance.getEntries</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName"><code>performance.getEntriesByName</code></a> 等方法检索，提供全面的性能相关信息。此外，该 API 通过计算从 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code></a> 获取的时间戳之间的差异来测量执行时间。然而，值得注意的是，对于 Chrome 等浏览器中的某些操作，<code>performance.now()</code> 的精度可能仅限于毫秒，这可能会影响时间测量的粒度。</p>
<p>除了时间测量外，Performance API 还可以用于安全相关的见解。例如，Chrome 中 <code>performance</code> 对象中页面的存在或缺失可以指示 <code>X-Frame-Options</code> 的应用。具体来说，如果由于 <code>X-Frame-Options</code> 而阻止页面在框架中呈现，则不会在 <code>performance</code> 对象中记录该页面，从而提供有关页面框架策略的微妙线索。</p>
<h3 id="error-leak"><a class="header" href="#error-leak">Error Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames, HTML Elements</li>
<li><strong>Detectable Difference</strong>: 状态码</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 结果为错误的请求不会创建资源时间条目。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20Error%20Leak">https://xsinator.com/testing.html#Performance%20API%20Error%20Leak</a></li>
</ul>
<p>可以<strong>区分 HTTP 响应状态码</strong>，因为导致<strong>错误</strong>的请求<strong>不会创建性能条目</strong>。</p>
<h3 id="style-reload-error"><a class="header" href="#style-reload-error">Style Reload Error</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements</li>
<li><strong>Detectable Difference</strong>: 状态码</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 由于浏览器错误，导致错误的请求被加载两次。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak">https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak</a></li>
</ul>
<p>在前一种技术中，还识别出浏览器 GC 中的两个案例，导致<strong>资源在加载失败时被加载两次</strong>。这将导致 Performance API 中出现多个条目，因此可以被检测到。</p>
<h3 id="request-merging-error"><a class="header" href="#request-merging-error">Request Merging Error</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements</li>
<li><strong>Detectable Difference</strong>: 状态码</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 导致错误的请求无法合并。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak">https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak</a></li>
</ul>
<p>该技术在提到的论文中的表格中被发现，但没有找到该技术的描述。然而，您可以在 <a href="https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak">https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak</a> 中检查源代码。</p>
<h3 id="empty-page-leak"><a class="header" href="#empty-page-leak">Empty Page Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 页面内容</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 空响应不会创建资源时间条目。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak">https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak</a></li>
</ul>
<p>攻击者可以检测请求是否导致空的 HTTP 响应体，因为<strong>空页面在某些浏览器中不会创建性能条目</strong>。</p>
<h3 id="xss-auditor-leak"><a class="header" href="#xss-auditor-leak"><strong>XSS-Auditor Leak</strong></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 页面内容</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 在安全声明中使用 XSS 审计器，攻击者可以通过观察在构造的有效负载触发审计器的过滤机制时响应的变化来检测特定网页元素。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak">https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak</a></li>
</ul>
<p>在安全声明 (SA) 中，XSS 审计器最初旨在防止跨站脚本 (XSS) 攻击，但可以悖论地被利用来泄露敏感信息。尽管此内置功能已从 Google Chrome (GC) 中删除，但在 SA 中仍然存在。2013 年，Braun 和 Heiderich 证明 XSS 审计器可能会意外阻止合法脚本，导致误报。在此基础上，研究人员开发了提取信息和检测跨源页面特定内容的技术，这一概念被称为 XS-Leaks，最初由 Terada 报告，并由 Heyes 在博客文章中详细阐述。尽管这些技术特定于 GC 中的 XSS 审计器，但发现 SA 中被 XSS 审计器阻止的页面不会在 Performance API 中生成条目，从而揭示了一种可能仍然泄露敏感信息的方法。</p>
<h3 id="x-frame-leak"><a class="header" href="#x-frame-leak">X-Frame Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 头部</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2), <a href="https://xsleaks.github.io/xsleaks/examples/x-frame/index.html">https://xsleaks.github.io/xsleaks/examples/x-frame/index.html</a>, <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options</a></li>
<li><strong>Summary:</strong> 带有 X-Frame-Options 头的资源不会创建资源时间条目。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak">https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak</a></li>
</ul>
<p>如果页面<strong>不允许</strong>在<strong>iframe</strong>中<strong>呈现</strong>，则不会<strong>创建性能条目</strong>。因此，攻击者可以检测响应头**<code>X-Frame-Options</code><strong>。<br />
如果使用</strong>embed** <strong>标签</strong>，情况也是如此。</p>
<h3 id="download-detection"><a class="header" href="#download-detection">Download Detection</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 头部</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 下载不会在 Performance API 中创建资源时间条目。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20Download%20Detection">https://xsinator.com/testing.html#Performance%20API%20Download%20Detection</a></li>
</ul>
<p>与描述的 XS-Leak 类似，由于 ContentDisposition 头，<strong>下载的资源</strong>也<strong>不会创建性能条目</strong>。此技术在所有主要浏览器中均有效。</p>
<h3 id="redirect-start-leak"><a class="header" href="#redirect-start-leak">Redirect Start Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 重定向</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 资源时间条目泄露重定向的开始时间。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Redirect%20Start%20Leak">https://xsinator.com/testing.html#Redirect%20Start%20Leak</a></li>
</ul>
<p>我们发现一个 XS-Leak 实例，利用某些浏览器记录过多跨源请求信息的行为。标准定义了一组应为跨源资源设置为零的属性。然而，在<strong>SA</strong>中，可以通过查询<strong>Performance API</strong>并检查<strong>redirectStart 时间数据</strong>来检测用户是否被目标页面<strong>重定向</strong>。</p>
<h3 id="duration-redirect-leak"><a class="header" href="#duration-redirect-leak">Duration Redirect Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Fetch API</li>
<li><strong>Detectable Difference</strong>: 重定向</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 当发生重定向时，持续时间的时间条目为负。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Duration%20Redirect%20Leak">https://xsinator.com/testing.html#Duration%20Redirect%20Leak</a></li>
</ul>
<p>在 GC 中，导致<strong>重定向</strong>的请求的<strong>持续时间</strong>为<strong>负</strong>，因此可以与不导致重定向的请求<strong>区分</strong>开来。</p>
<h3 id="corp-leak"><a class="header" href="#corp-leak">CORP Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: 头部</li>
<li><strong>More info</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.2)</li>
<li><strong>Summary:</strong> 受 CORP 保护的资源不会创建资源时间条目。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak">https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak</a></li>
</ul>
<p>在某些情况下，<strong>nextHopProtocol 条目</strong>可以用作泄露技术。在 GC 中，当设置<strong>CORP 头</strong>时，nextHopProtocol 将是<strong>空</strong>的。请注意，SA 对于启用 CORP 的资源根本不会创建性能条目。</p>
<h3 id="service-worker"><a class="header" href="#service-worker">Service Worker</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: API 使用</li>
<li><strong>More info</strong>: <a href="https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/">https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/</a></li>
<li><strong>Summary:</strong> 检测特定源是否注册了服务工作者。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>服务工作者是运行在某个源上的事件驱动脚本上下文。它们在网页的后台运行，可以拦截、修改和<strong>缓存资源</strong>以创建离线 Web 应用程序。<br />
如果通过<strong>iframe</strong>访问<strong>服务工作者</strong>缓存的<strong>资源</strong>，该资源将从<strong>服务工作者缓存</strong>中<strong>加载</strong>。<br />
要检测资源是否<strong>从服务工作者</strong>缓存中<strong>加载</strong>，可以使用<strong>Performance API</strong>。<br />
这也可以通过时间攻击来完成（有关更多信息，请查看论文）。</p>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Fetch API</li>
<li><strong>Detectable Difference</strong>: 时间</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources</a></li>
<li><strong>Summary:</strong> 可以检查资源是否存储在缓存中。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources</a>, <a href="https://xsinator.com/testing.html#Cache%20Leak%20(POST)">https://xsinator.com/testing.html#Cache%20Leak%20(POST)</a></li>
</ul>
<p>使用 <a href="./#performance-api">Performance API</a> 可以检查资源是否被缓存。</p>
<h3 id="network-duration"><a class="header" href="#network-duration">Network Duration</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Fetch API</li>
<li><strong>Detectable Difference</strong>: 页面内容</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration</a></li>
<li><strong>Summary:</strong> 可以从 <code>performance</code> API 中检索请求的网络持续时间。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration">https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration</a></li>
</ul>
<h2 id="error-messages-technique"><a class="header" href="#error-messages-technique">Error Messages Technique</a></h2>
<h3 id="media-error"><a class="header" href="#media-error">Media Error</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements (Video, Audio)</li>
<li><strong>Detectable Difference</strong>: 状态码</li>
<li><strong>More info</strong>: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=828265">https://bugs.chromium.org/p/chromium/issues/detail?id=828265</a></li>
<li><strong>Summary:</strong> 在 Firefox 中，可以准确泄露跨源请求的状态码。</li>
<li><strong>Code Example</strong>: <a href="https://jsbin.com/nejatopusi/1/edit?html,css,js,output">https://jsbin.com/nejatopusi/1/edit?html,css,js,output</a></li>
</ul>
<pre><code class="language-javascript">// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("&lt;strong&gt;Status: " + status + "&lt;/strong&gt; (Error code:" + err.code + " / Error Message: " + err.message + ")&lt;br&gt;");
};
audioElement.onerror = errHandler;
}
</code></pre>
<p>The <code>MediaError</code> 接口的 message 属性唯一标识成功加载的资源，具有独特的字符串。攻击者可以通过观察消息内容来利用此特性，从而推断跨源资源的响应状态。</p>
<h3 id="cors-错误"><a class="header" href="#cors-错误">CORS 错误</a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API</li>
<li><strong>可检测差异</strong>: Header</li>
<li><strong>更多信息</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.3)</li>
<li><strong>总结:</strong> 在安全声明 (SA) 中，CORS 错误消息无意中暴露了重定向请求的完整 URL。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#CORS%20Error%20Leak">https://xsinator.com/testing.html#CORS%20Error%20Leak</a></li>
</ul>
<p>此技术使攻击者能够<strong>提取跨源站点重定向的目标</strong>，通过利用基于 Webkit 的浏览器处理 CORS 请求的方式。具体而言，当向目标站点发送<strong>启用 CORS 的请求</strong>，该站点根据用户状态发出重定向，而浏览器随后拒绝该请求时，<strong>重定向目标的完整 URL</strong>会在错误消息中披露。此漏洞不仅揭示了重定向的事实，还暴露了重定向的端点及其可能包含的任何<strong>敏感查询参数</strong>。</p>
<h3 id="sri-错误"><a class="header" href="#sri-错误">SRI 错误</a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API</li>
<li><strong>可检测差异</strong>: Header</li>
<li><strong>更多信息</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.3)</li>
<li><strong>总结:</strong> 在安全声明 (SA) 中，CORS 错误消息无意中暴露了重定向请求的完整 URL。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#SRI%20Error%20Leak">https://xsinator.com/testing.html#SRI%20Error%20Leak</a></li>
</ul>
<p>攻击者可以利用<strong>详细的错误消息</strong>推断跨源响应的大小。这是由于子资源完整性 (SRI) 的机制，该机制使用完整性属性验证从 CDN 获取的资源未被篡改。为了使 SRI 在跨源资源上工作，这些资源必须是<strong>启用 CORS 的</strong>；否则，它们不受完整性检查。在安全声明 (SA) 中，类似于 CORS 错误 XS-Leak，当带有完整性属性的 fetch 请求失败时，可以捕获错误消息。攻击者可以故意<strong>触发此错误</strong>，通过将<strong>虚假的哈希值</strong>分配给任何请求的完整性属性。在 SA 中，结果错误消息无意中揭示了请求资源的内容长度。此信息泄露使攻击者能够识别响应大小的变化，为复杂的 XS-Leak 攻击铺平道路。</p>
<h3 id="csp-违规检测"><a class="header" href="#csp-违规检测">CSP 违规/检测</a></h3>
<ul>
<li><strong>包含方法</strong>: 弹出窗口</li>
<li><strong>可检测差异</strong>: 状态码</li>
<li><strong>更多信息</strong>: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=313737">https://bugs.chromium.org/p/chromium/issues/detail?id=313737</a>, <a href="https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html">https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html</a>, <a href="https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects">https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects</a></li>
<li><strong>总结:</strong> 如果我们访问的受害者网站尝试重定向到不同的域，则 CSP 只允许受害者网站，CSP 将触发可检测的错误。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#CSP%20Violation%20Leak">https://xsinator.com/testing.html#CSP%20Violation%20Leak</a>, <a href="https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation">https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation</a></li>
</ul>
<p>XS-Leak 可以使用 CSP 检测跨源站点是否重定向到不同的源。此泄漏可以检测重定向，但此外，重定向目标的域也会泄漏。此攻击的基本思路是<strong>在攻击者站点上允许目标域</strong>。一旦向目标域发出请求，它<strong>重定向</strong>到跨源域。<strong>CSP 阻止</strong>对其的访问并创建<strong>违规报告作为泄漏技术</strong>。根据浏览器的不同，<strong>此报告可能泄漏重定向的目标位置</strong>。<br />
现代浏览器不会指示重定向到的 URL，但您仍然可以检测到触发了跨源重定向。</p>
<h3 id="缓存"><a class="header" href="#缓存">缓存</a></h3>
<ul>
<li><strong>包含方法</strong>: 框架, 弹出窗口</li>
<li><strong>可检测差异</strong>: 页面内容</li>
<li><strong>更多信息</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events">https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events</a>, <a href="https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html">https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html</a></li>
<li><strong>总结:</strong> 从缓存中清除文件。打开目标页面检查文件是否存在于缓存中。</li>
<li><strong>代码示例:</strong></li>
</ul>
<p>浏览器可能为所有网站使用一个共享缓存。无论其来源如何，都可以推断目标页面是否<strong>请求了特定文件</strong>。</p>
<p>如果一个页面仅在用户登录时加载图像，您可以<strong>使资源失效</strong>（以便如果它被缓存则不再缓存，更多信息链接），<strong>执行请求</strong>以加载该资源，并尝试使用<strong>错误请求</strong>加载该资源（例如，使用过长的 referer 头）。如果资源加载<strong>没有触发任何错误</strong>，则是因为它被<strong>缓存</strong>。</p>
<h3 id="csp-指令"><a class="header" href="#csp-指令">CSP 指令</a></h3>
<ul>
<li><strong>包含方法</strong>: 框架</li>
<li><strong>可检测差异</strong>: Header</li>
<li><strong>更多信息</strong>: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1105875">https://bugs.chromium.org/p/chromium/issues/detail?id=1105875</a></li>
<li><strong>总结:</strong> CSP 头指令可以使用 CSP iframe 属性进行探测，揭示策略细节。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#CSP%20Directive%20Leak">https://xsinator.com/testing.html#CSP%20Directive%20Leak</a></li>
</ul>
<p>Google Chrome (GC) 中的一个新功能允许网页通过在 iframe 元素上设置属性来<strong>提议内容安全策略 (CSP)</strong>，并将策略指令与 HTTP 请求一起传输。通常，嵌入的内容必须<strong>通过 HTTP 头进行授权</strong>，否则将<strong>显示错误页面</strong>。然而，如果 iframe 已经受到 CSP 的管理，并且新提议的策略不更严格，则页面将正常加载。此机制为攻击者打开了一条路径，通过识别错误页面来<strong>检测跨源页面的特定 CSP 指令</strong>。尽管此漏洞被标记为已修复，但我们的发现揭示了一种<strong>新的泄漏技术</strong>，能够检测错误页面，表明根本问题从未完全解决。</p>
<h3 id="corp"><a class="header" href="#corp"><strong>CORP</strong></a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API</li>
<li><strong>可检测差异</strong>: Header</li>
<li><strong>更多信息</strong>: <a href="https://xsleaks.dev/docs/attacks/browser-features/corp/"><strong>https://xsleaks.dev/docs/attacks/browser-features/corp/</strong></a></li>
<li><strong>总结:</strong> 使用跨源资源策略 (CORP) 保护的资源在从不允许的源获取时会抛出错误。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#CORP%20Leak">https://xsinator.com/testing.html#CORP%20Leak</a></li>
</ul>
<p>CORP 头是一个相对较新的网络平台安全功能，当设置时<strong>阻止对给定资源的无 CORS 跨源请求</strong>。可以检测到该头的存在，因为受 CORP 保护的资源在被获取时会<strong>抛出错误</strong>。</p>
<h3 id="corb"><a class="header" href="#corb">CORB</a></h3>
<ul>
<li><strong>包含方法</strong>: HTML 元素</li>
<li><strong>可检测差异</strong>: Headers</li>
<li><strong>更多信息</strong>: <a href="https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header">https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header</a></li>
<li><strong>总结</strong>: CORB 可以允许攻击者检测请求中是否存在**<code>nosniff</code> 头**。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#CORB%20Leak">https://xsinator.com/testing.html#CORB%20Leak</a></li>
</ul>
<p>查看链接以获取有关攻击的更多信息。</p>
<h3 id="cors-错误在源反射错误配置"><a class="header" href="#cors-错误在源反射错误配置">CORS 错误在源反射错误配置 <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a></a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API</li>
<li><strong>可检测差异</strong>: Headers</li>
<li><strong>更多信息</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration">https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration</a></li>
<li><strong>总结</strong>: 如果 Origin 头在 <code>Access-Control-Allow-Origin</code> 头中被反射，则可以检查资源是否已经在缓存中。</li>
<li><strong>代码示例</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration">https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration</a></li>
</ul>
<p>如果<strong>Origin 头</strong>在 <code>Access-Control-Allow-Origin</code> 头中被<strong>反射</strong>，攻击者可以利用此行为尝试在<strong>CORS</strong> 模式下<strong>获取</strong>该<strong>资源</strong>。如果<strong>没有</strong>触发<strong>错误</strong>，则意味着它是<strong>正确地从网络中检索</strong>的，如果触发了错误，则是因为它是<strong>从缓存中访问的</strong>（错误出现是因为缓存保存了一个带有允许原始域而不是攻击者域的 CORS 头的响应）。<br />
请注意，如果原点未被反射但使用了通配符（<code>Access-Control-Allow-Origin: *</code>），则此方法将无效。</p>
<h2 id="可读属性技术"><a class="header" href="#可读属性技术">可读属性技术</a></h2>
<h3 id="fetch-重定向"><a class="header" href="#fetch-重定向">Fetch 重定向</a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API</li>
<li><strong>可检测差异</strong>: 状态码</li>
<li><strong>更多信息</strong>: <a href="https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html">https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html</a></li>
<li><strong>总结:</strong> GC 和 SA 允许在重定向完成后检查响应的类型（opaque-redirect）。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#Fetch%20Redirect%20Leak">https://xsinator.com/testing.html#Fetch%20Redirect%20Leak</a></li>
</ul>
<p>使用 Fetch API 提交请求，设置 <code>redirect: "manual"</code> 和其他参数，可以读取 <code>response.type</code> 属性，如果它等于 <code>opaqueredirect</code>，则响应是重定向。</p>
<h3 id="coop"><a class="header" href="#coop">COOP</a></h3>
<ul>
<li><strong>包含方法</strong>: 弹出窗口</li>
<li><strong>可检测差异</strong>: Header</li>
<li><strong>更多信息</strong>: <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> (5.4), <a href="https://xsleaks.dev/docs/attacks/window-references/">https://xsleaks.dev/docs/attacks/window-references/</a></li>
<li><strong>总结:</strong> 受跨源打开者策略 (COOP) 保护的页面防止跨源交互的访问。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#COOP%20Leak">https://xsinator.com/testing.html#COOP%20Leak</a></li>
</ul>
<p>攻击者能够推断跨源 HTTP 响应中跨源打开者策略 (COOP) 头的存在。COOP 被网络应用程序用于阻止外部站点获取任意窗口引用。可以通过尝试访问**<code>contentWindow</code> 引用<strong>来识别此头的可见性。在 COOP 有条件应用的情况下，</strong><code>opener</code> 属性<strong>成为一个明显的指示器：当 COOP 活动时，它是</strong>未定义的**，而在没有 COOP 的情况下是<strong>定义的</strong>。</p>
<h3 id="url-最大长度---服务器端"><a class="header" href="#url-最大长度---服务器端">URL 最大长度 - 服务器端</a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API, HTML 元素</li>
<li><strong>可检测差异</strong>: 状态码 / 内容</li>
<li><strong>更多信息</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects">https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects</a></li>
<li><strong>总结:</strong> 检测响应中的差异，因为重定向响应长度可能太大，服务器会回复错误并生成警报。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#URL%20Max%20Length%20Leak">https://xsinator.com/testing.html#URL%20Max%20Length%20Leak</a></li>
</ul>
<p>如果服务器端重定向使用<strong>用户输入进行重定向</strong>和<strong>额外数据</strong>。可以检测到这种行为，因为通常<strong>服务器</strong>有<strong>请求长度限制</strong>。如果<strong>用户数据</strong>是<strong>长度 - 1</strong>，因为<strong>重定向</strong>使用<strong>该数据</strong>并<strong>添加</strong>一些<strong>额外</strong>内容，它将触发一个<strong>可通过错误事件检测到的错误</strong>。</p>
<p>如果您以某种方式可以将 cookies 设置给用户，您还可以通过<strong>设置足够的 cookies</strong>（<a href="../hacking-with-cookies/cookie-bomb.html"><strong>cookie bomb</strong></a>）来执行此攻击，因此<strong>正确响应</strong>的<strong>响应大小</strong>增加会触发一个<strong>错误</strong>。在这种情况下，请记住，如果您从同一站点触发此请求，<code>&lt;script&gt;</code> 将自动发送 cookies（因此您可以检查错误）。<br />
有关<strong>cookie bomb + XS-Search</strong>的示例可以在此写作的意图解决方案中找到：<a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended">https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended</a></p>
<p><code>SameSite=None</code> 或处于相同上下文通常是此类攻击所需的。</p>
<h3 id="url-最大长度---客户端"><a class="header" href="#url-最大长度---客户端">URL 最大长度 - 客户端</a></h3>
<ul>
<li><strong>包含方法</strong>: 弹出窗口</li>
<li><strong>可检测差异</strong>: 状态码 / 内容</li>
<li><strong>更多信息</strong>: <a href="https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit">https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit</a></li>
<li><strong>总结:</strong> 检测响应中的差异，因为重定向响应长度可能太大，以至于可以注意到差异。</li>
<li><strong>代码示例</strong>: <a href="https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit">https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit</a></li>
</ul>
<p>根据 <a href="https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length">Chromium 文档</a>，Chrome 的最大 URL 长度为 2MB。</p>
<blockquote>
<p>一般来说，<em>web 平台</em> 对 URL 的长度没有限制（尽管 2^31 是一个常见限制）。<em>Chrome</em> 将 URL 限制为最大长度 <strong>2MB</strong>，出于实际原因并避免在进程间通信中造成拒绝服务问题。</p>
</blockquote>
<p>因此，如果<strong>重定向 URL</strong>在某些情况下响应的大小更大，则可以使其重定向到<strong>大于 2MB 的 URL</strong>以达到<strong>长度限制</strong>。当发生这种情况时，Chrome 会显示一个**<code>about:blank#blocked</code>** 页面。</p>
<p><strong>显著差异</strong>是，如果<strong>重定向</strong>已<strong>完成</strong>，<code>window.origin</code> 会抛出一个<strong>错误</strong>，因为跨源无法访问该信息。然而，如果<strong>限制</strong>被****触发并且加载的页面是**<code>about:blank#blocked</code><strong>，则窗口的</strong><code>origin</code>** 保持为<strong>父级</strong>的值，这是<strong>可访问的信息</strong>。</p>
<p>所有达到<strong>2MB</strong>所需的额外信息可以通过初始 URL 中的<strong>哈希</strong>添加，以便在重定向中<strong>使用</strong>。</p>
<p>{% content-ref url="url-max-length-client-side.md" %}
<a href="url-max-length-client-side.html">url-max-length-client-side.md</a>
{% endcontent-ref %}</p>
<h3 id="最大重定向"><a class="header" href="#最大重定向">最大重定向</a></h3>
<ul>
<li><strong>包含方法</strong>: Fetch API, 框架</li>
<li><strong>可检测差异</strong>: 状态码</li>
<li><strong>更多信息</strong>: <a href="https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76">https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76</a></li>
<li><strong>总结:</strong> 使用浏览器的重定向限制来确定 URL 重定向的发生。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#Max%20Redirect%20Leak">https://xsinator.com/testing.html#Max%20Redirect%20Leak</a></li>
</ul>
<p>如果浏览器的<strong>最大</strong>重定向次数为<strong>20</strong>，攻击者可以尝试用<strong>19 次重定向</strong>加载他的页面，最后<strong>将受害者</strong>发送到测试页面。如果触发了<strong>错误</strong>，则页面试图<strong>重定向受害者</strong>。</p>
<h3 id="历史长度"><a class="header" href="#历史长度">历史长度</a></h3>
<ul>
<li><strong>包含方法</strong>: 框架, 弹出窗口</li>
<li><strong>可检测差异</strong>: 重定向</li>
<li><strong>更多信息</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/">https://xsleaks.dev/docs/attacks/navigations/</a></li>
<li><strong>总结:</strong> JavaScript 代码操纵浏览器历史记录，可以通过长度属性访问。</li>
<li><strong>代码示例</strong>: <a href="https://xsinator.com/testing.html#History%20Length%20Leak">https://xsinator.com/testing.html#History%20Length%20Leak</a></li>
</ul>
<p><strong>历史 API</strong> 允许 JavaScript 代码操纵浏览器历史记录，<strong>保存用户访问的页面</strong>。攻击者可以使用长度属性作为包含方法：检测 JavaScript 和 HTML 导航。<br />
<strong>检查 <code>history.length</code></strong>，使用户<strong>导航</strong>到一个页面，<strong>返回</strong>到同源并<strong>检查</strong>新值的**<code>history.length</code>**。</p>
<h3 id="同一-url-的历史长度"><a class="header" href="#同一-url-的历史长度">同一 URL 的历史长度</a></h3>
<ul>
<li><strong>包含方法</strong>: 框架, 弹出窗口</li>
<li><strong>可检测差异</strong>: 如果 URL 与猜测的 URL 相同</li>
<li><strong>总结:</strong> 可以通过历史长度的滥用来猜测框架/弹出窗口的位置是否在特定 URL 中。</li>
<li><strong>代码示例</strong>: 以下</li>
</ul>
<p>攻击者可以使用 JavaScript 代码<strong>操纵框架/弹出窗口的位置到猜测的 URL</strong>，并<strong>立即</strong>将其<strong>更改为 <code>about:blank</code></strong>。如果历史长度增加，则意味着 URL 是正确的，并且有时间<strong>增加，因为如果 URL 相同则不会重新加载</strong>。如果没有增加，则意味着它<strong>尝试加载猜测的 URL</strong>，但因为我们<strong>立即之后</strong>加载了**<code>about:blank</code><strong>，所以</strong>历史长度在加载猜测的 URL 时从未增加**。</p>
<pre><code class="language-javascript">async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r =&gt; setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r =&gt; setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r =&gt; setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
</code></pre>
<h3 id="frame-counting"><a class="header" href="#frame-counting">Frame Counting</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames, Pop-ups</li>
<li><strong>Detectable Difference</strong>: Page Content</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/frame-counting/">https://xsleaks.dev/docs/attacks/frame-counting/</a></li>
<li><strong>Summary:</strong> 通过检查 <code>window.length</code> 属性评估 iframe 元素的数量。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#Frame%20Count%20Leak">https://xsinator.com/testing.html#Frame%20Count%20Leak</a></li>
</ul>
<p>计算通过 <code>iframe</code> 或 <code>window.open</code> 打开的 <strong>网页中的框架数量</strong> 可能有助于识别 <strong>用户在该页面上的状态</strong>。<br />
此外，如果页面始终具有相同数量的框架，<strong>持续</strong> 检查框架数量可能有助于识别可能泄露信息的 <strong>模式</strong>。</p>
<p>这种技术的一个例子是，在 Chrome 中，<strong>PDF</strong> 可以通过 <strong>框架计数</strong> 被 <strong>检测到</strong>，因为内部使用了 <code>embed</code>。有一些 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113">Open URL Parameters</a> 允许对内容进行一些控制，例如 <code>zoom</code>、<code>view</code>、<code>page</code>、<code>toolbar</code>，在这种情况下，这种技术可能会很有趣。</p>
<h3 id="htmlelements"><a class="header" href="#htmlelements">HTMLElements</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements</li>
<li><strong>Detectable Difference</strong>: Page Content</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/">https://xsleaks.dev/docs/attacks/element-leaks/</a></li>
<li><strong>Summary:</strong> 读取泄露的值以区分两种可能的状态</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/">https://xsleaks.dev/docs/attacks/element-leaks/</a>, <a href="https://xsinator.com/testing.html#Media%20Dimensions%20Leak">https://xsinator.com/testing.html#Media%20Dimensions%20Leak</a>, <a href="https://xsinator.com/testing.html#Media%20Duration%20Leak">https://xsinator.com/testing.html#Media%20Duration%20Leak</a></li>
</ul>
<p>通过 HTML 元素的信息泄露是网络安全中的一个问题，特别是当动态媒体文件基于用户信息生成时，或者当添加水印时，改变媒体大小。攻击者可以利用这一点，通过分析某些 HTML 元素暴露的信息来区分可能的状态。</p>
<h3 id="information-exposed-by-html-elements"><a class="header" href="#information-exposed-by-html-elements">Information Exposed by HTML Elements</a></h3>
<ul>
<li><strong>HTMLMediaElement</strong>: 此元素揭示媒体的 <code>duration</code> 和 <code>buffered</code> 时间，可以通过其 API 访问。<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement">了解更多关于 HTMLMediaElement 的信息</a></li>
<li><strong>HTMLVideoElement</strong>: 它暴露 <code>videoHeight</code> 和 <code>videoWidth</code>。在某些浏览器中，像 <code>webkitVideoDecodedByteCount</code>、<code>webkitAudioDecodedByteCount</code> 和 <code>webkitDecodedFrameCount</code> 等附加属性可用，提供有关媒体内容的更深入信息。<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement">了解更多关于 HTMLVideoElement 的信息</a></li>
<li><strong>getVideoPlaybackQuality()</strong>: 此函数提供有关视频播放质量的详细信息，包括 <code>totalVideoFrames</code>，这可以指示处理的视频数据量。<a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality">了解更多关于 getVideoPlaybackQuality() 的信息</a></li>
<li><strong>HTMLImageElement</strong>: 此元素泄露图像的 <code>height</code> 和 <code>width</code>。但是，如果图像无效，这些属性将返回 0，并且 <code>image.decode()</code> 函数将被拒绝，表示未能正确加载图像。<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement">了解更多关于 HTMLImageElement 的信息</a></li>
</ul>
<h3 id="css-property"><a class="header" href="#css-property">CSS Property</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements</li>
<li><strong>Detectable Difference</strong>: Page Content</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle">https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle</a>, <a href="https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html">https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html</a></li>
<li><strong>Summary:</strong> 识别与用户状态或状态相关的网站样式变化。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#CSS%20Property%20Leak">https://xsinator.com/testing.html#CSS%20Property%20Leak</a></li>
</ul>
<p>Web 应用程序可能会根据用户的状态更改 <strong>网站样式</strong>。跨域 CSS 文件可以通过 <strong>HTML link 元素</strong> 嵌入到攻击者页面中，<strong>规则</strong> 将被 <strong>应用</strong> 到攻击者页面。如果页面动态更改这些规则，攻击者可以根据用户状态 <strong>检测</strong> 这些 <strong>差异</strong>。<br />
作为一种泄露技术，攻击者可以使用 <code>window.getComputedStyle</code> 方法 <strong>读取特定 HTML 元素的 CSS</strong> 属性。因此，如果已知受影响的元素和属性名称，攻击者可以读取任意 CSS 属性。</p>
<h3 id="css-history"><a class="header" href="#css-history">CSS History</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements</li>
<li><strong>Detectable Difference</strong>: Page Content</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history">https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history</a></li>
<li><strong>Summary:</strong> 检测 <code>:visited</code> 样式是否应用于 URL，指示其已被访问</li>
<li><strong>Code Example</strong>: <a href="http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html">http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html</a></li>
</ul>
<p>{% hint style="info" %}
根据 <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/"><strong>这个</strong></a>，在无头 Chrome 中这不起作用。
{% endhint %}</p>
<p>CSS <code>:visited</code> 选择器用于对用户之前访问过的 URL 进行不同的样式。在过去，可以使用 <code>getComputedStyle()</code> 方法来识别这些样式差异。然而，现代浏览器已实施安全措施，以防止此方法泄露链接的状态。这些措施包括始终返回计算样式，仿佛链接已被访问，并限制可以使用 <code>:visited</code> 选择器应用的样式。</p>
<p>尽管有这些限制，但可以间接识别链接的访问状态。一种技术涉及诱使用户与受 CSS 影响的区域进行交互，特别是利用 <code>mix-blend-mode</code> 属性。该属性允许元素与其背景混合，可能根据用户交互揭示访问状态。</p>
<p>此外，可以通过利用链接的渲染时间来实现无用户交互的检测。由于浏览器可能以不同方式渲染已访问和未访问的链接，这可能在渲染中引入可测量的时间差。一个概念证明（PoC）在 Chromium 错误报告中提到，演示了使用多个链接来放大时间差，从而通过时间分析使访问状态可检测。</p>
<p>有关这些属性和方法的更多详细信息，请访问其文档页面：</p>
<ul>
<li><code>:visited</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:visited">MDN Documentation</a></li>
<li><code>getComputedStyle()</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">MDN Documentation</a></li>
<li><code>mix-blend-mode</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode">MDN Documentation</a></li>
</ul>
<h3 id="contentdocument-x-frame-leak"><a class="header" href="#contentdocument-x-frame-leak">ContentDocument X-Frame Leak</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames</li>
<li><strong>Detectable Difference</strong>: Headers</li>
<li><strong>More info</strong>: <a href="https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf">https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf</a></li>
<li><strong>Summary:</strong> 在 Google Chrome 中，当由于 X-Frame-Options 限制而阻止页面嵌入到跨域站点时，会显示专用错误页面。</li>
<li><strong>Code Example</strong>: <a href="https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak">https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak</a></li>
</ul>
<p>在 Chrome 中，如果一个带有 <code>X-Frame-Options</code> 头设置为 "deny" 或 "same-origin" 的页面作为对象嵌入，则会出现错误页面。Chrome 独特地为该对象的 <code>contentDocument</code> 属性返回一个空文档对象（而不是 <code>null</code>），这与在 iframe 或其他浏览器中的表现不同。攻击者可以通过检测空文档来利用这一点，可能揭示有关用户状态的信息，特别是如果开发人员不一致地设置 X-Frame-Options 头，通常会忽略错误页面。意识到并一致应用安全头对于防止此类泄露至关重要。</p>
<h3 id="download-detection-1"><a class="header" href="#download-detection-1">Download Detection</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Frames, Pop-ups</li>
<li><strong>Detectable Difference</strong>: Headers</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#download-trigger">https://xsleaks.dev/docs/attacks/navigations/#download-trigger</a></li>
<li><strong>Summary:</strong> 攻击者可以通过利用 iframe 来识别文件下载；iframe 的持续可访问性意味着文件下载成功。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#download-bar">https://xsleaks.dev/docs/attacks/navigations/#download-bar</a></li>
</ul>
<p><code>Content-Disposition</code> 头，特别是 <code>Content-Disposition: attachment</code>，指示浏览器下载内容而不是内联显示。这种行为可以被利用来检测用户是否可以访问触发文件下载的页面。在基于 Chromium 的浏览器中，有几种技术可以检测这种下载行为：</p>
<ol>
<li><strong>下载栏监控</strong>：</li>
</ol>
<ul>
<li>当文件在基于 Chromium 的浏览器中下载时，浏览器窗口底部会出现下载栏。</li>
<li>通过监控窗口高度的变化，攻击者可以推断下载栏的出现，表明下载已启动。</li>
</ul>
<ol start="2">
<li><strong>使用 iframe 的下载导航</strong>：</li>
</ol>
<ul>
<li>当页面使用 <code>Content-Disposition: attachment</code> 头触发文件下载时，它不会导致导航事件。</li>
<li>通过在 iframe 中加载内容并监控导航事件，可以检查内容处置是否导致文件下载（无导航）或不是。</li>
</ul>
<ol start="3">
<li><strong>不使用 iframe 的下载导航</strong>：</li>
</ol>
<ul>
<li>与 iframe 技术类似，此方法涉及使用 <code>window.open</code> 而不是 iframe。</li>
<li>监控新打开窗口中的导航事件可以揭示是否触发了文件下载（无导航）或内容是否内联显示（发生导航）。</li>
</ul>
<p>在只有登录用户可以触发此类下载的情况下，这些技术可以用来间接推断用户的身份验证状态，基于浏览器对下载请求的响应。</p>
<h3 id="partitioned-http-cache-bypass"><a class="header" href="#partitioned-http-cache-bypass">Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Pop-ups</li>
<li><strong>Detectable Difference</strong>: Timing</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass">https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass</a></li>
<li><strong>Summary:</strong> 攻击者可以通过利用 iframe 来识别文件下载；iframe 的持续可访问性意味着文件下载成功。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass">https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass</a>, <a href="https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722">https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722</a> (来自 <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/">https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/</a>)</li>
</ul>
<p>{% hint style="warning" %}
这就是为什么这个技术很有趣：Chrome 现在有 <strong>缓存分区</strong>，新打开页面的缓存键是：<code>(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)</code>，但如果我打开一个 ngrok 页面并在其中使用 fetch，缓存键将是：<code>(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)</code>，<strong>缓存键是不同的</strong>，因此缓存不能共享。您可以在这里找到更多详细信息：<a href="https://developer.chrome.com/blog/http-cache-partitioning/">通过分区缓存获得安全性和隐私</a><br />
（来自 <a href="https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/"><strong>这里</strong></a> 的评论）
{% endhint %}</p>
<p>如果一个站点 <code>example.com</code> 包含来自 <code>*.example.com/resource</code> 的资源，那么该资源将具有与通过顶级导航直接 <strong>请求</strong> 该资源时 <strong>相同的缓存键</strong>。这是因为缓存键由顶级 <em>eTLD+1</em> 和框架 <em>eTLD+1</em> 组成。</p>
<p>因为访问缓存比加载资源更快，所以可以尝试更改页面的位置并在 20 毫秒后取消它（例如）。如果在停止后更改了源，则意味着资源已被缓存。<br />
或者可以 <strong>向可能被缓存的页面发送一些 fetch 并测量所需时间</strong>。</p>
<h3 id="manual-redirect"><a class="header" href="#manual-redirect">Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Fetch API</li>
<li><strong>Detectable Difference</strong>: Redirects</li>
<li><strong>More info</strong>: <a href="https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234">ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234</a></li>
<li><strong>Summary:</strong> 可以找出 fetch 请求的响应是否为重定向</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p><img src="../../.gitbook/assets/image%20(769).png" alt="" /></p>
<h3 id="fetch-with-abortcontroller"><a class="header" href="#fetch-with-abortcontroller">Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Fetch API</li>
<li><strong>Detectable Difference</strong>: Timing</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller">https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller</a></li>
<li><strong>Summary:</strong> 可以尝试加载资源，并在加载之前中断加载。根据是否触发错误，资源可能已被缓存或未被缓存。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller">https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller</a></li>
</ul>
<p>使用 <em><strong>fetch</strong></em> 和 <em><strong>setTimeout</strong></em> 结合 <strong>AbortController</strong> 来检测 <strong>资源是否被缓存</strong> 并将特定资源从浏览器缓存中驱逐。此外，该过程在不缓存新内容的情况下进行。</p>
<h3 id="script-pollution"><a class="header" href="#script-pollution">Script Pollution</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: HTML Elements (script)</li>
<li><strong>Detectable Difference</strong>: Page Content</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/#script-tag">https://xsleaks.dev/docs/attacks/element-leaks/#script-tag</a></li>
<li><strong>Summary:</strong> 可以 <strong>覆盖内置函数</strong> 并读取其参数，即使是来自 <strong>跨域脚本</strong>（无法直接读取），这可能 <strong>泄露有价值的信息</strong>。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/element-leaks/#script-tag">https://xsleaks.dev/docs/attacks/element-leaks/#script-tag</a></li>
</ul>
<h3 id="service-workers"><a class="header" href="#service-workers">Service Workers <a href="#service-workers" id="service-workers"></a></a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Pop-ups</li>
<li><strong>Detectable Difference</strong>: Page Content</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers">https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers</a></li>
<li><strong>Summary:</strong> 测量使用服务工作者的网页的执行时间。</li>
<li><strong>Code Example</strong>:</li>
</ul>
<p>在给定的场景中，攻击者主动在其域名之一（特别是 "attacker.com"）中注册一个 <strong>服务工作者</strong>。接下来，攻击者从主文档中在目标网站打开一个新窗口，并指示 <strong>服务工作者</strong> 开始计时器。当新窗口开始加载时，攻击者将前一步获得的引用导航到由 <strong>服务工作者</strong> 管理的页面。</p>
<p>在前一步发起的请求到达时，<strong>服务工作者</strong> 以 <strong>204 (No Content)</strong> 状态码响应，有效地终止导航过程。此时，<strong>服务工作者</strong> 捕获从第二步开始的计时器的测量。该测量受 JavaScript 导致的导航过程延迟的影响。</p>
<p>{% hint style="warning" %}
在执行计时中，可以 <strong>消除</strong> <strong>网络因素</strong> 以获得 <strong>更精确的测量</strong>。例如，通过在加载页面之前加载页面使用的资源。
{% endhint %}</p>
<h3 id="fetch-timing"><a class="header" href="#fetch-timing">Fetch Timing</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Fetch API</li>
<li><strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks</a></li>
<li><strong>Summary:</strong> 使用 <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow">performance.now()</a> 测量执行请求所需的时间。可以使用其他时钟。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks</a></li>
</ul>
<h3 id="cross-window-timing"><a class="header" href="#cross-window-timing">Cross-Window Timing</a></h3>
<ul>
<li><strong>Inclusion Methods</strong>: Pop-ups</li>
<li><strong>Detectable Difference</strong>: Timing (generally due to Page Content, Status Code)</li>
<li><strong>More info</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks</a></li>
<li><strong>Summary:</strong> 使用 <a href="https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow">performance.now()</a> 测量使用 <code>window.open</code> 执行请求所需的时间。可以使用其他时钟。</li>
<li><strong>Code Example</strong>: <a href="https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks">https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks</a></li>
</ul>
<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p><br />
使用 <a href="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=text&amp;utm_campaign=ppc&amp;utm_content=xs-search"><strong>Trickest</strong></a> 轻松构建和 <strong>自动化工作流</strong>，由世界上 <strong>最先进</strong> 的社区工具提供支持。<br />
立即获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=xs-search" %}</p>
<h2 id="with-html-or-re-injection"><a class="header" href="#with-html-or-re-injection">With HTML or Re Injection</a></h2>
<p>在这里，您可以找到从跨域 HTML <strong>注入 HTML 内容</strong> 中提取信息的技术。这些技术在您因任何原因可以 <strong>注入 HTML 但无法注入 JS 代码</strong> 的情况下很有趣。</p>
<h3 id="dangling-markup"><a class="header" href="#dangling-markup">Dangling Markup</a></h3>
<p>{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
<a href="../dangling-markup-html-scriptless-injection/">dangling-markup-html-scriptless-injection</a>
{% endcontent-ref %}</p>
<h3 id="image-lazy-loading"><a class="header" href="#image-lazy-loading">Image Lazy Loading</a></h3>
<p>如果您需要 <strong>提取内容</strong> 并且可以 <strong>在秘密之前添加 HTML</strong>，您应该检查 <strong>常见的悬挂标记技术</strong>。<br />
但是，如果出于某种原因您 <strong>必须</strong> 逐个字符地进行（也许通信是通过缓存命中），您可以使用这个技巧。</p>
<p><strong>图像</strong> 在 HTML 中具有一个 "<strong>loading</strong>" 属性，其值可以是 "<strong>lazy</strong>"。在这种情况下，图像将在查看时加载，而不是在页面加载时：</p>
<pre><code class="language-html">&lt;img src=/something loading=lazy &gt;
</code></pre>
<p>因此，您可以做的是<strong>添加大量垃圾字符</strong>（例如<strong>成千上万的"W"</strong>）来<strong>填充网页在秘密之前，或者添加类似</strong><code>&lt;br&gt;&lt;canvas height="1850px"&gt;&lt;/canvas&gt;&lt;br&gt;</code><strong>的内容。</strong><br />
然后，如果例如我们的<strong>注入出现在标志之前</strong>，<strong>图像</strong>将会<strong>加载</strong>，但如果出现在<strong>标志之后</strong>，标志 + 垃圾将<strong>阻止其加载</strong>（您需要调整放置多少垃圾）。这就是在<a href="https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/"><strong>这篇文章</strong></a>中发生的事情。</p>
<p>另一个选项是使用<strong>scroll-to-text-fragment</strong>，如果允许的话：</p>
<h4 id="scroll-to-text-fragment"><a class="header" href="#scroll-to-text-fragment">Scroll-to-text-fragment</a></h4>
<p>但是，您让<strong>机器人访问页面</strong>时使用类似</p>
<pre><code>#:~:text=SECR
</code></pre>
<p>所以网页将是这样的：<strong><code>https://victim.com/post.html#:~:text=SECR</code></strong></p>
<p>其中 post.html 包含攻击者的垃圾字符和懒加载图像，然后添加机器人的秘密。</p>
<p>这段文本的作用是让机器人访问页面中包含文本 <code>SECR</code> 的任何文本。由于该文本是秘密，并且它就在 <strong>图像下方</strong>，因此 <strong>只有在猜测的秘密正确时，图像才会加载</strong>。所以你就有了你的神谕来 <strong>逐字符提取秘密</strong>。</p>
<p>一些利用此漏洞的代码示例：<a href="https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e">https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e</a></p>
<h3 id="基于图像懒加载时间"><a class="header" href="#基于图像懒加载时间">基于图像懒加载时间</a></h3>
<p>如果 <strong>无法加载外部图像</strong>，这可能会向攻击者指示图像已加载，另一种选择是尝试 <strong>多次猜测字符并测量</strong>。如果图像加载，所有请求的时间将比图像未加载时更长。这就是在 <a href="https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/"><strong>此写作的解决方案中</strong></a> <strong>总结的内容：</strong></p>
<p>{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
<a href="event-loop-blocking-+-lazy-images.html">event-loop-blocking-+-lazy-images.md</a>
{% endcontent-ref %}</p>
<h3 id="redos"><a class="header" href="#redos">ReDoS</a></h3>
<p>{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
<a href="../regular-expression-denial-of-service-redos.html">regular-expression-denial-of-service-redos.md</a>
{% endcontent-ref %}</p>
<h3 id="css-redos"><a class="header" href="#css-redos">CSS ReDoS</a></h3>
<p>如果使用 <code>jQuery(location.hash)</code>，可以通过计时来判断 <strong>是否存在某些 HTML 内容</strong>，这是因为如果选择器 <code>main[id='site-main']</code> 不匹配，则不需要检查其余的 <strong>选择器</strong>：</p>
<pre><code class="language-javascript">$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
</code></pre>
<h3 id="css-注入"><a class="header" href="#css-注入">CSS 注入</a></h3>
<p>{% content-ref url="css-injection/" %}
<a href="css-injection/">css-injection</a>
{% endcontent-ref %}</p>
<h2 id="防御"><a class="header" href="#防御">防御</a></h2>
<p>在 <a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a> 和每个 wiki 部分 <a href="https://xsleaks.dev/">https://xsleaks.dev/</a> 中推荐了一些缓解措施。请查看那里以获取有关如何防止这些技术的更多信息。</p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://xsinator.com/paper.pdf">https://xsinator.com/paper.pdf</a></li>
<li><a href="https://xsleaks.dev">https://xsleaks.dev/</a></li>
<li><a href="https://github.com/xsleaks/xsleaks">https://github.com/xsleaks/xsleaks</a></li>
<li><a href="https://xsinator.com/">https://xsinator.com/</a></li>
<li><a href="https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle">https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle</a></li>
</ul>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>telegram 群组</strong></a> 或 <strong>在</strong> <strong>Twitter</strong> 🐦 <strong>上关注我们</strong> <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p><br />
使用 <a href="https://trickest.com/?utm_campaign=hacktrics&amp;utm_medium=banner&amp;utm_source=hacktricks"><strong>Trickest</strong></a> 轻松构建和 <strong>自动化工作流程</strong>，由世界上 <strong>最先进</strong> 的社区工具提供支持。<br />
立即获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=xs-search" %}</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pentesting-web/xssi-cross-site-script-inclusion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pentesting-web/xs-search/connection-pool-example.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pentesting-web/xssi-cross-site-script-inclusion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pentesting-web/xs-search/connection-pool-example.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
